function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/******/
(function (modules) {
  // webpackBootstrap

  /******/
  // install a JSONP callback for chunk loading

  /******/
  function webpackJsonpCallback(data) {
    /******/
    var chunkIds = data[0];
    /******/

    var moreModules = data[1];
    /******/

    /******/

    /******/
    // add "moreModules" to the modules object,

    /******/
    // then flag all "chunkIds" as loaded and fire callback

    /******/

    var moduleId,
        chunkId,
        i = 0,
        resolves = [];
    /******/

    for (; i < chunkIds.length; i++) {
      /******/
      chunkId = chunkIds[i];
      /******/

      if (Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
        /******/
        resolves.push(installedChunks[chunkId][0]);
        /******/
      }
      /******/


      installedChunks[chunkId] = 0;
      /******/
    }
    /******/


    for (moduleId in moreModules) {
      /******/
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        /******/
        modules[moduleId] = moreModules[moduleId];
        /******/
      }
      /******/

    }
    /******/


    if (parentJsonpFunction) parentJsonpFunction(data);
    /******/

    /******/

    while (resolves.length) {
      /******/
      resolves.shift()();
      /******/
    }
    /******/

    /******/

  }

  ;
  /******/

  /******/

  /******/
  // The module cache

  /******/

  var installedModules = {};
  /******/

  /******/
  // object to store loaded and loading chunks

  /******/
  // undefined = chunk not loaded, null = chunk preloaded/prefetched

  /******/
  // Promise = chunk loading, 0 = chunk loaded

  /******/

  var installedChunks = {
    /******/
    "main": 0
    /******/

  };
  /******/

  /******/

  /******/

  /******/
  // script path function

  /******/

  function jsonpScriptSrc(chunkId) {
    /******/
    return __webpack_require__.p + "" + ({}[chunkId] || chunkId) + "-es2015.js";
    /******/
  }
  /******/

  /******/
  // The require function

  /******/


  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/
  // This file contains only the entry chunk.

  /******/
  // The chunk loading function for additional chunks

  /******/


  __webpack_require__.e = function requireEnsure(chunkId) {
    /******/
    var promises = [];
    /******/

    /******/

    /******/
    // JSONP chunk loading for javascript

    /******/

    /******/

    var installedChunkData = installedChunks[chunkId];
    /******/

    if (installedChunkData !== 0) {
      // 0 means "already installed".

      /******/

      /******/
      // a Promise means "currently loading".

      /******/
      if (installedChunkData) {
        /******/
        promises.push(installedChunkData[2]);
        /******/
      } else {
        /******/
        // setup Promise in chunk cache

        /******/
        var promise = new Promise(function (resolve, reject) {
          /******/
          installedChunkData = installedChunks[chunkId] = [resolve, reject];
          /******/
        });
        /******/

        promises.push(installedChunkData[2] = promise);
        /******/

        /******/
        // start chunk loading

        /******/

        var script = document.createElement('script');
        /******/

        var onScriptComplete;
        /******/

        /******/

        script.charset = 'utf-8';
        /******/

        script.timeout = 120;
        /******/

        if (__webpack_require__.nc) {
          /******/
          script.setAttribute("nonce", __webpack_require__.nc);
          /******/
        }
        /******/


        script.src = jsonpScriptSrc(chunkId);
        /******/

        /******/
        // create error before stack unwound to get useful stacktrace later

        /******/

        var error = new Error();
        /******/

        onScriptComplete = function onScriptComplete(event) {
          /******/
          // avoid mem leaks in IE.

          /******/
          script.onerror = script.onload = null;
          /******/

          clearTimeout(timeout);
          /******/

          var chunk = installedChunks[chunkId];
          /******/

          if (chunk !== 0) {
            /******/
            if (chunk) {
              /******/
              var errorType = event && (event.type === 'load' ? 'missing' : event.type);
              /******/

              var realSrc = event && event.target && event.target.src;
              /******/

              error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
              /******/

              error.name = 'ChunkLoadError';
              /******/

              error.type = errorType;
              /******/

              error.request = realSrc;
              /******/

              chunk[1](error);
              /******/
            }
            /******/


            installedChunks[chunkId] = undefined;
            /******/
          }
          /******/

        };
        /******/


        var timeout = setTimeout(function () {
          /******/
          onScriptComplete({
            type: 'timeout',
            target: script
          });
          /******/
        }, 120000);
        /******/

        script.onerror = script.onload = onScriptComplete;
        /******/

        document.head.appendChild(script);
        /******/
      }
      /******/

    }
    /******/


    return Promise.all(promises);
    /******/
  };
  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "";
  /******/

  /******/
  // on error function for async loading

  /******/

  __webpack_require__.oe = function (err) {
    console.error(err);
    throw err;
  };
  /******/

  /******/


  var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
  /******/

  var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
  /******/

  jsonpArray.push = webpackJsonpCallback;
  /******/

  jsonpArray = jsonpArray.slice();
  /******/

  for (var i = 0; i < jsonpArray.length; i++) {
    webpackJsonpCallback(jsonpArray[i]);
  }
  /******/


  var parentJsonpFunction = oldJsonpFunction;
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 0);
  /******/
})(
/************************************************************************/

/******/
{
  /***/
  "../../libs/shared/vendors/src/index.ts":
  /*!*******************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/libs/shared/vendors/src/index.ts ***!
    \*******************************************************************************/

  /*! exports provided: SharedVendorsModule */

  /***/
  function libsSharedVendorsSrcIndexTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var _lib_shared_vendors_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./lib/shared-vendors.module */
    "../../libs/shared/vendors/src/lib/shared-vendors.module.ts");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "SharedVendorsModule", function () {
      return _lib_shared_vendors_module__WEBPACK_IMPORTED_MODULE_0__["SharedVendorsModule"];
    });
    /***/

  },

  /***/
  "../../libs/shared/vendors/src/lib/shared-vendors.module.ts":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/libs/shared/vendors/src/lib/shared-vendors.module.ts ***!
    \***************************************************************************************************/

  /*! exports provided: SharedVendorsModule */

  /***/
  function libsSharedVendorsSrcLibSharedVendorsModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SharedVendorsModule", function () {
      return SharedVendorsModule;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var hammerjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! hammerjs */
    "../../node_modules/hammerjs/hammer.js");
    /* harmony import */


    var hammerjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_1__); // Angular Material

    /**
     * 3rd party librairies integrations in the project.
     */


    var SharedVendorsModule = function SharedVendorsModule() {
      _classCallCheck(this, SharedVendorsModule);
    };

    SharedVendorsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: SharedVendorsModule
    });
    SharedVendorsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function SharedVendorsModule_Factory(t) {
        return new (t || SharedVendorsModule)();
      }
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SharedVendorsModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{}]
      }], null, null);
    })();
    /***/

  },

  /***/
  "../../libs/webcomponents/src/index.ts":
  /*!******************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/libs/webcomponents/src/index.ts ***!
    \******************************************************************************/

  /*! exports provided: WEB_COMPONENTS_REGISTRY, WebComponentsModule */

  /***/
  function libsWebcomponentsSrcIndexTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var _lib_web_components_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./lib/web-components-registry */
    "../../libs/webcomponents/src/lib/web-components-registry.ts");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "WEB_COMPONENTS_REGISTRY", function () {
      return _lib_web_components_registry__WEBPACK_IMPORTED_MODULE_0__["WEB_COMPONENTS_REGISTRY"];
    });
    /* harmony import */


    var _lib_web_components_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./lib/web-components.module */
    "../../libs/webcomponents/src/lib/web-components.module.ts");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "WebComponentsModule", function () {
      return _lib_web_components_module__WEBPACK_IMPORTED_MODULE_1__["WebComponentsModule"];
    });
    /***/

  },

  /***/
  "../../libs/webcomponents/src/lib/web-components-loader.component.ts":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/libs/webcomponents/src/lib/web-components-loader.component.ts ***!
    \************************************************************************************************************/

  /*! exports provided: WebComponentLoaderComponent */

  /***/
  function libsWebcomponentsSrcLibWebComponentsLoaderComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WebComponentLoaderComponent", function () {
      return WebComponentLoaderComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "../../node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var _juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @juristr/ngx-lazy-el */
    "../../node_modules/@juristr/ngx-lazy-el/__ivy_ngcc__/fesm2015/juristr-ngx-lazy-el.js");
    /**
     * Dynamically detect and lazy load web components in the dom.
     */


    var WebComponentLoaderComponent = /*#__PURE__*/function () {
      function WebComponentLoaderComponent(componentLoader) {
        _classCallCheck(this, WebComponentLoaderComponent);

        this.componentLoader = componentLoader;
      }

      _createClass(WebComponentLoaderComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.lazyLoadWebComponents();
          this.observeWebComponents();
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _a;

          (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();

          if (this.listener) {
            this.listener();
          }
        }
        /**
         * Detect the web components during the initial load of the page and lazy load them.
         * @returns A promise that resolves with a list of the remaining unloaded element selectors
         */

      }, {
        key: "lazyLoadWebComponents",
        value: function lazyLoadWebComponents() {
          var _this = this;

          var listener = function listener() {
            setTimeout(function () {
              return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                var _this2 = this;

                var unloadedTags, _iterator, _step, _loop;

                return regeneratorRuntime.wrap(function _callee$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        unloadedTags = Array.from(this.componentLoader.getComponentsToLoad());
                        _iterator = _createForOfIteratorHelper(unloadedTags);
                        _context2.prev = 2;
                        _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                          var tagName, tags;
                          return regeneratorRuntime.wrap(function _loop$(_context) {
                            while (1) {
                              switch (_context.prev = _context.next) {
                                case 0:
                                  tagName = _step.value;
                                  tags = document.getElementsByTagName(tagName);

                                  if (!(tags === null || tags === void 0 ? void 0 : tags.length)) {
                                    _context.next = 6;
                                    break;
                                  }

                                  _context.next = 5;
                                  return _this2.componentLoader.loadComponent(tagName);

                                case 5:
                                  unloadedTags = unloadedTags.filter(function (e) {
                                    return e !== tagName;
                                  });

                                case 6:
                                case "end":
                                  return _context.stop();
                              }
                            }
                          }, _loop);
                        });

                        _iterator.s();

                      case 5:
                        if ((_step = _iterator.n()).done) {
                          _context2.next = 9;
                          break;
                        }

                        return _context2.delegateYield(_loop(), "t0", 7);

                      case 7:
                        _context2.next = 5;
                        break;

                      case 9:
                        _context2.next = 14;
                        break;

                      case 11:
                        _context2.prev = 11;
                        _context2.t1 = _context2["catch"](2);

                        _iterator.e(_context2.t1);

                      case 14:
                        _context2.prev = 14;

                        _iterator.f();

                        return _context2.finish(14);

                      case 17:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee, this, [[2, 11, 14, 17]]);
              }));
            });
          };

          document.addEventListener('DOMContentLoaded', listener);

          this.listener = function () {
            document.removeEventListener('DOMContentLoaded', listener);
          };
        }
        /**
         * Detect the web components insertion in the dom using MutationObserver API.
         * Each time a web component is inserted to the dom, this method will load the bundle associated
         * to the web component if it's the first time.
         */

      }, {
        key: "observeWebComponents",
        value: function observeWebComponents() {
          var _this3 = this;

          var target = document.body;
          var unloadedTags = Array.from(this.componentLoader.getComponentsToLoad());
          this.observer = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
              mutation.addedNodes.forEach(function (node) {
                if (node instanceof HTMLElement) {
                  var tagName = node.tagName.toLowerCase();

                  if (unloadedTags.includes(tagName)) {
                    unloadedTags = unloadedTags.filter(function (e) {
                      return e !== tagName;
                    });

                    _this3.componentLoader.loadComponent(tagName)["catch"](console.error);
                  }
                }
              });
            });
          });
          this.observer.observe(target, {
            subtree: true,
            childList: true
          });
        }
      }]);

      return WebComponentLoaderComponent;
    }();

    WebComponentLoaderComponent.ɵfac = function WebComponentLoaderComponent_Factory(t) {
      return new (t || WebComponentLoaderComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_2__["ComponentLoaderService"]));
    };

    WebComponentLoaderComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
      type: WebComponentLoaderComponent,
      selectors: [["wc-loader"]],
      decls: 0,
      vars: 0,
      template: function WebComponentLoaderComponent_Template(rf, ctx) {},
      encapsulation: 2
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](WebComponentLoaderComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
        args: [{
          selector: 'wc-loader',
          template: ''
        }]
      }], function () {
        return [{
          type: _juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_2__["ComponentLoaderService"]
        }];
      }, null);
    })();
    /***/

  },

  /***/
  "../../libs/webcomponents/src/lib/web-components-registry.ts":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/libs/webcomponents/src/lib/web-components-registry.ts ***!
    \****************************************************************************************************/

  /*! exports provided: WEB_COMPONENTS_REGISTRY */

  /***/
  function libsWebcomponentsSrcLibWebComponentsRegistryTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WEB_COMPONENTS_REGISTRY", function () {
      return WEB_COMPONENTS_REGISTRY;
    });

    var WEB_COMPONENTS_REGISTRY = [{
      selector: 'wc-text-input',
      loadChildren: function loadChildren() {
        return Promise.all(
        /*! import() */
        [__webpack_require__.e(0), __webpack_require__.e(1)]).then(__webpack_require__.bind(null,
        /*! ./text-input/text-input.module */
        "../../libs/webcomponents/src/lib/text-input/text-input.module.ts")).then(function (m) {
          return m.TextInputModule;
        });
      }
    }];
    /***/
  },

  /***/
  "../../libs/webcomponents/src/lib/web-components.module.ts":
  /*!**************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/libs/webcomponents/src/lib/web-components.module.ts ***!
    \**************************************************************************************************/

  /*! exports provided: WebComponentsModule */

  /***/
  function libsWebcomponentsSrcLibWebComponentsModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WebComponentsModule", function () {
      return WebComponentsModule;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "@angular/common");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var _angular_elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/elements */
    "@angular/elements");
    /* harmony import */


    var _angular_elements__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_elements__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var _web_components_loader_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./web-components-loader.component */
    "../../libs/webcomponents/src/lib/web-components-loader.component.ts");

    var WebComponentsModule = function WebComponentsModule(injector) {
      _classCallCheck(this, WebComponentsModule);

      this.injector = injector;
      customElements.define('wc-loader', Object(_angular_elements__WEBPACK_IMPORTED_MODULE_2__["createCustomElement"])(_web_components_loader_component__WEBPACK_IMPORTED_MODULE_3__["WebComponentLoaderComponent"], {
        injector: this.injector
      }));
    };

    WebComponentsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
      type: WebComponentsModule
    });
    WebComponentsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
      factory: function WebComponentsModule_Factory(t) {
        return new (t || WebComponentsModule)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]));
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](WebComponentsModule, {
        declarations: [_web_components_loader_component__WEBPACK_IMPORTED_MODULE_3__["WebComponentLoaderComponent"]],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]],
        exports: [_web_components_loader_component__WEBPACK_IMPORTED_MODULE_3__["WebComponentLoaderComponent"]]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](WebComponentsModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
        args: [{
          declarations: [_web_components_loader_component__WEBPACK_IMPORTED_MODULE_3__["WebComponentLoaderComponent"]],
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]],
          exports: [_web_components_loader_component__WEBPACK_IMPORTED_MODULE_3__["WebComponentLoaderComponent"]]
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
        }];
      }, null);
    })();
    /***/

  },

  /***/
  "../../node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js":
  /*!*******************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js ***!
    \*******************************************************************************************************************/

  /*! exports provided: AUTO_STYLE, AnimationBuilder, AnimationFactory, NoopAnimationPlayer, animate, animateChild, animation, group, keyframes, query, sequence, stagger, state, style, transition, trigger, useAnimation, ɵAnimationGroupPlayer, ɵPRE_STYLE */

  /***/
  function node_modulesAngularAnimations__ivy_ngcc__Fesm2015AnimationsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AUTO_STYLE", function () {
      return AUTO_STYLE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnimationBuilder", function () {
      return AnimationBuilder;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnimationFactory", function () {
      return AnimationFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NoopAnimationPlayer", function () {
      return NoopAnimationPlayer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "animate", function () {
      return animate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "animateChild", function () {
      return animateChild;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "animation", function () {
      return animation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "group", function () {
      return group;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "keyframes", function () {
      return keyframes;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "query", function () {
      return query;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sequence", function () {
      return sequence;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "stagger", function () {
      return stagger;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "state", function () {
      return state;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "style", function () {
      return style;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "transition", function () {
      return transition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "trigger", function () {
      return trigger;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "useAnimation", function () {
      return useAnimation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAnimationGroupPlayer", function () {
      return AnimationGroupPlayer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵPRE_STYLE", function () {
      return ɵPRE_STYLE;
    });
    /**
     * @license Angular v9.1.11
     * (c) 2010-2020 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/animation_builder.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * An injectable service that produces an animation sequence programmatically within an
     * Angular component or directive.
     * Provided by the `BrowserAnimationsModule` or `NoopAnimationsModule`.
     *
     * \@usageNotes
     *
     * To use this service, add it to your component or directive as a dependency.
     * The service is instantiated along with your component.
     *
     * Apps do not typically need to create their own animation players, but if you
     * do need to, follow these steps:
     *
     * 1. Use the `build()` method to create a programmatic animation using the
     * `animate()` function. The method returns an `AnimationFactory` instance.
     *
     * 2. Use the factory object to create an `AnimationPlayer` and attach it to a DOM element.
     *
     * 3. Use the player object to control the animation programmatically.
     *
     * For example:
     *
     * ```ts
     * // import the service from BrowserAnimationsModule
     * import {AnimationBuilder} from '\@angular/animations';
     * // require the service as a dependency
     * class MyCmp {
     *   constructor(private _builder: AnimationBuilder) {}
     *
     *   makeAnimation(element: any) {
     *     // first define a reusable animation
     *     const myAnimation = this._builder.build([
     *       style({ width: 0 }),
     *       animate(1000, style({ width: '100px' }))
     *     ]);
     *
     *     // use the returned factory object to create a player
     *     const player = myAnimation.create(element);
     *
     *     player.play();
     *   }
     * }
     * ```
     *
     * \@publicApi
     * @abstract
     */


    var AnimationBuilder = function AnimationBuilder() {
      _classCallCheck(this, AnimationBuilder);
    };

    if (false) {}
    /**
     * A factory object returned from the `AnimationBuilder`.`build()` method.
     *
     * \@publicApi
     * @abstract
     */


    var AnimationFactory = function AnimationFactory() {
      _classCallCheck(this, AnimationFactory);
    };

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/animation_metadata.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Represents a set of CSS styles for use in an animation style.
     * @record
     */


    function ɵStyleData() {}
    /** @enum {number} */


    var AnimationMetadataType = {
      /**
       * Associates a named animation state with a set of CSS styles.
       * See `state()`
       */
      State: 0,

      /**
       * Data for a transition from one animation state to another.
       * See `transition()`
       */
      Transition: 1,

      /**
       * Contains a set of animation steps.
       * See `sequence()`
       */
      Sequence: 2,

      /**
       * Contains a set of animation steps.
       * See `{@link animations/group group()}`
       */
      Group: 3,

      /**
       * Contains an animation step.
       * See `animate()`
       */
      Animate: 4,

      /**
       * Contains a set of animation steps.
       * See `keyframes()`
       */
      Keyframes: 5,

      /**
       * Contains a set of CSS property-value pairs into a named style.
       * See `style()`
       */
      Style: 6,

      /**
       * Associates an animation with an entry trigger that can be attached to an element.
       * See `trigger()`
       */
      Trigger: 7,

      /**
       * Contains a re-usable animation.
       * See `animation()`
       */
      Reference: 8,

      /**
       * Contains data to use in executing child animations returned by a query.
       * See `animateChild()`
       */
      AnimateChild: 9,

      /**
       * Contains animation parameters for a re-usable animation.
       * See `useAnimation()`
       */
      AnimateRef: 10,

      /**
       * Contains child-animation query data.
       * See `query()`
       */
      Query: 11,

      /**
       * Contains data for staggering an animation sequence.
       * See `stagger()`
       */
      Stagger: 12
    };
    /**
     * Specifies automatic styling.
     *
     * \@publicApi
     * @type {?}
     */

    var AUTO_STYLE = '*';
    /**
     * Base for animation data structures.
     *
     * \@publicApi
     * @record
     */

    function AnimationMetadata() {}

    if (false) {}
    /**
     * Contains an animation trigger. Instantiated and returned by the
     * `trigger()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationTriggerMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation state by associating a state name with a set of CSS styles.
     * Instantiated and returned by the `state()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationStateMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation transition. Instantiated and returned by the
     * `transition()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationTransitionMetadata() {}

    if (false) {}
    /**
     * Encapsulates a reusable animation, which is a collection of individual animation steps.
     * Instantiated and returned by the `animation()` function, and
     * passed to the `useAnimation()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationReferenceMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation query. Instantiated and returned by
     * the `query()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationQueryMetadata() {}

    if (false) {}
    /**
     * Encapsulates a keyframes sequence. Instantiated and returned by
     * the `keyframes()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationKeyframesSequenceMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation style. Instantiated and returned by
     * the `style()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationStyleMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation step. Instantiated and returned by
     * the `animate()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationAnimateMetadata() {}

    if (false) {}
    /**
     * Encapsulates a child animation, that can be run explicitly when the parent is run.
     * Instantiated and returned by the `animateChild` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationAnimateChildMetadata() {}

    if (false) {}
    /**
     * Encapsulates a reusable animation.
     * Instantiated and returned by the `useAnimation()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationAnimateRefMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation sequence.
     * Instantiated and returned by the `sequence()` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationSequenceMetadata() {}

    if (false) {}
    /**
     * Encapsulates an animation group.
     * Instantiated and returned by the `{\@link animations/group group()}` function.
     *
     * \@publicApi
     * @record
     */


    function AnimationGroupMetadata() {}

    if (false) {}
    /**
     * Encapsulates parameters for staggering the start times of a set of animation steps.
     * Instantiated and returned by the `stagger()` function.
     *
     * \@publicApi
     *
     * @record
     */


    function AnimationStaggerMetadata() {}

    if (false) {}
    /**
     * Creates a named animation trigger, containing a  list of `state()`
     * and `transition()` entries to be evaluated when the expression
     * bound to the trigger changes.
     *
     * \@usageNotes
     * Define an animation trigger in the `animations` section of `\@Component` metadata.
     * In the template, reference the trigger by name and bind it to a trigger expression that
     * evaluates to a defined animation state, using the following format:
     *
     * `[\@triggerName]="expression"`
     *
     * Animation trigger bindings convert all values to strings, and then match the
     * previous and current values against any linked transitions.
     * Booleans can be specified as `1` or `true` and `0` or `false`.
     *
     * ### Usage Example
     *
     * The following example creates an animation trigger reference based on the provided
     * name value.
     * The provided animation value is expected to be an array consisting of state and
     * transition declarations.
     *
     * ```typescript
     * \@Component({
     *   selector: "my-component",
     *   templateUrl: "my-component-tpl.html",
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *       state(...),
     *       state(...),
     *       transition(...),
     *       transition(...)
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   myStatusExp = "something";
     * }
     * ```
     *
     * The template associated with this component makes use of the defined trigger
     * by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * ### Using an inline function
     * The `transition` animation method also supports reading an inline function which can decide
     * if its associated animation should be run.
     *
     * ```typescript
     * // this method is run each time the `myAnimationTrigger` trigger value changes.
     * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:
     * string]: any}): boolean {
     *   // notice that `element` and `params` are also available here
     *   return toState == 'yes-please-animate';
     * }
     *  /
     *   selector: 'my-component',
     *   templateUrl: 'my-component-tpl.html',
     *   animations: [
     *     trigger('myAnimationTrigger', [
     *       transition(myInlineMatcherFn, [
     *         // the animation sequence code
     *       ]),
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   myStatusExp = "yes-please-animate";
     * }
     * ```
     *
     * ### Disabling Animations
     * When true, the special animation control binding `\@.disabled` binding prevents
     * all animations from rendering.
     * Place the  `\@.disabled` binding on an element to disable
     * animations on the element itself, as well as any inner animation triggers
     * within the element.
     *
     * The following example shows how to use this feature:
     *
     * ```typescript /
     *   selector: 'my-component',
     *   template: `
     *     <div [\@.disabled]="isDisabled">
     *       <div [\@childAnimation]="exp"></div>
     *     </div>
     *   `,
     *   animations: [
     *     trigger("childAnimation", [
     *       // ...
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   isDisabled = true;
     *   exp = '...';
     * }
     * ```
     *
     * When `\@.disabled` is true, it prevents the `\@childAnimation` trigger from animating,
     * along with any inner animations.
     *
     * ### Disable animations application-wide
     * When an area of the template is set to have animations disabled,
     * **all** inner components have their animations disabled as well.
     * This means that you can disable all animations for an app
     * by placing a host binding set on `\@.disabled` on the topmost Angular component.
     *
     * ```typescript
     * import {Component, HostBinding} from '\@angular/core';
     *  /
     *   selector: 'app-component',
     *   templateUrl: 'app.component.html',
     * })
     * class AppComponent {
     * \@HostBinding('@.disabled')
     *   public animationsDisabled = true;
     * }
     * ```
     *
     * ### Overriding disablement of inner animations
     * Despite inner animations being disabled, a parent animation can `query()`
     * for inner elements located in disabled areas of the template and still animate
     * them if needed. This is also the case for when a sub animation is
     * queried by a parent and then later animated using `animateChild()`.
     *
     * ### Detecting when an animation is disabled
     * If a region of the DOM (or the entire application) has its animations disabled, the animation
     * trigger callbacks still fire, but for zero seconds. When the callback fires, it provides
     * an instance of an `AnimationEvent`. If animations are disabled,
     * the `.disabled` flag on the event is true.
     *
     * \@publicApi
     * @param {?} name An identifying string.
     * @param {?} definitions  An animation definition object, containing an array of `state()`
     * and `transition()` declarations.
     *
     * @return {?} An object that encapsulates the trigger data.
     *
     */


    function trigger(name, definitions) {
      return {
        type: 7
        /* Trigger */
        ,
        name: name,
        definitions: definitions,
        options: {}
      };
    }
    /**
     * Defines an animation step that combines styling information with timing information.
     *
     * \@usageNotes
     * Call within an animation `sequence()`, `{\@link animations/group group()}`, or
     * `transition()` call to specify an animation step
     * that applies given style data to the parent animation for a given amount of time.
     *
     * ### Syntax Examples
     * **Timing examples**
     *
     * The following examples show various `timings` specifications.
     * - `animate(500)` : Duration is 500 milliseconds.
     * - `animate("1s")` : Duration is 1000 milliseconds.
     * - `animate("100ms 0.5s")` : Duration is 100 milliseconds, delay is 500 milliseconds.
     * - `animate("5s ease-in")` : Duration is 5000 milliseconds, easing in.
     * - `animate("5s 10ms cubic-bezier(.17,.67,.88,.1)")` : Duration is 5000 milliseconds, delay is 10
     * milliseconds, easing according to a bezier curve.
     *
     * **Style examples**
     *
     * The following example calls `style()` to set a single CSS style.
     * ```typescript
     * animate(500, style({ background: "red" }))
     * ```
     * The following example calls `keyframes()` to set a CSS style
     * to different values for successive keyframes.
     * ```typescript
     * animate(500, keyframes(
     *  [
     *   style({ background: "blue" })),
     *   style({ background: "red" }))
     *  ])
     * ```
     *
     * \@publicApi
     * @param {?} timings Sets `AnimateTimings` for the parent animation.
     * A string in the format "duration [delay] [easing]".
     *  - Duration and delay are expressed as a number and optional time unit,
     * such as "1s" or "10ms" for one second and 10 milliseconds, respectively.
     * The default unit is milliseconds.
     *  - The easing value controls how the animation accelerates and decelerates
     * during its runtime. Value is one of  `ease`, `ease-in`, `ease-out`,
     * `ease-in-out`, or a `cubic-bezier()` function call.
     * If not supplied, no easing is applied.
     *
     * For example, the string "1s 100ms ease-out" specifies a duration of
     * 1000 milliseconds, and delay of 100 ms, and the "ease-out" easing style,
     * which decelerates near the end of the duration.
     * @param {?=} styles Sets AnimationStyles for the parent animation.
     * A function call to either `style()` or `keyframes()`
     * that returns a collection of CSS style entries to be applied to the parent animation.
     * When null, uses the styles from the destination state.
     * This is useful when describing an animation step that will complete an animation;
     * see "Animating to the final state" in `transitions()`.
     * @return {?} An object that encapsulates the animation step.
     *
     */


    function animate(timings) {
      var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        type: 4
        /* Animate */
        ,
        styles: styles,
        timings: timings
      };
    }
    /**
     * \@description Defines a list of animation steps to be run in parallel.
     *
     * \@usageNotes
     * Grouped animations are useful when a series of styles must be
     * animated at different starting times and closed off at different ending times.
     *
     * When called within a `sequence()` or a
     * `transition()` call, does not continue to the next
     * instruction until all of the inner animation steps have completed.
     *
     * \@publicApi
     * @param {?} steps An array of animation step objects.
     * - When steps are defined by `style()` or `animate()`
     * function calls, each call within the group is executed instantly.
     * - To specify offset styles to be applied at a later time, define steps with
     * `keyframes()`, or use `animate()` calls with a delay value.
     * For example:
     *
     * ```typescript
     * group([
     *   animate("1s", style({ background: "black" })),
     *   animate("2s", style({ color: "white" }))
     * ])
     * ```
     *
     * @param {?=} options An options object containing a delay and
     * developer-defined parameters that provide styling defaults and
     * can be overridden on invocation.
     *
     * @return {?} An object that encapsulates the group data.
     *
     */


    function group(steps) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        type: 3
        /* Group */
        ,
        steps: steps,
        options: options
      };
    }
    /**
     * Defines a list of animation steps to be run sequentially, one by one.
     *
     * \@usageNotes
     * When you pass an array of steps to a
     * `transition()` call, the steps run sequentially by default.
     * Compare this to the `{\@link animations/group group()}` call, which runs animation steps in
     * parallel.
     *
     * When a sequence is used within a `{\@link animations/group group()}` or a `transition()` call,
     * execution continues to the next instruction only after each of the inner animation
     * steps have completed.
     *
     * \@publicApi
     *
     * @param {?} steps An array of animation step objects.
     * - Steps defined by `style()` calls apply the styling data immediately.
     * - Steps defined by `animate()` calls apply the styling data over time
     *   as specified by the timing data.
     *
     * ```typescript
     * sequence([
     *   style({ opacity: 0 }),
     *   animate("1s", style({ opacity: 1 }))
     * ])
     * ```
     *
     * @param {?=} options An options object containing a delay and
     * developer-defined parameters that provide styling defaults and
     * can be overridden on invocation.
     *
     * @return {?} An object that encapsulates the sequence data.
     *
     */


    function sequence(steps) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        type: 2
        /* Sequence */
        ,
        steps: steps,
        options: options
      };
    }
    /**
     * Declares a key/value object containing CSS properties/styles that
     * can then be used for an animation `state`, within an animation `sequence`,
     * or as styling data for calls to `animate()` and `keyframes()`.
     *
     * \@usageNotes
     * The following examples create animation styles that collect a set of
     * CSS property values:
     *
     * ```typescript
     * // string values for CSS properties
     * style({ background: "red", color: "blue" })
     *
     * // numerical pixel values
     * style({ width: 100, height: 0 })
     * ```
     *
     * The following example uses auto-styling to allow a component to animate from
     * a height of 0 up to the height of the parent element:
     *
     * ```
     * style({ height: 0 }),
     * animate("1s", style({ height: "*" }))
     * ```
     *
     * \@publicApi
     *
     * @param {?} tokens A set of CSS styles or HTML styles associated with an animation state.
     * The value can be any of the following:
     * - A key-value style pair associating a CSS property with a value.
     * - An array of key-value style pairs.
     * - An asterisk (*), to use auto-styling, where styles are derived from the element
     * being animated and applied to the animation when it starts.
     *
     * Auto-styling can be used to define a state that depends on layout or other
     * environmental factors.
     *
     * @return {?} An object that encapsulates the style data.
     *
     */


    function style(tokens) {
      return {
        type: 6
        /* Style */
        ,
        styles: tokens,
        offset: null
      };
    }
    /**
     * Declares an animation state within a trigger attached to an element.
     *
     * \@usageNotes
     * Use the `trigger()` function to register states to an animation trigger.
     * Use the `transition()` function to animate between states.
     * When a state is active within a component, its associated styles persist on the element,
     * even when the animation ends.
     *
     * \@publicApi
     *
     * @param {?} name One or more names for the defined state in a comma-separated string.
     * The following reserved state names can be supplied to define a style for specific use
     * cases:
     *
     * - `void` You can associate styles with this name to be used when
     * the element is detached from the application. For example, when an `ngIf` evaluates
     * to false, the state of the associated element is void.
     *  - `*` (asterisk) Indicates the default state. You can associate styles with this name
     * to be used as the fallback when the state that is being animated is not declared
     * within the trigger.
     *
     * @param {?} styles A set of CSS styles associated with this state, created using the
     * `style()` function.
     * This set of styles persists on the element once the state has been reached.
     * @param {?=} options Parameters that can be passed to the state when it is invoked.
     * 0 or more key-value pairs.
     * @return {?} An object that encapsulates the new state data.
     *
     */


    function state(name, styles, options) {
      return {
        type: 0
        /* State */
        ,
        name: name,
        styles: styles,
        options: options
      };
    }
    /**
     * Defines a set of animation styles, associating each style with an optional `offset` value.
     *
     * \@usageNotes
     * Use with the `animate()` call. Instead of applying animations
     * from the current state
     * to the destination state, keyframes describe how each style entry is applied and at what point
     * within the animation arc.
     * Compare [CSS Keyframe Animations](https://www.w3schools.com/css/css3_animations.asp).
     *
     * ### Usage
     *
     * In the following example, the offset values describe
     * when each `backgroundColor` value is applied. The color is red at the start, and changes to
     * blue when 20% of the total time has elapsed.
     *
     * ```typescript
     * // the provided offset values
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red", offset: 0 }),
     *   style({ backgroundColor: "blue", offset: 0.2 }),
     *   style({ backgroundColor: "orange", offset: 0.3 }),
     *   style({ backgroundColor: "black", offset: 1 })
     * ]))
     * ```
     *
     * If there are no `offset` values specified in the style entries, the offsets
     * are calculated automatically.
     *
     * ```typescript
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red" }) // offset = 0
     *   style({ backgroundColor: "blue" }) // offset = 0.33
     *   style({ backgroundColor: "orange" }) // offset = 0.66
     *   style({ backgroundColor: "black" }) // offset = 1
     * ]))
     * ```
     * \@publicApi
     * @param {?} steps A set of animation styles with optional offset data.
     * The optional `offset` value for a style specifies a percentage of the total animation
     * time at which that style is applied.
     * @return {?} An object that encapsulates the keyframes data.
     *
     */


    function keyframes(steps) {
      return {
        type: 5
        /* Keyframes */
        ,
        steps: steps
      };
    }
    /**
     * Declares an animation transition as a sequence of animation steps to run when a given
     * condition is satisfied. The condition is a Boolean expression or function that compares
     * the previous and current animation states, and returns true if this transition should occur.
     * When the state criteria of a defined transition are met, the associated animation is
     * triggered.
     *
     * \@usageNotes
     * The template associated with a component binds an animation trigger to an element.
     *
     * ```HTML
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * All transitions are defined within an animation trigger,
     * along with named states that the transitions change to and from.
     *
     * ```typescript
     * trigger("myAnimationTrigger", [
     *  // define states
     *  state("on", style({ background: "green" })),
     *  state("off", style({ background: "grey" })),
     *  ...]
     * ```
     *
     * Note that when you call the `sequence()` function within a `{\@link animations/group group()}`
     * or a `transition()` call, execution does not continue to the next instruction
     * until each of the inner animation steps have completed.
     *
     * ### Syntax examples
     *
     * The following examples define transitions between the two defined states (and default states),
     * using various options:
     *
     * ```typescript
     * // Transition occurs when the state value
     * // bound to "myAnimationTrigger" changes from "on" to "off"
     * transition("on => off", animate(500))
     * // Run the same animation for both directions
     * transition("on <=> off", animate(500))
     * // Define multiple state-change pairs separated by commas
     * transition("on => off, off => void", animate(500))
     * ```
     *
     * ### Special values for state-change expressions
     *
     * - Catch-all state change for when an element is inserted into the page and the
     * destination state is unknown:
     *
     * ```typescript
     * transition("void => *", [
     *  style({ opacity: 0 }),
     *  animate(500)
     *  ])
     * ```
     *
     * - Capture a state change between any states:
     *
     *  `transition("* => *", animate("1s 0s"))`
     *
     * - Entry and exit transitions:
     *
     * ```typescript
     * transition(":enter", [
     *   style({ opacity: 0 }),
     *   animate(500, style({ opacity: 1 }))
     *   ]),
     * transition(":leave", [
     *   animate(500, style({ opacity: 0 }))
     *   ])
     * ```
     *
     * - Use `:increment` and `:decrement` to initiate transitions:
     *
     * ```typescript
     * transition(":increment", group([
     *  query(':enter', [
     *     style({ left: '100%' }),
     *     animate('0.5s ease-out', style('*'))
     *   ]),
     *  query(':leave', [
     *     animate('0.5s ease-out', style({ left: '-100%' }))
     *  ])
     * ]))
     *
     * transition(":decrement", group([
     *  query(':enter', [
     *     style({ left: '100%' }),
     *     animate('0.5s ease-out', style('*'))
     *   ]),
     *  query(':leave', [
     *     animate('0.5s ease-out', style({ left: '-100%' }))
     *  ])
     * ]))
     * ```
     *
     * ### State-change functions
     *
     * Here is an example of a `fromState` specified as a state-change function that invokes an
     * animation when true:
     *
     * ```typescript
     * transition((fromState, toState) =>
     *  {
     *   return fromState == "off" && toState == "on";
     *  },
     *  animate("1s 0s"))
     * ```
     *
     * ### Animating to the final state
     *
     * If the final step in a transition is a call to `animate()` that uses a timing value
     * with no style data, that step is automatically considered the final animation arc,
     * for the element to reach the final state. Angular automatically adds or removes
     * CSS styles to ensure that the element is in the correct final state.
     *
     * The following example defines a transition that starts by hiding the element,
     * then makes sure that it animates properly to whatever state is currently active for trigger:
     *
     * ```typescript
     * transition("void => *", [
     *   style({ opacity: 0 }),
     *   animate(500)
     *  ])
     * ```
     * ### Boolean value matching
     * If a trigger binding value is a Boolean, it can be matched using a transition expression
     * that compares true and false or 1 and 0. For example:
     *
     * ```
     * // in the template
     * <div [\@openClose]="open ? true : false">...</div>
     * // in the component metadata
     * trigger('openClose', [
     *   state('true', style({ height: '*' })),
     *   state('false', style({ height: '0px' })),
     *   transition('false <=> true', animate(500))
     * ])
     * ```
     *
     * \@publicApi
     *
     * @param {?} stateChangeExpr A Boolean expression or function that compares the previous and current
     * animation states, and returns true if this transition should occur. Note that  "true" and "false"
     * match 1 and 0, respectively. An expression is evaluated each time a state change occurs in the
     * animation trigger element.
     * The animation steps run when the expression evaluates to true.
     *
     * - A state-change string takes the form "state1 => state2", where each side is a defined animation
     * state, or an asterix (*) to refer to a dynamic start or end state.
     *   - The expression string can contain multiple comma-separated statements;
     * for example "state1 => state2, state3 => state4".
     *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,
     * equivalent to  "void => *"  and "* => void".
     *   - Special values `:increment` and `:decrement` initiate a transition when a numeric value has
     * increased or decreased in value.
     * - A function is executed each time a state change occurs in the animation trigger element.
     * The animation steps run when the function returns true.
     *
     * @param {?} steps One or more animation objects, as returned by the `animate()` or
     * `sequence()` function, that form a transformation from one state to another.
     * A sequence is used by default when you pass an array.
     * @param {?=} options An options object that can contain a delay value for the start of the animation,
     * and additional developer-defined parameters. Provided values for additional parameters are used
     * as defaults, and override values can be passed to the caller on invocation.
     * @return {?} An object that encapsulates the transition data.
     *
     */


    function transition(stateChangeExpr, steps) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return {
        type: 1
        /* Transition */
        ,
        expr: stateChangeExpr,
        animation: steps,
        options: options
      };
    }
    /**
     * Produces a reusable animation that can be invoked in another animation or sequence,
     * by calling the `useAnimation()` function.
     *
     * \@usageNotes
     * The following example defines a reusable animation, providing some default parameter
     * values.
     *
     * ```typescript
     * var fadeAnimation = animation([
     *   style({ opacity: '{{ start }}' }),
     *   animate('{{ time }}',
     *   style({ opacity: '{{ end }}'}))
     *   ],
     *   { params: { time: '1000ms', start: 0, end: 1 }});
     * ```
     *
     * The following invokes the defined animation with a call to `useAnimation()`,
     * passing in override parameter values.
     *
     * ```js
     * useAnimation(fadeAnimation, {
     *   params: {
     *     time: '2s',
     *     start: 1,
     *     end: 0
     *   }
     * })
     * ```
     *
     * If any of the passed-in parameter values are missing from this call,
     * the default values are used. If one or more parameter values are missing before a step is
     * animated, `useAnimation()` throws an error.
     *
     * \@publicApi
     * @param {?} steps One or more animation objects, as returned by the `animate()`
     * or `sequence()` function, that form a transformation from one state to another.
     * A sequence is used by default when you pass an array.
     * @param {?=} options An options object that can contain a delay value for the start of the
     * animation, and additional developer-defined parameters.
     * Provided values for additional parameters are used as defaults,
     * and override values can be passed to the caller on invocation.
     * @return {?} An object that encapsulates the animation data.
     *
     */


    function animation(steps) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        type: 8
        /* Reference */
        ,
        animation: steps,
        options: options
      };
    }
    /**
     * Executes a queried inner animation element within an animation sequence.
     *
     * \@usageNotes
     * Each time an animation is triggered in Angular, the parent animation
     * has priority and any child animations are blocked. In order
     * for a child animation to run, the parent animation must query each of the elements
     * containing child animations, and run them using this function.
     *
     * Note that this feature is designed to be used with `query()` and it will only work
     * with animations that are assigned using the Angular animation library. CSS keyframes
     * and transitions are not handled by this API.
     *
     * \@publicApi
     * @param {?=} options An options object that can contain a delay value for the start of the
     * animation, and additional override values for developer-defined parameters.
     * @return {?} An object that encapsulates the child animation data.
     *
     */


    function animateChild() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return {
        type: 9
        /* AnimateChild */
        ,
        options: options
      };
    }
    /**
     * Starts a reusable animation that is created using the `animation()` function.
     *
     * \@publicApi
     * @param {?} animation The reusable animation to start.
     * @param {?=} options An options object that can contain a delay value for the start of
     * the animation, and additional override values for developer-defined parameters.
     * @return {?} An object that contains the animation parameters.
     *
     */


    function useAnimation(animation) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return {
        type: 10
        /* AnimateRef */
        ,
        animation: animation,
        options: options
      };
    }
    /**
     * Finds one or more inner elements within the current element that is
     * being animated within a sequence. Use with `animate()`.
     *
     * \@usageNotes
     * Tokens can be merged into a combined query selector string. For example:
     *
     * ```typescript
     *  query(':self, .record:enter, .record:leave, \@subTrigger', [...])
     * ```
     *
     * The `query()` function collects multiple elements and works internally by using
     * `element.querySelectorAll`. Use the `limit` field of an options object to limit
     * the total number of items to be collected. For example:
     *
     * ```js
     * query('div', [
     *   animate(...),
     *   animate(...)
     * ], { limit: 1 })
     * ```
     *
     * By default, throws an error when zero items are found. Set the
     * `optional` flag to ignore this error. For example:
     *
     * ```js
     * query('.some-element-that-may-not-be-there', [
     *   animate(...),
     *   animate(...)
     * ], { optional: true })
     * ```
     *
     * ### Usage Example
     *
     * The following example queries for inner elements and animates them
     * individually using `animate()`.
     *
     * ```typescript
     * \@Component({
     *   selector: 'inner',
     *   template: `
     *     <div [\@queryAnimation]="exp">
     *       <h1>Title</h1>
     *       <div class="content">
     *         Blah blah blah
     *       </div>
     *     </div>
     *   `,
     *   animations: [
     *    trigger('queryAnimation', [
     *      transition('* => goAnimate', [
     *        // hide the inner elements
     *        query('h1', style({ opacity: 0 })),
     *        query('.content', style({ opacity: 0 })),
     *
     *        // animate the inner elements in, one by one
     *        query('h1', animate(1000, style({ opacity: 1 }))),
     *        query('.content', animate(1000, style({ opacity: 1 }))),
     *      ])
     *    ])
     *  ]
     * })
     * class Cmp {
     *   exp = '';
     *
     *   goAnimate() {
     *     this.exp = 'goAnimate';
     *   }
     * }
     * ```
     *
     * \@publicApi
     * @param {?} selector The element to query, or a set of elements that contain Angular-specific
     * characteristics, specified with one or more of the following tokens.
     *  - `query(":enter")` or `query(":leave")` : Query for newly inserted/removed elements.
     *  - `query(":animating")` : Query all currently animating elements.
     *  - `query("\@triggerName")` : Query elements that contain an animation trigger.
     *  - `query("\@*")` : Query all elements that contain an animation triggers.
     *  - `query(":self")` : Include the current element into the animation sequence.
     *
     * @param {?} animation One or more animation steps to apply to the queried element or elements.
     * An array is treated as an animation sequence.
     * @param {?=} options An options object. Use the 'limit' field to limit the total number of
     * items to collect.
     * @return {?} An object that encapsulates the query data.
     *
     */


    function query(selector, animation) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return {
        type: 11
        /* Query */
        ,
        selector: selector,
        animation: animation,
        options: options
      };
    }
    /**
     * Use within an animation `query()` call to issue a timing gap after
     * each queried item is animated.
     *
     * \@usageNotes
     * In the following example, a container element wraps a list of items stamped out
     * by an `ngFor`. The container element contains an animation trigger that will later be set
     * to query for each of the inner items.
     *
     * Each time items are added, the opacity fade-in animation runs,
     * and each removed item is faded out.
     * When either of these animations occur, the stagger effect is
     * applied after each item's animation is started.
     *
     * ```html
     * <!-- list.component.html -->
     * <button (click)="toggle()">Show / Hide Items</button>
     * <hr />
     * <div [\@listAnimation]="items.length">
     *   <div *ngFor="let item of items">
     *     {{ item }}
     *   </div>
     * </div>
     * ```
     *
     * Here is the component code:
     *
     * ```typescript
     * import {trigger, transition, style, animate, query, stagger} from '\@angular/animations';
     * \@Component({
     *   templateUrl: 'list.component.html',
     *   animations: [
     *     trigger('listAnimation', [
     *     ...
     *     ])
     *   ]
     * })
     * class ListComponent {
     *   items = [];
     *
     *   showItems() {
     *     this.items = [0,1,2,3,4];
     *   }
     *
     *   hideItems() {
     *     this.items = [];
     *   }
     *
     *   toggle() {
     *     this.items.length ? this.hideItems() : this.showItems();
     *    }
     *  }
     * ```
     *
     * Here is the animation trigger code:
     *
     * ```typescript
     * trigger('listAnimation', [
     *   transition('* => *', [ // each time the binding value changes
     *     query(':leave', [
     *       stagger(100, [
     *         animate('0.5s', style({ opacity: 0 }))
     *       ])
     *     ]),
     *     query(':enter', [
     *       style({ opacity: 0 }),
     *       stagger(100, [
     *         animate('0.5s', style({ opacity: 1 }))
     *       ])
     *     ])
     *   ])
     * ])
     * ```
     *
     * \@publicApi
     * @param {?} timings A delay value.
     * @param {?} animation One ore more animation steps.
     * @return {?} An object that encapsulates the stagger data.
     *
     */


    function stagger(timings, animation) {
      return {
        type: 12
        /* Stagger */
        ,
        timings: timings,
        animation: animation
      };
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/util.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     * @param {?} cb
     * @return {?}
     */


    function scheduleMicroTask(cb) {
      Promise.resolve(null).then(cb);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/players/animation_player.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provides programmatic control of a reusable animation sequence,
     * built using the `build()` method of `AnimationBuilder`. The `build()` method
     * returns a factory, whose `create()` method instantiates and initializes this interface.
     *
     * @see `AnimationBuilder`
     * @see `AnimationFactory`
     * @see `animate()`
     *
     * \@publicApi
     * @record
     */


    function AnimationPlayer() {}

    if (false) {}
    /**
     * An empty programmatic controller for reusable animations.
     * Used internally when animations are disabled, to avoid
     * checking for the null case when an animation player is expected.
     *
     * @see `animate()`
     * @see `AnimationPlayer`
     * @see `GroupPlayer`
     *
     * \@publicApi
     */


    var NoopAnimationPlayer = /*#__PURE__*/function () {
      /**
       * @param {?=} duration
       * @param {?=} delay
       */
      function NoopAnimationPlayer() {
        var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, NoopAnimationPlayer);

        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._started = false;
        this._destroyed = false;
        this._finished = false;
        this.parentPlayer = null;
        this.totalTime = duration + delay;
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(NoopAnimationPlayer, [{
        key: "_onFinish",
        value: function _onFinish() {
          if (!this._finished) {
            this._finished = true;

            this._onDoneFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onDoneFns = [];
          }
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onStart",
        value: function onStart(fn) {
          this._onStartFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDone",
        value: function onDone(fn) {
          this._onDoneFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDestroy",
        value: function onDestroy(fn) {
          this._onDestroyFns.push(fn);
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasStarted",
        value: function hasStarted() {
          return this._started;
        }
        /**
         * @return {?}
         */

      }, {
        key: "init",
        value: function init() {}
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          if (!this.hasStarted()) {
            this._onStart();

            this.triggerMicrotask();
          }

          this._started = true;
        }
        /**
         * \@internal
         * @return {?}
         */

      }, {
        key: "triggerMicrotask",
        value: function triggerMicrotask() {
          var _this4 = this;

          scheduleMicroTask(
          /**
          * @return {?}
          */
          function () {
            return _this4._onFinish();
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_onStart",
        value: function _onStart() {
          this._onStartFns.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });

          this._onStartFns = [];
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {}
        /**
         * @return {?}
         */

      }, {
        key: "restart",
        value: function restart() {}
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this._onFinish();
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          if (!this._destroyed) {
            this._destroyed = true;

            if (!this.hasStarted()) {
              this._onStart();
            }

            this.finish();

            this._onDestroyFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onDestroyFns = [];
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset() {}
        /**
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(position) {}
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          return 0;
        }
        /**
         * \@internal
         * @param {?} phaseName
         * @return {?}
         */

      }, {
        key: "triggerCallback",
        value: function triggerCallback(phaseName) {
          /** @type {?} */
          var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
          methods.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });
          methods.length = 0;
        }
      }]);

      return NoopAnimationPlayer;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/players/animation_group_player.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A programmatic controller for a group of reusable animations.
     * Used internally to control animations.
     *
     * @see `AnimationPlayer`
     * @see `{\@link animations/group group()}`
     *
     */


    var AnimationGroupPlayer = /*#__PURE__*/function () {
      /**
       * @param {?} _players
       */
      function AnimationGroupPlayer(_players) {
        var _this5 = this;

        _classCallCheck(this, AnimationGroupPlayer);

        this._onDoneFns = [];
        this._onStartFns = [];
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this._onDestroyFns = [];
        this.parentPlayer = null;
        this.totalTime = 0;
        this.players = _players;
        /** @type {?} */

        var doneCount = 0;
        /** @type {?} */

        var destroyCount = 0;
        /** @type {?} */

        var startCount = 0;
        /** @type {?} */

        var total = this.players.length;

        if (total == 0) {
          scheduleMicroTask(
          /**
          * @return {?}
          */
          function () {
            return _this5._onFinish();
          });
        } else {
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            player.onDone(
            /**
            * @return {?}
            */
            function () {
              if (++doneCount == total) {
                _this5._onFinish();
              }
            });
            player.onDestroy(
            /**
            * @return {?}
            */
            function () {
              if (++destroyCount == total) {
                _this5._onDestroy();
              }
            });
            player.onStart(
            /**
            * @return {?}
            */
            function () {
              if (++startCount == total) {
                _this5._onStart();
              }
            });
          });
        }

        this.totalTime = this.players.reduce(
        /**
        * @param {?} time
        * @param {?} player
        * @return {?}
        */
        function (time, player) {
          return Math.max(time, player.totalTime);
        }, 0);
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(AnimationGroupPlayer, [{
        key: "_onFinish",
        value: function _onFinish() {
          if (!this._finished) {
            this._finished = true;

            this._onDoneFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onDoneFns = [];
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "init",
        value: function init() {
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player.init();
          });
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onStart",
        value: function onStart(fn) {
          this._onStartFns.push(fn);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_onStart",
        value: function _onStart() {
          if (!this.hasStarted()) {
            this._started = true;

            this._onStartFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onStartFns = [];
          }
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDone",
        value: function onDone(fn) {
          this._onDoneFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDestroy",
        value: function onDestroy(fn) {
          this._onDestroyFns.push(fn);
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasStarted",
        value: function hasStarted() {
          return this._started;
        }
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          if (!this.parentPlayer) {
            this.init();
          }

          this._onStart();

          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player.play();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player.pause();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "restart",
        value: function restart() {
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player.restart();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this._onFinish();

          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player.finish();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this._onDestroy();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_onDestroy",
        value: function _onDestroy() {
          if (!this._destroyed) {
            this._destroyed = true;

            this._onFinish();

            this.players.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              return player.destroy();
            });

            this._onDestroyFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onDestroyFns = [];
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset() {
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player.reset();
          });
          this._destroyed = false;
          this._finished = false;
          this._started = false;
        }
        /**
         * @param {?} p
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(p) {
          /** @type {?} */
          var timeAtPosition = p * this.totalTime;
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            /** @type {?} */
            var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
            player.setPosition(position);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          /** @type {?} */
          var min = 0;
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            /** @type {?} */
            var p = player.getPosition();
            min = Math.min(p, min);
          });
          return min;
        }
        /**
         * @return {?}
         */

      }, {
        key: "beforeDestroy",
        value: function beforeDestroy() {
          this.players.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            if (player.beforeDestroy) {
              player.beforeDestroy();
            }
          });
        }
        /**
         * \@internal
         * @param {?} phaseName
         * @return {?}
         */

      }, {
        key: "triggerCallback",
        value: function triggerCallback(phaseName) {
          /** @type {?} */
          var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
          methods.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });
          methods.length = 0;
        }
      }]);

      return AnimationGroupPlayer;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/private_export.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ɵPRE_STYLE = '!';
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/src/animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=animations.js.map

    /***/
  },

  /***/
  "../../node_modules/@angular/animations/__ivy_ngcc__/fesm2015/browser.js":
  /*!****************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/@angular/animations/__ivy_ngcc__/fesm2015/browser.js ***!
    \****************************************************************************************************************/

  /*! exports provided: AnimationDriver, ɵAnimation, ɵAnimationEngine, ɵAnimationStyleNormalizer, ɵCssKeyframesDriver, ɵCssKeyframesPlayer, ɵNoopAnimationDriver, ɵNoopAnimationStyleNormalizer, ɵWebAnimationsDriver, ɵWebAnimationsPlayer, ɵWebAnimationsStyleNormalizer, ɵallowPreviousPlayerStylesMerge, ɵangular_packages_animations_browser_browser_a, ɵcontainsElement, ɵinvokeQuery, ɵmatchesElement, ɵsupportsWebAnimations, ɵvalidateStyleProperty */

  /***/
  function node_modulesAngularAnimations__ivy_ngcc__Fesm2015BrowserJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnimationDriver", function () {
      return AnimationDriver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAnimation", function () {
      return Animation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAnimationEngine", function () {
      return AnimationEngine;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAnimationStyleNormalizer", function () {
      return AnimationStyleNormalizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCssKeyframesDriver", function () {
      return CssKeyframesDriver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCssKeyframesPlayer", function () {
      return CssKeyframesPlayer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNoopAnimationDriver", function () {
      return NoopAnimationDriver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNoopAnimationStyleNormalizer", function () {
      return NoopAnimationStyleNormalizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵWebAnimationsDriver", function () {
      return WebAnimationsDriver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵWebAnimationsPlayer", function () {
      return WebAnimationsPlayer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵWebAnimationsStyleNormalizer", function () {
      return WebAnimationsStyleNormalizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵallowPreviousPlayerStylesMerge", function () {
      return allowPreviousPlayerStylesMerge;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_animations_browser_browser_a", function () {
      return SpecialCasedStyles;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcontainsElement", function () {
      return _containsElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵinvokeQuery", function () {
      return invokeQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵmatchesElement", function () {
      return _matchesElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵsupportsWebAnimations", function () {
      return supportsWebAnimations;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵvalidateStyleProperty", function () {
      return _validateStyleProperty;
    });
    /* harmony import */


    var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/animations */
    "../../node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
    /**
     * @license Angular v9.1.11
     * (c) 2010-2020 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/shared.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @return {?}
     */


    function isBrowser() {
      return typeof window !== 'undefined' && typeof window.document !== 'undefined';
    }
    /**
     * @return {?}
     */


    function isNode() {
      // Checking only for `process` isn't enough to identify whether or not we're in a Node
      // environment, because Webpack by default will polyfill the `process`. While we can discern
      // that Webpack polyfilled it by looking at `process.browser`, it's very Webpack-specific and
      // might not be future-proof. Instead we look at the stringified version of `process` which
      // is `[object process]` in Node and `[object Object]` when polyfilled.
      return typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
    }
    /**
     * @param {?} players
     * @return {?}
     */


    function optimizeGroupPlayer(players) {
      switch (players.length) {
        case 0:
          return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__["NoopAnimationPlayer"]();

        case 1:
          return players[0];

        default:
          return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__["ɵAnimationGroupPlayer"](players);
      }
    }
    /**
     * @param {?} driver
     * @param {?} normalizer
     * @param {?} element
     * @param {?} keyframes
     * @param {?=} preStyles
     * @param {?=} postStyles
     * @return {?}
     */


    function normalizeKeyframes(driver, normalizer, element, keyframes) {
      var preStyles = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var postStyles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

      /** @type {?} */
      var errors = [];
      /** @type {?} */

      var normalizedKeyframes = [];
      /** @type {?} */

      var previousOffset = -1;
      /** @type {?} */

      var previousKeyframe = null;
      keyframes.forEach(
      /**
      * @param {?} kf
      * @return {?}
      */
      function (kf) {
        /** @type {?} */
        var offset =
        /** @type {?} */
        kf['offset'];
        /** @type {?} */

        var isSameOffset = offset == previousOffset;
        /** @type {?} */

        var normalizedKeyframe = isSameOffset && previousKeyframe || {};
        Object.keys(kf).forEach(
        /**
        * @param {?} prop
        * @return {?}
        */
        function (prop) {
          /** @type {?} */
          var normalizedProp = prop;
          /** @type {?} */

          var normalizedValue = kf[prop];

          if (prop !== 'offset') {
            normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);

            switch (normalizedValue) {
              case _angular_animations__WEBPACK_IMPORTED_MODULE_0__["ɵPRE_STYLE"]:
                normalizedValue = preStyles[prop];
                break;

              case _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"]:
                normalizedValue = postStyles[prop];
                break;

              default:
                normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                break;
            }
          }

          normalizedKeyframe[normalizedProp] = normalizedValue;
        });

        if (!isSameOffset) {
          normalizedKeyframes.push(normalizedKeyframe);
        }

        previousKeyframe = normalizedKeyframe;
        previousOffset = offset;
      });

      if (errors.length) {
        /** @type {?} */
        var LINE_START = '\n - ';
        throw new Error("Unable to animate due to the following errors:".concat(LINE_START).concat(errors.join(LINE_START)));
      }

      return normalizedKeyframes;
    }
    /**
     * @param {?} player
     * @param {?} eventName
     * @param {?} event
     * @param {?} callback
     * @return {?}
     */


    function listenOnPlayer(player, eventName, event, callback) {
      switch (eventName) {
        case 'start':
          player.onStart(
          /**
          * @return {?}
          */
          function () {
            return callback(event && copyAnimationEvent(event, 'start', player));
          });
          break;

        case 'done':
          player.onDone(
          /**
          * @return {?}
          */
          function () {
            return callback(event && copyAnimationEvent(event, 'done', player));
          });
          break;

        case 'destroy':
          player.onDestroy(
          /**
          * @return {?}
          */
          function () {
            return callback(event && copyAnimationEvent(event, 'destroy', player));
          });
          break;
      }
    }
    /**
     * @param {?} e
     * @param {?} phaseName
     * @param {?} player
     * @return {?}
     */


    function copyAnimationEvent(e, phaseName, player) {
      /** @type {?} */
      var totalTime = player.totalTime;
      /** @type {?} */

      var disabled =
      /** @type {?} */
      player.disabled ? true : false;
      /** @type {?} */

      var event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);
      /** @type {?} */

      var data =
      /** @type {?} */
      e['_data'];

      if (data != null) {
        /** @type {?} */
        event['_data'] = data;
      }

      return event;
    }
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} fromState
     * @param {?} toState
     * @param {?=} phaseName
     * @param {?=} totalTime
     * @param {?=} disabled
     * @return {?}
     */


    function makeAnimationEvent(element, triggerName, fromState, toState) {
      var phaseName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
      var totalTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var disabled = arguments.length > 6 ? arguments[6] : undefined;
      return {
        element: element,
        triggerName: triggerName,
        fromState: fromState,
        toState: toState,
        phaseName: phaseName,
        totalTime: totalTime,
        disabled: !!disabled
      };
    }
    /**
     * @param {?} map
     * @param {?} key
     * @param {?} defaultValue
     * @return {?}
     */


    function getOrSetAsInMap(map, key, defaultValue) {
      /** @type {?} */
      var value;

      if (map instanceof Map) {
        value = map.get(key);

        if (!value) {
          map.set(key, value = defaultValue);
        }
      } else {
        value = map[key];

        if (!value) {
          value = map[key] = defaultValue;
        }
      }

      return value;
    }
    /**
     * @param {?} command
     * @return {?}
     */


    function parseTimelineCommand(command) {
      /** @type {?} */
      var separatorPos = command.indexOf(':');
      /** @type {?} */

      var id = command.substring(1, separatorPos);
      /** @type {?} */

      var action = command.substr(separatorPos + 1);
      return [id, action];
    }
    /** @type {?} */


    var _contains =
    /**
    * @param {?} elm1
    * @param {?} elm2
    * @return {?}
    */
    function _contains(elm1, elm2) {
      return false;
    };

    var ɵ0 = _contains;
    /** @type {?} */

    var _matches =
    /**
    * @param {?} element
    * @param {?} selector
    * @return {?}
    */
    function _matches(element, selector) {
      return false;
    };

    var ɵ1 = _matches;
    /** @type {?} */

    var _query =
    /**
    * @param {?} element
    * @param {?} selector
    * @param {?} multi
    * @return {?}
    */
    function _query(element, selector, multi) {
      return [];
    };

    var ɵ2 = _query; // Define utility methods for browsers and platform-server(domino) where Element
    // and utility methods exist.

    /** @type {?} */

    var _isNode = isNode();

    if (_isNode || typeof Element !== 'undefined') {
      // this is well supported in all browsers
      _contains =
      /**
      * @param {?} elm1
      * @param {?} elm2
      * @return {?}
      */
      function _contains(elm1, elm2) {
        return (
          /** @type {?} */
          elm1.contains(elm2)
        );
      };

      _matches =
      /**
      * @return {?}
      */
      function () {
        if (_isNode || Element.prototype.matches) {
          return (
            /**
            * @param {?} element
            * @param {?} selector
            * @return {?}
            */
            function (element, selector) {
              return element.matches(selector);
            }
          );
        } else {
          /** @type {?} */
          var proto =
          /** @type {?} */
          Element.prototype;
          /** @type {?} */

          var fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;

          if (fn) {
            return (
              /**
              * @param {?} element
              * @param {?} selector
              * @return {?}
              */
              function (element, selector) {
                return fn.apply(element, [selector]);
              }
            );
          } else {
            return _matches;
          }
        }
      }();

      _query =
      /**
      * @param {?} element
      * @param {?} selector
      * @param {?} multi
      * @return {?}
      */
      function _query(element, selector, multi) {
        /** @type {?} */
        var results = [];

        if (multi) {
          results.push.apply(results, _toConsumableArray(element.querySelectorAll(selector)));
        } else {
          /** @type {?} */
          var elm = element.querySelector(selector);

          if (elm) {
            results.push(elm);
          }
        }

        return results;
      };
    }
    /**
     * @param {?} prop
     * @return {?}
     */


    function containsVendorPrefix(prop) {
      // Webkit is the only real popular vendor prefix nowadays
      // cc: http://shouldiprefix.com/
      return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit
    }
    /** @type {?} */


    var _CACHED_BODY = null;
    /** @type {?} */

    var _IS_WEBKIT = false;
    /**
     * @param {?} prop
     * @return {?}
     */

    function _validateStyleProperty(prop) {
      if (!_CACHED_BODY) {
        _CACHED_BODY = getBodyNode() || {};
        _IS_WEBKIT =
        /** @type {?} */
        _CACHED_BODY.style ? 'WebkitAppearance' in
        /** @type {?} */
        _CACHED_BODY.style : false;
      }
      /** @type {?} */


      var result = true;

      if (
      /** @type {?} */
      _CACHED_BODY.style && !containsVendorPrefix(prop)) {
        result = prop in
        /** @type {?} */
        _CACHED_BODY.style;

        if (!result && _IS_WEBKIT) {
          /** @type {?} */
          var camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);
          result = camelProp in
          /** @type {?} */
          _CACHED_BODY.style;
        }
      }

      return result;
    }
    /**
     * @return {?}
     */


    function getBodyNode() {
      if (typeof document != 'undefined') {
        return document.body;
      }

      return null;
    }
    /** @type {?} */


    var _matchesElement = _matches;
    /** @type {?} */

    var _containsElement = _contains;
    /** @type {?} */

    var invokeQuery = _query;
    /**
     * @param {?} object
     * @return {?}
     */

    function hypenatePropsObject(object) {
      /** @type {?} */
      var newObj = {};
      Object.keys(object).forEach(
      /**
      * @param {?} prop
      * @return {?}
      */
      function (prop) {
        /** @type {?} */
        var newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');
        newObj[newProp] = object[prop];
      });
      return newObj;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/animation_driver.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@publicApi
     */


    var NoopAnimationDriver = /*#__PURE__*/function () {
      function NoopAnimationDriver() {
        _classCallCheck(this, NoopAnimationDriver);
      }

      _createClass(NoopAnimationDriver, [{
        key: "validateStyleProperty",

        /**
         * @param {?} prop
         * @return {?}
         */
        value: function validateStyleProperty(prop) {
          return _validateStyleProperty(prop);
        }
        /**
         * @param {?} element
         * @param {?} selector
         * @return {?}
         */

      }, {
        key: "matchesElement",
        value: function matchesElement(element, selector) {
          return _matchesElement(element, selector);
        }
        /**
         * @param {?} elm1
         * @param {?} elm2
         * @return {?}
         */

      }, {
        key: "containsElement",
        value: function containsElement(elm1, elm2) {
          return _containsElement(elm1, elm2);
        }
        /**
         * @param {?} element
         * @param {?} selector
         * @param {?} multi
         * @return {?}
         */

      }, {
        key: "query",
        value: function query(element, selector, multi) {
          return invokeQuery(element, selector, multi);
        }
        /**
         * @param {?} element
         * @param {?} prop
         * @param {?=} defaultValue
         * @return {?}
         */

      }, {
        key: "computeStyle",
        value: function computeStyle(element, prop, defaultValue) {
          return defaultValue || '';
        }
        /**
         * @param {?} element
         * @param {?} keyframes
         * @param {?} duration
         * @param {?} delay
         * @param {?} easing
         * @param {?=} previousPlayers
         * @param {?=} scrubberAccessRequested
         * @return {?}
         */

      }, {
        key: "animate",
        value: function animate(element, keyframes, duration, delay, easing) {
          var previousPlayers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
          var scrubberAccessRequested = arguments.length > 6 ? arguments[6] : undefined;
          return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__["NoopAnimationPlayer"](duration, delay);
        }
      }]);

      return NoopAnimationDriver;
    }();

    NoopAnimationDriver.ɵfac = function NoopAnimationDriver_Factory(t) {
      return new (t || NoopAnimationDriver)();
    };

    NoopAnimationDriver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
      token: NoopAnimationDriver,
      factory: NoopAnimationDriver.ɵfac
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](NoopAnimationDriver, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
      }], null, null);
    })();
    /**
     * \@publicApi
     * @abstract
     */


    var AnimationDriver = function AnimationDriver() {
      _classCallCheck(this, AnimationDriver);
    };

    AnimationDriver.NOOP = new NoopAnimationDriver();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/util.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ONE_SECOND = 1000;
    /** @type {?} */

    var SUBSTITUTION_EXPR_START = '{{';
    /** @type {?} */

    var SUBSTITUTION_EXPR_END = '}}';
    /** @type {?} */

    var ENTER_CLASSNAME = 'ng-enter';
    /** @type {?} */

    var LEAVE_CLASSNAME = 'ng-leave';
    /** @type {?} */

    var ENTER_SELECTOR = '.ng-enter';
    /** @type {?} */

    var LEAVE_SELECTOR = '.ng-leave';
    /** @type {?} */

    var NG_TRIGGER_CLASSNAME = 'ng-trigger';
    /** @type {?} */

    var NG_TRIGGER_SELECTOR = '.ng-trigger';
    /** @type {?} */

    var NG_ANIMATING_CLASSNAME = 'ng-animating';
    /** @type {?} */

    var NG_ANIMATING_SELECTOR = '.ng-animating';
    /**
     * @param {?} value
     * @return {?}
     */

    function resolveTimingValue(value) {
      if (typeof value == 'number') return value;
      /** @type {?} */

      var matches = value.match(/^(-?[\.\d]+)(m?s)/);
      if (!matches || matches.length < 2) return 0;
      return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
    }
    /**
     * @param {?} value
     * @param {?} unit
     * @return {?}
     */


    function _convertTimeValueToMS(value, unit) {
      switch (unit) {
        case 's':
          return value * ONE_SECOND;

        default:
          // ms or something else
          return value;
      }
    }
    /**
     * @param {?} timings
     * @param {?} errors
     * @param {?=} allowNegativeValues
     * @return {?}
     */


    function resolveTiming(timings, errors, allowNegativeValues) {
      return timings.hasOwnProperty('duration') ?
      /** @type {?} */
      timings : parseTimeExpression(
      /** @type {?} */
      timings, errors, allowNegativeValues);
    }
    /**
     * @param {?} exp
     * @param {?} errors
     * @param {?=} allowNegativeValues
     * @return {?}
     */


    function parseTimeExpression(exp, errors, allowNegativeValues) {
      /** @type {?} */
      var regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
      /** @type {?} */

      var duration;
      /** @type {?} */

      var delay = 0;
      /** @type {?} */

      var easing = '';

      if (typeof exp === 'string') {
        /** @type {?} */
        var matches = exp.match(regex);

        if (matches === null) {
          errors.push("The provided timing value \"".concat(exp, "\" is invalid."));
          return {
            duration: 0,
            delay: 0,
            easing: ''
          };
        }

        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        /** @type {?} */

        var delayMatch = matches[3];

        if (delayMatch != null) {
          delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);
        }
        /** @type {?} */


        var easingVal = matches[5];

        if (easingVal) {
          easing = easingVal;
        }
      } else {
        duration = exp;
      }

      if (!allowNegativeValues) {
        /** @type {?} */
        var containsErrors = false;
        /** @type {?} */

        var startIndex = errors.length;

        if (duration < 0) {
          errors.push("Duration values below 0 are not allowed for this animation step.");
          containsErrors = true;
        }

        if (delay < 0) {
          errors.push("Delay values below 0 are not allowed for this animation step.");
          containsErrors = true;
        }

        if (containsErrors) {
          errors.splice(startIndex, 0, "The provided timing value \"".concat(exp, "\" is invalid."));
        }
      }

      return {
        duration: duration,
        delay: delay,
        easing: easing
      };
    }
    /**
     * @param {?} obj
     * @param {?=} destination
     * @return {?}
     */


    function copyObj(obj) {
      var destination = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Object.keys(obj).forEach(
      /**
      * @param {?} prop
      * @return {?}
      */
      function (prop) {
        destination[prop] = obj[prop];
      });
      return destination;
    }
    /**
     * @param {?} styles
     * @return {?}
     */


    function normalizeStyles(styles) {
      /** @type {?} */
      var normalizedStyles = {};

      if (Array.isArray(styles)) {
        styles.forEach(
        /**
        * @param {?} data
        * @return {?}
        */
        function (data) {
          return copyStyles(data, false, normalizedStyles);
        });
      } else {
        copyStyles(styles, false, normalizedStyles);
      }

      return normalizedStyles;
    }
    /**
     * @param {?} styles
     * @param {?} readPrototype
     * @param {?=} destination
     * @return {?}
     */


    function copyStyles(styles, readPrototype) {
      var destination = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (readPrototype) {
        // we make use of a for-in loop so that the
        // prototypically inherited properties are
        // revealed from the backFill map
        for (var prop in styles) {
          destination[prop] = styles[prop];
        }
      } else {
        copyObj(styles, destination);
      }

      return destination;
    }
    /**
     * @param {?} element
     * @param {?} key
     * @param {?} value
     * @return {?}
     */


    function getStyleAttributeString(element, key, value) {
      // Return the key-value pair string to be added to the style attribute for the
      // given CSS style key.
      if (value) {
        return key + ':' + value + ';';
      } else {
        return '';
      }
    }
    /**
     * @param {?} element
     * @return {?}
     */


    function writeStyleAttribute(element) {
      // Read the style property of the element and manually reflect it to the
      // style attribute. This is needed because Domino on platform-server doesn't
      // understand the full set of allowed CSS properties and doesn't reflect some
      // of them automatically.

      /** @type {?} */
      var styleAttrValue = '';

      for (var i = 0; i < element.style.length; i++) {
        /** @type {?} */
        var key = element.style.item(i);
        styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));
      }

      for (var _key in element.style) {
        // Skip internal Domino properties that don't need to be reflected.
        if (!element.style.hasOwnProperty(_key) || _key.startsWith('_')) {
          continue;
        }
        /** @type {?} */


        var dashKey = camelCaseToDashCase(_key);
        styleAttrValue += getStyleAttributeString(element, dashKey, element.style[_key]);
      }

      element.setAttribute('style', styleAttrValue);
    }
    /**
     * @param {?} element
     * @param {?} styles
     * @param {?=} formerStyles
     * @return {?}
     */


    function setStyles(element, styles, formerStyles) {
      if (element['style']) {
        Object.keys(styles).forEach(
        /**
        * @param {?} prop
        * @return {?}
        */
        function (prop) {
          /** @type {?} */
          var camelProp = dashCaseToCamelCase(prop);

          if (formerStyles && !formerStyles.hasOwnProperty(prop)) {
            formerStyles[prop] = element.style[camelProp];
          }

          element.style[camelProp] = styles[prop];
        }); // On the server set the 'style' attribute since it's not automatically reflected.

        if (isNode()) {
          writeStyleAttribute(element);
        }
      }
    }
    /**
     * @param {?} element
     * @param {?} styles
     * @return {?}
     */


    function eraseStyles(element, styles) {
      if (element['style']) {
        Object.keys(styles).forEach(
        /**
        * @param {?} prop
        * @return {?}
        */
        function (prop) {
          /** @type {?} */
          var camelProp = dashCaseToCamelCase(prop);
          element.style[camelProp] = '';
        }); // On the server set the 'style' attribute since it's not automatically reflected.

        if (isNode()) {
          writeStyleAttribute(element);
        }
      }
    }
    /**
     * @param {?} steps
     * @return {?}
     */


    function normalizeAnimationEntry(steps) {
      if (Array.isArray(steps)) {
        if (steps.length == 1) return steps[0];
        return Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["sequence"])(steps);
      }

      return (
        /** @type {?} */
        steps
      );
    }
    /**
     * @param {?} value
     * @param {?} options
     * @param {?} errors
     * @return {?}
     */


    function validateStyleParams(value, options, errors) {
      /** @type {?} */
      var params = options.params || {};
      /** @type {?} */

      var matches = extractStyleParams(value);

      if (matches.length) {
        matches.forEach(
        /**
        * @param {?} varName
        * @return {?}
        */
        function (varName) {
          if (!params.hasOwnProperty(varName)) {
            errors.push("Unable to resolve the local animation param ".concat(varName, " in the given list of values"));
          }
        });
      }
    }
    /** @type {?} */


    var PARAM_REGEX = new RegExp("".concat(SUBSTITUTION_EXPR_START, "\\s*(.+?)\\s*").concat(SUBSTITUTION_EXPR_END), 'g');
    /**
     * @param {?} value
     * @return {?}
     */

    function extractStyleParams(value) {
      /** @type {?} */
      var params = [];

      if (typeof value === 'string') {
        /** @type {?} */
        var match;

        while (match = PARAM_REGEX.exec(value)) {
          params.push(
          /** @type {?} */
          match[1]);
        }

        PARAM_REGEX.lastIndex = 0;
      }

      return params;
    }
    /**
     * @param {?} value
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */


    function interpolateParams(value, params, errors) {
      /** @type {?} */
      var original = value.toString();
      /** @type {?} */

      var str = original.replace(PARAM_REGEX,
      /**
      * @param {?} _
      * @param {?} varName
      * @return {?}
      */
      function (_, varName) {
        /** @type {?} */
        var localVal = params[varName]; // this means that the value was never overridden by the data passed in by the user

        if (!params.hasOwnProperty(varName)) {
          errors.push("Please provide a value for the animation param ".concat(varName));
          localVal = '';
        }

        return localVal.toString();
      }); // we do this to assert that numeric values stay as they are

      return str == original ? value : str;
    }
    /**
     * @param {?} iterator
     * @return {?}
     */


    function iteratorToArray(iterator) {
      /** @type {?} */
      var arr = [];
      /** @type {?} */

      var item = iterator.next();

      while (!item.done) {
        arr.push(item.value);
        item = iterator.next();
      }

      return arr;
    }
    /**
     * @param {?} source
     * @param {?} destination
     * @return {?}
     */


    function mergeAnimationOptions(source, destination) {
      if (source.params) {
        /** @type {?} */
        var p0 = source.params;

        if (!destination.params) {
          destination.params = {};
        }
        /** @type {?} */


        var p1 = destination.params;
        Object.keys(p0).forEach(
        /**
        * @param {?} param
        * @return {?}
        */
        function (param) {
          if (!p1.hasOwnProperty(param)) {
            p1[param] = p0[param];
          }
        });
      }

      return destination;
    }
    /** @type {?} */


    var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    /**
     * @param {?} input
     * @return {?}
     */

    function dashCaseToCamelCase(input) {
      return input.replace(DASH_CASE_REGEXP,
      /**
      * @param {...?} m
      * @return {?}
      */
      function () {
        for (var _len = arguments.length, m = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
          m[_key2] = arguments[_key2];
        }

        return m[1].toUpperCase();
      });
    }
    /**
     * @param {?} input
     * @return {?}
     */


    function camelCaseToDashCase(input) {
      return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    /**
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */


    function allowPreviousPlayerStylesMerge(duration, delay) {
      return duration === 0 || delay === 0;
    }
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} previousStyles
     * @return {?}
     */


    function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {
      /** @type {?} */
      var previousStyleProps = Object.keys(previousStyles);

      if (previousStyleProps.length && keyframes.length) {
        /** @type {?} */
        var startingKeyframe = keyframes[0];
        /** @type {?} */

        var missingStyleProps = [];
        previousStyleProps.forEach(
        /**
        * @param {?} prop
        * @return {?}
        */
        function (prop) {
          if (!startingKeyframe.hasOwnProperty(prop)) {
            missingStyleProps.push(prop);
          }

          startingKeyframe[prop] = previousStyles[prop];
        });

        if (missingStyleProps.length) {
          var _loop2 = function _loop2() {
            /** @type {?} */
            var kf = keyframes[i];
            missingStyleProps.forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              kf[prop] = computeStyle(element, prop);
            });
          };

          // tslint:disable-next-line
          for (var i = 1; i < keyframes.length; i++) {
            _loop2();
          }
        }
      }

      return keyframes;
    }
    /**
     * @param {?} visitor
     * @param {?} node
     * @param {?} context
     * @return {?}
     */


    function visitDslNode(visitor, node, context) {
      switch (node.type) {
        case 7
        /* Trigger */
        :
          return visitor.visitTrigger(node, context);

        case 0
        /* State */
        :
          return visitor.visitState(node, context);

        case 1
        /* Transition */
        :
          return visitor.visitTransition(node, context);

        case 2
        /* Sequence */
        :
          return visitor.visitSequence(node, context);

        case 3
        /* Group */
        :
          return visitor.visitGroup(node, context);

        case 4
        /* Animate */
        :
          return visitor.visitAnimate(node, context);

        case 5
        /* Keyframes */
        :
          return visitor.visitKeyframes(node, context);

        case 6
        /* Style */
        :
          return visitor.visitStyle(node, context);

        case 8
        /* Reference */
        :
          return visitor.visitReference(node, context);

        case 9
        /* AnimateChild */
        :
          return visitor.visitAnimateChild(node, context);

        case 10
        /* AnimateRef */
        :
          return visitor.visitAnimateRef(node, context);

        case 11
        /* Query */
        :
          return visitor.visitQuery(node, context);

        case 12
        /* Stagger */
        :
          return visitor.visitStagger(node, context);

        default:
          throw new Error("Unable to resolve animation metadata node #".concat(node.type));
      }
    }
    /**
     * @param {?} element
     * @param {?} prop
     * @return {?}
     */


    function computeStyle(element, prop) {
      return (
        /** @type {?} */
        window.getComputedStyle(element)[prop]
      );
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_transition_expr.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     * @type {?}
     */


    var ANY_STATE = '*';
    /**
     * @param {?} transitionValue
     * @param {?} errors
     * @return {?}
     */

    function parseTransitionExpr(transitionValue, errors) {
      /** @type {?} */
      var expressions = [];

      if (typeof transitionValue == 'string') {
        transitionValue.split(/\s*,\s*/).forEach(
        /**
        * @param {?} str
        * @return {?}
        */
        function (str) {
          return parseInnerTransitionStr(str, expressions, errors);
        });
      } else {
        expressions.push(
        /** @type {?} */
        transitionValue);
      }

      return expressions;
    }
    /**
     * @param {?} eventStr
     * @param {?} expressions
     * @param {?} errors
     * @return {?}
     */


    function parseInnerTransitionStr(eventStr, expressions, errors) {
      if (eventStr[0] == ':') {
        /** @type {?} */
        var result = parseAnimationAlias(eventStr, errors);

        if (typeof result == 'function') {
          expressions.push(result);
          return;
        }

        eventStr = result;
      }
      /** @type {?} */


      var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);

      if (match == null || match.length < 4) {
        errors.push("The provided transition expression \"".concat(eventStr, "\" is not supported"));
        return expressions;
      }
      /** @type {?} */


      var fromState = match[1];
      /** @type {?} */

      var separator = match[2];
      /** @type {?} */

      var toState = match[3];
      expressions.push(makeLambdaFromStates(fromState, toState));
      /** @type {?} */

      var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;

      if (separator[0] == '<' && !isFullAnyStateExpr) {
        expressions.push(makeLambdaFromStates(toState, fromState));
      }
    }
    /**
     * @param {?} alias
     * @param {?} errors
     * @return {?}
     */


    function parseAnimationAlias(alias, errors) {
      switch (alias) {
        case ':enter':
          return 'void => *';

        case ':leave':
          return '* => void';

        case ':increment':
          return (
            /**
            * @param {?} fromState
            * @param {?} toState
            * @return {?}
            */
            function (fromState, toState) {
              return parseFloat(toState) > parseFloat(fromState);
            }
          );

        case ':decrement':
          return (
            /**
            * @param {?} fromState
            * @param {?} toState
            * @return {?}
            */
            function (fromState, toState) {
              return parseFloat(toState) < parseFloat(fromState);
            }
          );

        default:
          errors.push("The transition alias value \"".concat(alias, "\" is not supported"));
          return '* => *';
      }
    } // DO NOT REFACTOR ... keep the follow set instantiations
    // with the values intact (closure compiler for some reason
    // removes follow-up lines that add the values outside of
    // the constructor...

    /** @type {?} */


    var TRUE_BOOLEAN_VALUES = new Set(['true', '1']);
    /** @type {?} */

    var FALSE_BOOLEAN_VALUES = new Set(['false', '0']);
    /**
     * @param {?} lhs
     * @param {?} rhs
     * @return {?}
     */

    function makeLambdaFromStates(lhs, rhs) {
      /** @type {?} */
      var LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
      /** @type {?} */

      var RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
      return (
        /**
        * @param {?} fromState
        * @param {?} toState
        * @return {?}
        */
        function (fromState, toState) {
          /** @type {?} */
          var lhsMatch = lhs == ANY_STATE || lhs == fromState;
          /** @type {?} */

          var rhsMatch = rhs == ANY_STATE || rhs == toState;

          if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {
            lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
          }

          if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {
            rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
          }

          return lhsMatch && rhsMatch;
        }
      );
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_ast_builder.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var SELF_TOKEN = ':self';
    /** @type {?} */

    var SELF_TOKEN_REGEX = new RegExp("s*".concat(SELF_TOKEN, "s*,?"), 'g');
    /*
     * [Validation]
     * The visitor code below will traverse the animation AST generated by the animation verb functions
     * (the output is a tree of objects) and attempt to perform a series of validations on the data. The
     * following corner-cases will be validated:
     *
     * 1. Overlap of animations
     * Given that a CSS property cannot be animated in more than one place at the same time, it's
     * important that this behavior is detected and validated. The way in which this occurs is that
     * each time a style property is examined, a string-map containing the property will be updated with
     * the start and end times for when the property is used within an animation step.
     *
     * If there are two or more parallel animations that are currently running (these are invoked by the
     * group()) on the same element then the validator will throw an error. Since the start/end timing
     * values are collected for each property then if the current animation step is animating the same
     * property and its timing values fall anywhere into the window of time that the property is
     * currently being animated within then this is what causes an error.
     *
     * 2. Timing values
     * The validator will validate to see if a timing value of `duration delay easing` or
     * `durationNumber` is valid or not.
     *
     * (note that upon validation the code below will replace the timing data with an object containing
     * {duration,delay,easing}.
     *
     * 3. Offset Validation
     * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().
     * Offsets within keyframes() are considered valid when:
     *
     *   - No offsets are used at all
     *   - Each style() entry contains an offset value
     *   - Each offset is between 0 and 1
     *   - Each offset is greater to or equal than the previous one
     *
     * Otherwise an error will be thrown.
     */

    /**
     * @param {?} driver
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */

    function buildAnimationAst(driver, metadata, errors) {
      return new AnimationAstBuilderVisitor(driver).build(metadata, errors);
    }
    /** @type {?} */


    var ROOT_SELECTOR = '';

    var AnimationAstBuilderVisitor = /*#__PURE__*/function () {
      /**
       * @param {?} _driver
       */
      function AnimationAstBuilderVisitor(_driver) {
        _classCallCheck(this, AnimationAstBuilderVisitor);

        this._driver = _driver;
      }
      /**
       * @param {?} metadata
       * @param {?} errors
       * @return {?}
       */


      _createClass(AnimationAstBuilderVisitor, [{
        key: "build",
        value: function build(metadata, errors) {
          /** @type {?} */
          var context = new AnimationAstBuilderContext(errors);

          this._resetContextStyleTimingState(context);

          return (
            /** @type {?} */
            visitDslNode(this, normalizeAnimationEntry(metadata), context)
          );
        }
        /**
         * @private
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "_resetContextStyleTimingState",
        value: function _resetContextStyleTimingState(context) {
          context.currentQuerySelector = ROOT_SELECTOR;
          context.collectedStyles = {};
          context.collectedStyles[ROOT_SELECTOR] = {};
          context.currentTime = 0;
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitTrigger",
        value: function visitTrigger(metadata, context) {
          var _this6 = this;

          /** @type {?} */
          var queryCount = context.queryCount = 0;
          /** @type {?} */

          var depCount = context.depCount = 0;
          /** @type {?} */

          var states = [];
          /** @type {?} */

          var transitions = [];

          if (metadata.name.charAt(0) == '@') {
            context.errors.push('animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\'@foo\', [...]))');
          }

          metadata.definitions.forEach(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            _this6._resetContextStyleTimingState(context);

            if (def.type == 0
            /* State */
            ) {
                /** @type {?} */
                var stateDef =
                /** @type {?} */
                def;
                /** @type {?} */

                var name = stateDef.name;
                name.toString().split(/\s*,\s*/).forEach(
                /**
                * @param {?} n
                * @return {?}
                */
                function (n) {
                  stateDef.name = n;
                  states.push(_this6.visitState(stateDef, context));
                });
                stateDef.name = name;
              } else if (def.type == 1
            /* Transition */
            ) {
                /** @type {?} */
                var transition = _this6.visitTransition(
                /** @type {?} */
                def, context);

                queryCount += transition.queryCount;
                depCount += transition.depCount;
                transitions.push(transition);
              } else {
              context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
            }
          });
          return {
            type: 7
            /* Trigger */
            ,
            name: metadata.name,
            states: states,
            transitions: transitions,
            queryCount: queryCount,
            depCount: depCount,
            options: null
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitState",
        value: function visitState(metadata, context) {
          /** @type {?} */
          var styleAst = this.visitStyle(metadata.styles, context);
          /** @type {?} */

          var astParams = metadata.options && metadata.options.params || null;

          if (styleAst.containsDynamicStyles) {
            /** @type {?} */
            var missingSubs = new Set();
            /** @type {?} */

            var params = astParams || {};
            styleAst.styles.forEach(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              if (isObject(value)) {
                /** @type {?} */
                var stylesObj =
                /** @type {?} */
                value;
                Object.keys(stylesObj).forEach(
                /**
                * @param {?} prop
                * @return {?}
                */
                function (prop) {
                  extractStyleParams(stylesObj[prop]).forEach(
                  /**
                  * @param {?} sub
                  * @return {?}
                  */
                  function (sub) {
                    if (!params.hasOwnProperty(sub)) {
                      missingSubs.add(sub);
                    }
                  });
                });
              }
            });

            if (missingSubs.size) {
              /** @type {?} */
              var missingSubsArr = iteratorToArray(missingSubs.values());
              context.errors.push("state(\"".concat(metadata.name, "\", ...) must define default values for all the following style substitutions: ").concat(missingSubsArr.join(', ')));
            }
          }

          return {
            type: 0
            /* State */
            ,
            name: metadata.name,
            style: styleAst,
            options: astParams ? {
              params: astParams
            } : null
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitTransition",
        value: function visitTransition(metadata, context) {
          context.queryCount = 0;
          context.depCount = 0;
          /** @type {?} */

          var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
          /** @type {?} */

          var matchers = parseTransitionExpr(metadata.expr, context.errors);
          return {
            type: 1
            /* Transition */
            ,
            matchers: matchers,
            animation: animation,
            queryCount: context.queryCount,
            depCount: context.depCount,
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitSequence",
        value: function visitSequence(metadata, context) {
          var _this7 = this;

          return {
            type: 2
            /* Sequence */
            ,
            steps: metadata.steps.map(
            /**
            * @param {?} s
            * @return {?}
            */
            function (s) {
              return visitDslNode(_this7, s, context);
            }),
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitGroup",
        value: function visitGroup(metadata, context) {
          var _this8 = this;

          /** @type {?} */
          var currentTime = context.currentTime;
          /** @type {?} */

          var furthestTime = 0;
          /** @type {?} */

          var steps = metadata.steps.map(
          /**
          * @param {?} step
          * @return {?}
          */
          function (step) {
            context.currentTime = currentTime;
            /** @type {?} */

            var innerAst = visitDslNode(_this8, step, context);
            furthestTime = Math.max(furthestTime, context.currentTime);
            return innerAst;
          });
          context.currentTime = furthestTime;
          return {
            type: 3
            /* Group */
            ,
            steps: steps,
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitAnimate",
        value: function visitAnimate(metadata, context) {
          /** @type {?} */
          var timingAst = constructTimingAst(metadata.timings, context.errors);
          context.currentAnimateTimings = timingAst;
          /** @type {?} */

          var styleAst;
          /** @type {?} */

          var styleMetadata = metadata.styles ? metadata.styles : Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({});

          if (styleMetadata.type == 5
          /* Keyframes */
          ) {
              styleAst = this.visitKeyframes(
              /** @type {?} */
              styleMetadata, context);
            } else {
            /** @type {?} */
            var _styleMetadata =
            /** @type {?} */
            metadata.styles;
            /** @type {?} */

            var isEmpty = false;

            if (!_styleMetadata) {
              isEmpty = true;
              /** @type {?} */

              var newStyleData = {};

              if (timingAst.easing) {
                newStyleData['easing'] = timingAst.easing;
              }

              _styleMetadata = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])(newStyleData);
            }

            context.currentTime += timingAst.duration + timingAst.delay;
            /** @type {?} */

            var _styleAst = this.visitStyle(_styleMetadata, context);

            _styleAst.isEmptyStep = isEmpty;
            styleAst = _styleAst;
          }

          context.currentAnimateTimings = null;
          return {
            type: 4
            /* Animate */
            ,
            timings: timingAst,
            style: styleAst,
            options: null
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitStyle",
        value: function visitStyle(metadata, context) {
          /** @type {?} */
          var ast = this._makeStyleAst(metadata, context);

          this._validateStyleAst(ast, context);

          return ast;
        }
        /**
         * @private
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "_makeStyleAst",
        value: function _makeStyleAst(metadata, context) {
          /** @type {?} */
          var styles = [];

          if (Array.isArray(metadata.styles)) {
            /** @type {?} */
            metadata.styles.forEach(
            /**
            * @param {?} styleTuple
            * @return {?}
            */
            function (styleTuple) {
              if (typeof styleTuple == 'string') {
                if (styleTuple == _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"]) {
                  styles.push(styleTuple);
                } else {
                  context.errors.push("The provided style string value ".concat(styleTuple, " is not allowed."));
                }
              } else {
                styles.push(styleTuple);
              }
            });
          } else {
            styles.push(metadata.styles);
          }
          /** @type {?} */


          var containsDynamicStyles = false;
          /** @type {?} */

          var collectedEasing = null;
          styles.forEach(
          /**
          * @param {?} styleData
          * @return {?}
          */
          function (styleData) {
            if (isObject(styleData)) {
              /** @type {?} */
              var styleMap =
              /** @type {?} */
              styleData;
              /** @type {?} */

              var easing = styleMap['easing'];

              if (easing) {
                collectedEasing =
                /** @type {?} */
                easing;
                delete styleMap['easing'];
              }

              if (!containsDynamicStyles) {
                for (var prop in styleMap) {
                  /** @type {?} */
                  var value = styleMap[prop];

                  if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
                    containsDynamicStyles = true;
                    break;
                  }
                }
              }
            }
          });
          return {
            type: 6
            /* Style */
            ,
            styles: styles,
            easing: collectedEasing,
            offset: metadata.offset,
            containsDynamicStyles: containsDynamicStyles,
            options: null
          };
        }
        /**
         * @private
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "_validateStyleAst",
        value: function _validateStyleAst(ast, context) {
          var _this9 = this;

          /** @type {?} */
          var timings = context.currentAnimateTimings;
          /** @type {?} */

          var endTime = context.currentTime;
          /** @type {?} */

          var startTime = context.currentTime;

          if (timings && startTime > 0) {
            startTime -= timings.duration + timings.delay;
          }

          ast.styles.forEach(
          /**
          * @param {?} tuple
          * @return {?}
          */
          function (tuple) {
            if (typeof tuple == 'string') return;
            Object.keys(tuple).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              if (!_this9._driver.validateStyleProperty(prop)) {
                context.errors.push("The provided animation property \"".concat(prop, "\" is not a supported CSS property for animations"));
                return;
              }
              /** @type {?} */


              var collectedStyles = context.collectedStyles[
              /** @type {?} */
              context.currentQuerySelector];
              /** @type {?} */

              var collectedEntry = collectedStyles[prop];
              /** @type {?} */

              var updateCollectedStyle = true;

              if (collectedEntry) {
                if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {
                  context.errors.push("The CSS property \"".concat(prop, "\" that exists between the times of \"").concat(collectedEntry.startTime, "ms\" and \"").concat(collectedEntry.endTime, "ms\" is also being animated in a parallel animation between the times of \"").concat(startTime, "ms\" and \"").concat(endTime, "ms\""));
                  updateCollectedStyle = false;
                } // we always choose the smaller start time value since we
                // want to have a record of the entire animation window where
                // the style property is being animated in between


                startTime = collectedEntry.startTime;
              }

              if (updateCollectedStyle) {
                collectedStyles[prop] = {
                  startTime: startTime,
                  endTime: endTime
                };
              }

              if (context.options) {
                validateStyleParams(tuple[prop], context.options, context.errors);
              }
            });
          });
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitKeyframes",
        value: function visitKeyframes(metadata, context) {
          var _this10 = this;

          /** @type {?} */
          var ast = {
            type: 5
            /* Keyframes */
            ,
            styles: [],
            options: null
          };

          if (!context.currentAnimateTimings) {
            context.errors.push("keyframes() must be placed inside of a call to animate()");
            return ast;
          }
          /** @type {?} */


          var MAX_KEYFRAME_OFFSET = 1;
          /** @type {?} */

          var totalKeyframesWithOffsets = 0;
          /** @type {?} */

          var offsets = [];
          /** @type {?} */

          var offsetsOutOfOrder = false;
          /** @type {?} */

          var keyframesOutOfRange = false;
          /** @type {?} */

          var previousOffset = 0;
          /** @type {?} */

          var keyframes = metadata.steps.map(
          /**
          * @param {?} styles
          * @return {?}
          */
          function (styles) {
            /** @type {?} */
            var style = _this10._makeStyleAst(styles, context);
            /** @type {?} */


            var offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);
            /** @type {?} */

            var offset = 0;

            if (offsetVal != null) {
              totalKeyframesWithOffsets++;
              offset = style.offset = offsetVal;
            }

            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
            previousOffset = offset;
            offsets.push(offset);
            return style;
          });

          if (keyframesOutOfRange) {
            context.errors.push("Please ensure that all keyframe offsets are between 0 and 1");
          }

          if (offsetsOutOfOrder) {
            context.errors.push("Please ensure that all keyframe offsets are in order");
          }
          /** @type {?} */


          var length = metadata.steps.length;
          /** @type {?} */

          var generatedOffset = 0;

          if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
            context.errors.push("Not all style() steps within the declared keyframes() contain offsets");
          } else if (totalKeyframesWithOffsets == 0) {
            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
          }
          /** @type {?} */


          var limit = length - 1;
          /** @type {?} */

          var currentTime = context.currentTime;
          /** @type {?} */

          var currentAnimateTimings =
          /** @type {?} */
          context.currentAnimateTimings;
          /** @type {?} */

          var animateDuration = currentAnimateTimings.duration;
          keyframes.forEach(
          /**
          * @param {?} kf
          * @param {?} i
          * @return {?}
          */
          function (kf, i) {
            /** @type {?} */
            var offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];
            /** @type {?} */

            var durationUpToThisFrame = offset * animateDuration;
            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
            currentAnimateTimings.duration = durationUpToThisFrame;

            _this10._validateStyleAst(kf, context);

            kf.offset = offset;
            ast.styles.push(kf);
          });
          return ast;
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitReference",
        value: function visitReference(metadata, context) {
          return {
            type: 8
            /* Reference */
            ,
            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitAnimateChild",
        value: function visitAnimateChild(metadata, context) {
          context.depCount++;
          return {
            type: 9
            /* AnimateChild */
            ,
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitAnimateRef",
        value: function visitAnimateRef(metadata, context) {
          return {
            type: 10
            /* AnimateRef */
            ,
            animation: this.visitReference(metadata.animation, context),
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitQuery",
        value: function visitQuery(metadata, context) {
          /** @type {?} */
          var parentSelector =
          /** @type {?} */
          context.currentQuerySelector;
          /** @type {?} */

          var options =
          /** @type {?} */
          metadata.options || {};
          context.queryCount++;
          context.currentQuery = metadata;

          var _normalizeSelector = normalizeSelector(metadata.selector),
              _normalizeSelector2 = _slicedToArray(_normalizeSelector, 2),
              selector = _normalizeSelector2[0],
              includeSelf = _normalizeSelector2[1];

          context.currentQuerySelector = parentSelector.length ? parentSelector + ' ' + selector : selector;
          getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
          /** @type {?} */

          var animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
          context.currentQuery = null;
          context.currentQuerySelector = parentSelector;
          return {
            type: 11
            /* Query */
            ,
            selector: selector,
            limit: options.limit || 0,
            optional: !!options.optional,
            includeSelf: includeSelf,
            animation: animation,
            originalSelector: metadata.selector,
            options: normalizeAnimationOptions(metadata.options)
          };
        }
        /**
         * @param {?} metadata
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitStagger",
        value: function visitStagger(metadata, context) {
          if (!context.currentQuery) {
            context.errors.push("stagger() can only be used inside of query()");
          }
          /** @type {?} */


          var timings = metadata.timings === 'full' ? {
            duration: 0,
            delay: 0,
            easing: 'full'
          } : resolveTiming(metadata.timings, context.errors, true);
          return {
            type: 12
            /* Stagger */
            ,
            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
            timings: timings,
            options: null
          };
        }
      }]);

      return AnimationAstBuilderVisitor;
    }();

    if (false) {}
    /**
     * @param {?} selector
     * @return {?}
     */


    function normalizeSelector(selector) {
      /** @type {?} */
      var hasAmpersand = selector.split(/\s*,\s*/).find(
      /**
      * @param {?} token
      * @return {?}
      */
      function (token) {
        return token == SELF_TOKEN;
      }) ? true : false;

      if (hasAmpersand) {
        selector = selector.replace(SELF_TOKEN_REGEX, '');
      } // the :enter and :leave selectors are filled in at runtime during timeline building


      selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g,
      /**
      * @param {?} match
      * @return {?}
      */
      function (match) {
        return NG_TRIGGER_SELECTOR + '-' + match.substr(1);
      }).replace(/:animating/g, NG_ANIMATING_SELECTOR);
      return [selector, hasAmpersand];
    }
    /**
     * @param {?} obj
     * @return {?}
     */


    function normalizeParams(obj) {
      return obj ? copyObj(obj) : null;
    }

    var AnimationAstBuilderContext =
    /**
     * @param {?} errors
     */
    function AnimationAstBuilderContext(errors) {
      _classCallCheck(this, AnimationAstBuilderContext);

      this.errors = errors;
      this.queryCount = 0;
      this.depCount = 0;
      this.currentTransition = null;
      this.currentQuery = null;
      this.currentQuerySelector = null;
      this.currentAnimateTimings = null;
      this.currentTime = 0;
      this.collectedStyles = {};
      this.options = null;
    };

    if (false) {}
    /**
     * @param {?} styles
     * @return {?}
     */


    function consumeOffset(styles) {
      if (typeof styles == 'string') return null;
      /** @type {?} */

      var offset = null;

      if (Array.isArray(styles)) {
        styles.forEach(
        /**
        * @param {?} styleTuple
        * @return {?}
        */
        function (styleTuple) {
          if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
            /** @type {?} */
            var obj =
            /** @type {?} */
            styleTuple;
            offset = parseFloat(
            /** @type {?} */
            obj['offset']);
            delete obj['offset'];
          }
        });
      } else if (isObject(styles) && styles.hasOwnProperty('offset')) {
        /** @type {?} */
        var obj = styles;
        offset = parseFloat(
        /** @type {?} */
        obj['offset']);
        delete obj['offset'];
      }

      return offset;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isObject(value) {
      return !Array.isArray(value) && typeof value == 'object';
    }
    /**
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */


    function constructTimingAst(value, errors) {
      /** @type {?} */
      var timings = null;

      if (value.hasOwnProperty('duration')) {
        timings =
        /** @type {?} */
        value;
      } else if (typeof value == 'number') {
        /** @type {?} */
        var duration = resolveTiming(value, errors).duration;
        return makeTimingAst(duration, 0, '');
      }
      /** @type {?} */


      var strValue =
      /** @type {?} */
      value;
      /** @type {?} */

      var isDynamic = strValue.split(/\s+/).some(
      /**
      * @param {?} v
      * @return {?}
      */
      function (v) {
        return v.charAt(0) == '{' && v.charAt(1) == '{';
      });

      if (isDynamic) {
        /** @type {?} */
        var ast =
        /** @type {?} */
        makeTimingAst(0, 0, '');
        ast.dynamic = true;
        ast.strValue = strValue;
        return (
          /** @type {?} */
          ast
        );
      }

      timings = timings || resolveTiming(strValue, errors);
      return makeTimingAst(timings.duration, timings.delay, timings.easing);
    }
    /**
     * @param {?} options
     * @return {?}
     */


    function normalizeAnimationOptions(options) {
      if (options) {
        options = copyObj(options);

        if (options['params']) {
          options['params'] =
          /** @type {?} */
          normalizeParams(options['params']);
        }
      } else {
        options = {};
      }

      return options;
    }
    /**
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @return {?}
     */


    function makeTimingAst(duration, delay, easing) {
      return {
        duration: duration,
        delay: delay,
        easing: easing
      };
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_timeline_instruction.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     */


    function AnimationTimelineInstruction() {}

    if (false) {}
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} preStyleProps
     * @param {?} postStyleProps
     * @param {?} duration
     * @param {?} delay
     * @param {?=} easing
     * @param {?=} subTimeline
     * @return {?}
     */


    function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay) {
      var easing = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var subTimeline = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      return {
        type: 1
        /* TimelineAnimation */
        ,
        element: element,
        keyframes: keyframes,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        duration: duration,
        delay: delay,
        totalTime: duration + delay,
        easing: easing,
        subTimeline: subTimeline
      };
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/element_instruction_map.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var ElementInstructionMap = /*#__PURE__*/function () {
      function ElementInstructionMap() {
        _classCallCheck(this, ElementInstructionMap);

        this._map = new Map();
      }
      /**
       * @param {?} element
       * @return {?}
       */


      _createClass(ElementInstructionMap, [{
        key: "consume",
        value: function consume(element) {
          /** @type {?} */
          var instructions = this._map.get(element);

          if (instructions) {
            this._map["delete"](element);
          } else {
            instructions = [];
          }

          return instructions;
        }
        /**
         * @param {?} element
         * @param {?} instructions
         * @return {?}
         */

      }, {
        key: "append",
        value: function append(element, instructions) {
          var _existingInstructions;

          /** @type {?} */
          var existingInstructions = this._map.get(element);

          if (!existingInstructions) {
            this._map.set(element, existingInstructions = []);
          }

          (_existingInstructions = existingInstructions).push.apply(_existingInstructions, _toConsumableArray(instructions));
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "has",
        value: function has(element) {
          return this._map.has(element);
        }
        /**
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear() {
          this._map.clear();
        }
      }]);

      return ElementInstructionMap;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_timeline_builder.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ONE_FRAME_IN_MILLISECONDS = 1;
    /** @type {?} */

    var ENTER_TOKEN = ':enter';
    /** @type {?} */

    var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');
    /** @type {?} */

    var LEAVE_TOKEN = ':leave';
    /** @type {?} */

    var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
    /*
     * The code within this file aims to generate web-animations-compatible keyframes from Angular's
     * animation DSL code.
     *
     * The code below will be converted from:
     *
     * ```
     * sequence([
     *   style({ opacity: 0 }),
     *   animate(1000, style({ opacity: 0 }))
     * ])
     * ```
     *
     * To:
     * ```
     * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]
     * duration = 1000
     * delay = 0
     * easing = ''
     * ```
     *
     * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a
     * combination of prototypical inheritance, AST traversal and merge-sort-like algorithms are used.
     *
     * [AST Traversal]
     * Each of the animation verbs, when executed, will return an string-map object representing what
     * type of action it is (style, animate, group, etc...) and the data associated with it. This means
     * that when functional composition mix of these functions is evaluated (like in the example above)
     * then it will end up producing a tree of objects representing the animation itself.
     *
     * When this animation object tree is processed by the visitor code below it will visit each of the
     * verb statements within the visitor. And during each visit it will build the context of the
     * animation keyframes by interacting with the `TimelineBuilder`.
     *
     * [TimelineBuilder]
     * This class is responsible for tracking the styles and building a series of keyframe objects for a
     * timeline between a start and end time. The builder starts off with an initial timeline and each
     * time the AST comes across a `group()`, `keyframes()` or a combination of the two wihtin a
     * `sequence()` then it will generate a sub timeline for each step as well as a new one after
     * they are complete.
     *
     * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub
     * timeline was created (based on one of the cases above) then the parent timeline will attempt to
     * merge the styles used within the sub timelines into itself (only with group() this will happen).
     * This happens with a merge operation (much like how the merge works in mergesort) and it will only
     * copy the most recently used styles from the sub timelines into the parent timeline. This ensures
     * that if the styles are used later on in another phase of the animation then they will be the most
     * up-to-date values.
     *
     * [How Missing Styles Are Updated]
     * Each timeline has a `backFill` property which is responsible for filling in new styles into
     * already processed keyframes if a new style shows up later within the animation sequence.
     *
     * ```
     * sequence([
     *   style({ width: 0 }),
     *   animate(1000, style({ width: 100 })),
     *   animate(1000, style({ width: 200 })),
     *   animate(1000, style({ width: 300 }))
     *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn't exist anywhere
     * else
     * ])
     * ```
     *
     * What is happening here is that the `height` value is added later in the sequence, but is missing
     * from all previous animation steps. Therefore when a keyframe is created it would also be missing
     * from all previous keyframes up until where it is first used. For the timeline keyframe generation
     * to properly fill in the style it will place the previous value (the value from the parent
     * timeline) or a default value of `*` into the backFill object. Given that each of the keyframe
     * styles are objects that prototypically inhert from the backFill object, this means that if a
     * value is added into the backFill then it will automatically propagate any missing values to all
     * keyframes. Therefore the missing `height` value will be properly filled into the already
     * processed keyframes.
     *
     * When a sub-timeline is created it will have its own backFill property. This is done so that
     * styles present within the sub-timeline do not accidentally seep into the previous/future timeline
     * keyframes
     *
     * (For prototypically-inherited contents to be detected a `for(i in obj)` loop must be used.)
     *
     * [Validation]
     * The code in this file is not responsible for validation. That functionality happens with within
     * the `AnimationValidatorVisitor` code.
     */

    /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?=} startingStyles
     * @param {?=} finalStyles
     * @param {?=} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */

    function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName) {
      var startingStyles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      var finalStyles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
      var options = arguments.length > 7 ? arguments[7] : undefined;
      var subInstructions = arguments.length > 8 ? arguments[8] : undefined;
      var errors = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];
      return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
    }

    var AnimationTimelineBuilderVisitor = /*#__PURE__*/function () {
      function AnimationTimelineBuilderVisitor() {
        _classCallCheck(this, AnimationTimelineBuilderVisitor);
      }

      _createClass(AnimationTimelineBuilderVisitor, [{
        key: "buildKeyframes",

        /**
         * @param {?} driver
         * @param {?} rootElement
         * @param {?} ast
         * @param {?} enterClassName
         * @param {?} leaveClassName
         * @param {?} startingStyles
         * @param {?} finalStyles
         * @param {?} options
         * @param {?=} subInstructions
         * @param {?=} errors
         * @return {?}
         */
        value: function buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions) {
          var errors = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];
          subInstructions = subInstructions || new ElementInstructionMap();
          /** @type {?} */

          var context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
          context.options = options;
          context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
          visitDslNode(this, ast, context); // this checks to see if an actual animation happened

          /** @type {?} */

          var timelines = context.timelines.filter(
          /**
          * @param {?} timeline
          * @return {?}
          */
          function (timeline) {
            return timeline.containsAnimation();
          });

          if (timelines.length && Object.keys(finalStyles).length) {
            /** @type {?} */
            var tl = timelines[timelines.length - 1];

            if (!tl.allowOnlyTimelineStyles()) {
              tl.setStyles([finalStyles], null, context.errors, options);
            }
          }

          return timelines.length ? timelines.map(
          /**
          * @param {?} timeline
          * @return {?}
          */
          function (timeline) {
            return timeline.buildKeyframes();
          }) : [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitTrigger",
        value: function visitTrigger(ast, context) {// these values are not visited in this AST
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitState",
        value: function visitState(ast, context) {// these values are not visited in this AST
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitTransition",
        value: function visitTransition(ast, context) {// these values are not visited in this AST
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitAnimateChild",
        value: function visitAnimateChild(ast, context) {
          /** @type {?} */
          var elementInstructions = context.subInstructions.consume(context.element);

          if (elementInstructions) {
            /** @type {?} */
            var innerContext = context.createSubContext(ast.options);
            /** @type {?} */

            var startTime = context.currentTimeline.currentTime;
            /** @type {?} */

            var endTime = this._visitSubInstructions(elementInstructions, innerContext,
            /** @type {?} */
            innerContext.options);

            if (startTime != endTime) {
              // we do this on the upper context because we created a sub context for
              // the sub child animations
              context.transformIntoNewTimeline(endTime);
            }
          }

          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitAnimateRef",
        value: function visitAnimateRef(ast, context) {
          /** @type {?} */
          var innerContext = context.createSubContext(ast.options);
          innerContext.transformIntoNewTimeline();
          this.visitReference(ast.animation, innerContext);
          context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
          context.previousNode = ast;
        }
        /**
         * @private
         * @param {?} instructions
         * @param {?} context
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "_visitSubInstructions",
        value: function _visitSubInstructions(instructions, context, options) {
          /** @type {?} */
          var startTime = context.currentTimeline.currentTime;
          /** @type {?} */

          var furthestTime = startTime; // this is a special-case for when a user wants to skip a sub
          // animation from being fired entirely.

          /** @type {?} */

          var duration = options.duration != null ? resolveTimingValue(options.duration) : null;
          /** @type {?} */

          var delay = options.delay != null ? resolveTimingValue(options.delay) : null;

          if (duration !== 0) {
            instructions.forEach(
            /**
            * @param {?} instruction
            * @return {?}
            */
            function (instruction) {
              /** @type {?} */
              var instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
              furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
            });
          }

          return furthestTime;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitReference",
        value: function visitReference(ast, context) {
          context.updateOptions(ast.options, true);
          visitDslNode(this, ast.animation, context);
          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitSequence",
        value: function visitSequence(ast, context) {
          var _this11 = this;

          /** @type {?} */
          var subContextCount = context.subContextCount;
          /** @type {?} */

          var ctx = context;
          /** @type {?} */

          var options = ast.options;

          if (options && (options.params || options.delay)) {
            ctx = context.createSubContext(options);
            ctx.transformIntoNewTimeline();

            if (options.delay != null) {
              if (ctx.previousNode.type == 6
              /* Style */
              ) {
                  ctx.currentTimeline.snapshotCurrentStyles();
                  ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
                }
              /** @type {?} */


              var delay = resolveTimingValue(options.delay);
              ctx.delayNextStep(delay);
            }
          }

          if (ast.steps.length) {
            ast.steps.forEach(
            /**
            * @param {?} s
            * @return {?}
            */
            function (s) {
              return visitDslNode(_this11, s, ctx);
            }); // this is here just incase the inner steps only contain or end with a style() call

            ctx.currentTimeline.applyStylesToKeyframe(); // this means that some animation function within the sequence
            // ended up creating a sub timeline (which means the current
            // timeline cannot overlap with the contents of the sequence)

            if (ctx.subContextCount > subContextCount) {
              ctx.transformIntoNewTimeline();
            }
          }

          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitGroup",
        value: function visitGroup(ast, context) {
          var _this12 = this;

          /** @type {?} */
          var innerTimelines = [];
          /** @type {?} */

          var furthestTime = context.currentTimeline.currentTime;
          /** @type {?} */

          var delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
          ast.steps.forEach(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            /** @type {?} */
            var innerContext = context.createSubContext(ast.options);

            if (delay) {
              innerContext.delayNextStep(delay);
            }

            visitDslNode(_this12, s, innerContext);
            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
            innerTimelines.push(innerContext.currentTimeline);
          }); // this operation is run after the AST loop because otherwise
          // if the parent timeline's collected styles were updated then
          // it would pass in invalid data into the new-to-be forked items

          innerTimelines.forEach(
          /**
          * @param {?} timeline
          * @return {?}
          */
          function (timeline) {
            return context.currentTimeline.mergeTimelineCollectedStyles(timeline);
          });
          context.transformIntoNewTimeline(furthestTime);
          context.previousNode = ast;
        }
        /**
         * @private
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "_visitTiming",
        value: function _visitTiming(ast, context) {
          if (
          /** @type {?} */
          ast.dynamic) {
            /** @type {?} */
            var strValue =
            /** @type {?} */
            ast.strValue;
            /** @type {?} */

            var timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
            return resolveTiming(timingValue, context.errors);
          } else {
            return {
              duration: ast.duration,
              delay: ast.delay,
              easing: ast.easing
            };
          }
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitAnimate",
        value: function visitAnimate(ast, context) {
          /** @type {?} */
          var timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
          /** @type {?} */


          var timeline = context.currentTimeline;

          if (timings.delay) {
            context.incrementTime(timings.delay);
            timeline.snapshotCurrentStyles();
          }
          /** @type {?} */


          var style = ast.style;

          if (style.type == 5
          /* Keyframes */
          ) {
              this.visitKeyframes(style, context);
            } else {
            context.incrementTime(timings.duration);
            this.visitStyle(
            /** @type {?} */
            style, context);
            timeline.applyStylesToKeyframe();
          }

          context.currentAnimateTimings = null;
          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitStyle",
        value: function visitStyle(ast, context) {
          /** @type {?} */
          var timeline = context.currentTimeline;
          /** @type {?} */

          var timings =
          /** @type {?} */
          context.currentAnimateTimings; // this is a special case for when a style() call
          // directly follows  an animate() call (but not inside of an animate() call)

          if (!timings && timeline.getCurrentStyleProperties().length) {
            timeline.forwardFrame();
          }
          /** @type {?} */


          var easing = timings && timings.easing || ast.easing;

          if (ast.isEmptyStep) {
            timeline.applyEmptyStep(easing);
          } else {
            timeline.setStyles(ast.styles, easing, context.errors, context.options);
          }

          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitKeyframes",
        value: function visitKeyframes(ast, context) {
          /** @type {?} */
          var currentAnimateTimings =
          /** @type {?} */
          context.currentAnimateTimings;
          /** @type {?} */

          var startTime =
          /** @type {?} */
          context.currentTimeline.duration;
          /** @type {?} */

          var duration = currentAnimateTimings.duration;
          /** @type {?} */

          var innerContext = context.createSubContext();
          /** @type {?} */

          var innerTimeline = innerContext.currentTimeline;
          innerTimeline.easing = currentAnimateTimings.easing;
          ast.styles.forEach(
          /**
          * @param {?} step
          * @return {?}
          */
          function (step) {
            /** @type {?} */
            var offset = step.offset || 0;
            innerTimeline.forwardTime(offset * duration);
            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
            innerTimeline.applyStylesToKeyframe();
          }); // this will ensure that the parent timeline gets all the styles from
          // the child even if the new timeline below is not used

          context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline); // we do this because the window between this timeline and the sub timeline
          // should ensure that the styles within are exactly the same as they were before

          context.transformIntoNewTimeline(startTime + duration);
          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitQuery",
        value: function visitQuery(ast, context) {
          var _this13 = this;

          // in the event that the first step before this is a style step we need
          // to ensure the styles are applied before the children are animated

          /** @type {?} */
          var startTime = context.currentTimeline.currentTime;
          /** @type {?} */

          var options =
          /** @type {?} */
          ast.options || {};
          /** @type {?} */

          var delay = options.delay ? resolveTimingValue(options.delay) : 0;

          if (delay && (context.previousNode.type === 6
          /* Style */
          || startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length)) {
            context.currentTimeline.snapshotCurrentStyles();
            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
          }
          /** @type {?} */


          var furthestTime = startTime;
          /** @type {?} */

          var elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
          context.currentQueryTotal = elms.length;
          /** @type {?} */

          var sameElementTimeline = null;
          elms.forEach(
          /**
          * @param {?} element
          * @param {?} i
          * @return {?}
          */
          function (element, i) {
            context.currentQueryIndex = i;
            /** @type {?} */

            var innerContext = context.createSubContext(ast.options, element);

            if (delay) {
              innerContext.delayNextStep(delay);
            }

            if (element === context.element) {
              sameElementTimeline = innerContext.currentTimeline;
            }

            visitDslNode(_this13, ast.animation, innerContext); // this is here just incase the inner steps only contain or end
            // with a style() call (which is here to signal that this is a preparatory
            // call to style an element before it is animated again)

            innerContext.currentTimeline.applyStylesToKeyframe();
            /** @type {?} */

            var endTime = innerContext.currentTimeline.currentTime;
            furthestTime = Math.max(furthestTime, endTime);
          });
          context.currentQueryIndex = 0;
          context.currentQueryTotal = 0;
          context.transformIntoNewTimeline(furthestTime);

          if (sameElementTimeline) {
            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
            context.currentTimeline.snapshotCurrentStyles();
          }

          context.previousNode = ast;
        }
        /**
         * @param {?} ast
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "visitStagger",
        value: function visitStagger(ast, context) {
          /** @type {?} */
          var parentContext =
          /** @type {?} */
          context.parentContext;
          /** @type {?} */

          var tl = context.currentTimeline;
          /** @type {?} */

          var timings = ast.timings;
          /** @type {?} */

          var duration = Math.abs(timings.duration);
          /** @type {?} */

          var maxTime = duration * (context.currentQueryTotal - 1);
          /** @type {?} */

          var delay = duration * context.currentQueryIndex;
          /** @type {?} */

          var staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;

          switch (staggerTransformer) {
            case 'reverse':
              delay = maxTime - delay;
              break;

            case 'full':
              delay = parentContext.currentStaggerTime;
              break;
          }
          /** @type {?} */


          var timeline = context.currentTimeline;

          if (delay) {
            timeline.delayNextStep(delay);
          }
          /** @type {?} */


          var startingTime = timeline.currentTime;
          visitDslNode(this, ast.animation, context);
          context.previousNode = ast; // time = duration + delay
          // the reason why this computation is so complex is because
          // the inner timeline may either have a delay value or a stretched
          // keyframe depending on if a subtimeline is not used or is used.

          parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
        }
      }]);

      return AnimationTimelineBuilderVisitor;
    }();
    /** @type {?} */


    var DEFAULT_NOOP_PREVIOUS_NODE =
    /** @type {?} */
    {};

    var AnimationTimelineContext = /*#__PURE__*/function () {
      /**
       * @param {?} _driver
       * @param {?} element
       * @param {?} subInstructions
       * @param {?} _enterClassName
       * @param {?} _leaveClassName
       * @param {?} errors
       * @param {?} timelines
       * @param {?=} initialTimeline
       */
      function AnimationTimelineContext(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
        _classCallCheck(this, AnimationTimelineContext);

        this._driver = _driver;
        this.element = element;
        this.subInstructions = subInstructions;
        this._enterClassName = _enterClassName;
        this._leaveClassName = _leaveClassName;
        this.errors = errors;
        this.timelines = timelines;
        this.parentContext = null;
        this.currentAnimateTimings = null;
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.subContextCount = 0;
        this.options = {};
        this.currentQueryIndex = 0;
        this.currentQueryTotal = 0;
        this.currentStaggerTime = 0;
        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
        timelines.push(this.currentTimeline);
      }
      /**
       * @return {?}
       */


      _createClass(AnimationTimelineContext, [{
        key: "updateOptions",

        /**
         * @param {?} options
         * @param {?=} skipIfExists
         * @return {?}
         */
        value: function updateOptions(options, skipIfExists) {
          var _this14 = this;

          if (!options) return;
          /** @type {?} */

          var newOptions =
          /** @type {?} */
          options;
          /** @type {?} */

          var optionsToUpdate = this.options; // NOTE: this will get patched up when other animation methods support duration overrides

          if (newOptions.duration != null) {
            /** @type {?} */
            optionsToUpdate.duration = resolveTimingValue(newOptions.duration);
          }

          if (newOptions.delay != null) {
            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
          }
          /** @type {?} */


          var newParams = newOptions.params;

          if (newParams) {
            /** @type {?} */
            var paramsToUpdate =
            /** @type {?} */
            optionsToUpdate.params;

            if (!paramsToUpdate) {
              paramsToUpdate = this.options.params = {};
            }

            Object.keys(newParams).forEach(
            /**
            * @param {?} name
            * @return {?}
            */
            function (name) {
              if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {
                paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, _this14.errors);
              }
            });
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_copyOptions",
        value: function _copyOptions() {
          /** @type {?} */
          var options = {};

          if (this.options) {
            /** @type {?} */
            var oldParams = this.options.params;

            if (oldParams) {
              /** @type {?} */
              var params = options['params'] = {};
              Object.keys(oldParams).forEach(
              /**
              * @param {?} name
              * @return {?}
              */
              function (name) {
                params[name] = oldParams[name];
              });
            }
          }

          return options;
        }
        /**
         * @param {?=} options
         * @param {?=} element
         * @param {?=} newTime
         * @return {?}
         */

      }, {
        key: "createSubContext",
        value: function createSubContext() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var element = arguments.length > 1 ? arguments[1] : undefined;
          var newTime = arguments.length > 2 ? arguments[2] : undefined;

          /** @type {?} */
          var target = element || this.element;
          /** @type {?} */

          var context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
          context.previousNode = this.previousNode;
          context.currentAnimateTimings = this.currentAnimateTimings;
          context.options = this._copyOptions();
          context.updateOptions(options);
          context.currentQueryIndex = this.currentQueryIndex;
          context.currentQueryTotal = this.currentQueryTotal;
          context.parentContext = this;
          this.subContextCount++;
          return context;
        }
        /**
         * @param {?=} newTime
         * @return {?}
         */

      }, {
        key: "transformIntoNewTimeline",
        value: function transformIntoNewTimeline(newTime) {
          this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
          this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
          this.timelines.push(this.currentTimeline);
          return this.currentTimeline;
        }
        /**
         * @param {?} instruction
         * @param {?} duration
         * @param {?} delay
         * @return {?}
         */

      }, {
        key: "appendInstructionToTimeline",
        value: function appendInstructionToTimeline(instruction, duration, delay) {
          /** @type {?} */
          var updatedTimings = {
            duration: duration != null ? duration : instruction.duration,
            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
            easing: ''
          };
          /** @type {?} */

          var builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
          this.timelines.push(builder);
          return updatedTimings;
        }
        /**
         * @param {?} time
         * @return {?}
         */

      }, {
        key: "incrementTime",
        value: function incrementTime(time) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
        }
        /**
         * @param {?} delay
         * @return {?}
         */

      }, {
        key: "delayNextStep",
        value: function delayNextStep(delay) {
          // negative delays are not yet supported
          if (delay > 0) {
            this.currentTimeline.delayNextStep(delay);
          }
        }
        /**
         * @param {?} selector
         * @param {?} originalSelector
         * @param {?} limit
         * @param {?} includeSelf
         * @param {?} optional
         * @param {?} errors
         * @return {?}
         */

      }, {
        key: "invokeQuery",
        value: function invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {
          /** @type {?} */
          var results = [];

          if (includeSelf) {
            results.push(this.element);
          }

          if (selector.length > 0) {
            // if :self is only used then the selector is empty
            selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);
            selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);
            /** @type {?} */

            var multi = limit != 1;
            /** @type {?} */

            var elements = this._driver.query(this.element, selector, multi);

            if (limit !== 0) {
              elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);
            }

            results.push.apply(results, _toConsumableArray(elements));
          }

          if (!optional && results.length == 0) {
            errors.push("`query(\"".concat(originalSelector, "\")` returned zero elements. (Use `query(\"").concat(originalSelector, "\", { optional: true })` if you wish to allow this.)"));
          }

          return results;
        }
      }, {
        key: "params",
        get: function get() {
          return this.options.params;
        }
      }]);

      return AnimationTimelineContext;
    }();

    if (false) {}

    var TimelineBuilder = /*#__PURE__*/function () {
      /**
       * @param {?} _driver
       * @param {?} element
       * @param {?} startTime
       * @param {?=} _elementTimelineStylesLookup
       */
      function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {
        _classCallCheck(this, TimelineBuilder);

        this._driver = _driver;
        this.element = element;
        this.startTime = startTime;
        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
        this.duration = 0;
        this._previousKeyframe = {};
        this._currentKeyframe = {};
        this._keyframes = new Map();
        this._styleSummary = {};
        this._pendingStyles = {};
        this._backFill = {};
        this._currentEmptyStepKeyframe = null;

        if (!this._elementTimelineStylesLookup) {
          this._elementTimelineStylesLookup = new Map();
        }

        this._localTimelineStyles = Object.create(this._backFill, {});
        this._globalTimelineStyles =
        /** @type {?} */
        this._elementTimelineStylesLookup.get(element);

        if (!this._globalTimelineStyles) {
          this._globalTimelineStyles = this._localTimelineStyles;

          this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
        }

        this._loadKeyframe();
      }
      /**
       * @return {?}
       */


      _createClass(TimelineBuilder, [{
        key: "containsAnimation",
        value: function containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return false;

            case 1:
              return this.getCurrentStyleProperties().length > 0;

            default:
              return true;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "getCurrentStyleProperties",
        value: function getCurrentStyleProperties() {
          return Object.keys(this._currentKeyframe);
        }
        /**
         * @return {?}
         */

      }, {
        key: "delayNextStep",

        /**
         * @param {?} delay
         * @return {?}
         */
        value: function delayNextStep(delay) {
          // in the event that a style() step is placed right before a stagger()
          // and that style() step is the very first style() value in the animation
          // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
          // properly applies the style() values to work with the stagger...

          /** @type {?} */
          var hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;

          if (this.duration || hasPreStyleStep) {
            this.forwardTime(this.currentTime + delay);

            if (hasPreStyleStep) {
              this.snapshotCurrentStyles();
            }
          } else {
            this.startTime += delay;
          }
        }
        /**
         * @param {?} element
         * @param {?=} currentTime
         * @return {?}
         */

      }, {
        key: "fork",
        value: function fork(element, currentTime) {
          this.applyStylesToKeyframe();
          return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_loadKeyframe",
        value: function _loadKeyframe() {
          if (this._currentKeyframe) {
            this._previousKeyframe = this._currentKeyframe;
          }

          this._currentKeyframe =
          /** @type {?} */
          this._keyframes.get(this.duration);

          if (!this._currentKeyframe) {
            this._currentKeyframe = Object.create(this._backFill, {});

            this._keyframes.set(this.duration, this._currentKeyframe);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "forwardFrame",
        value: function forwardFrame() {
          this.duration += ONE_FRAME_IN_MILLISECONDS;

          this._loadKeyframe();
        }
        /**
         * @param {?} time
         * @return {?}
         */

      }, {
        key: "forwardTime",
        value: function forwardTime(time) {
          this.applyStylesToKeyframe();
          this.duration = time;

          this._loadKeyframe();
        }
        /**
         * @private
         * @param {?} prop
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_updateStyle",
        value: function _updateStyle(prop, value) {
          this._localTimelineStyles[prop] = value;
          this._globalTimelineStyles[prop] = value;
          this._styleSummary[prop] = {
            time: this.currentTime,
            value: value
          };
        }
        /**
         * @return {?}
         */

      }, {
        key: "allowOnlyTimelineStyles",
        value: function allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe;
        }
        /**
         * @param {?} easing
         * @return {?}
         */

      }, {
        key: "applyEmptyStep",
        value: function applyEmptyStep(easing) {
          var _this15 = this;

          if (easing) {
            this._previousKeyframe['easing'] = easing;
          } // special case for animate(duration):
          // all missing styles are filled with a `*` value then
          // if any destination styles are filled in later on the same
          // keyframe then they will override the overridden styles
          // We use `_globalTimelineStyles` here because there may be
          // styles in previous keyframes that are not present in this timeline


          Object.keys(this._globalTimelineStyles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            _this15._backFill[prop] = _this15._globalTimelineStyles[prop] || _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"];
            _this15._currentKeyframe[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"];
          });
          this._currentEmptyStepKeyframe = this._currentKeyframe;
        }
        /**
         * @param {?} input
         * @param {?} easing
         * @param {?} errors
         * @param {?=} options
         * @return {?}
         */

      }, {
        key: "setStyles",
        value: function setStyles(input, easing, errors, options) {
          var _this16 = this;

          if (easing) {
            this._previousKeyframe['easing'] = easing;
          }
          /** @type {?} */


          var params = options && options.params || {};
          /** @type {?} */

          var styles = flattenStyles(input, this._globalTimelineStyles);
          Object.keys(styles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            /** @type {?} */
            var val = interpolateParams(styles[prop], params, errors);
            _this16._pendingStyles[prop] = val;

            if (!_this16._localTimelineStyles.hasOwnProperty(prop)) {
              _this16._backFill[prop] = _this16._globalTimelineStyles.hasOwnProperty(prop) ? _this16._globalTimelineStyles[prop] : _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"];
            }

            _this16._updateStyle(prop, val);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "applyStylesToKeyframe",
        value: function applyStylesToKeyframe() {
          var _this17 = this;

          /** @type {?} */
          var styles = this._pendingStyles;
          /** @type {?} */

          var props = Object.keys(styles);
          if (props.length == 0) return;
          this._pendingStyles = {};
          props.forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            /** @type {?} */
            var val = styles[prop];
            _this17._currentKeyframe[prop] = val;
          });
          Object.keys(this._localTimelineStyles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            if (!_this17._currentKeyframe.hasOwnProperty(prop)) {
              _this17._currentKeyframe[prop] = _this17._localTimelineStyles[prop];
            }
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "snapshotCurrentStyles",
        value: function snapshotCurrentStyles() {
          var _this18 = this;

          Object.keys(this._localTimelineStyles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            /** @type {?} */
            var val = _this18._localTimelineStyles[prop];
            _this18._pendingStyles[prop] = val;

            _this18._updateStyle(prop, val);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "getFinalKeyframe",
        value: function getFinalKeyframe() {
          return this._keyframes.get(this.duration);
        }
        /**
         * @return {?}
         */

      }, {
        key: "mergeTimelineCollectedStyles",

        /**
         * @param {?} timeline
         * @return {?}
         */
        value: function mergeTimelineCollectedStyles(timeline) {
          var _this19 = this;

          Object.keys(timeline._styleSummary).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            /** @type {?} */
            var details0 = _this19._styleSummary[prop];
            /** @type {?} */

            var details1 = timeline._styleSummary[prop];

            if (!details0 || details1.time > details0.time) {
              _this19._updateStyle(prop, details1.value);
            }
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "buildKeyframes",
        value: function buildKeyframes() {
          var _this20 = this;

          this.applyStylesToKeyframe();
          /** @type {?} */

          var preStyleProps = new Set();
          /** @type {?} */

          var postStyleProps = new Set();
          /** @type {?} */

          var isEmpty = this._keyframes.size === 1 && this.duration === 0;
          /** @type {?} */

          var finalKeyframes = [];

          this._keyframes.forEach(
          /**
          * @param {?} keyframe
          * @param {?} time
          * @return {?}
          */
          function (keyframe, time) {
            /** @type {?} */
            var finalKeyframe = copyStyles(keyframe, true);
            Object.keys(finalKeyframe).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              /** @type {?} */
              var value = finalKeyframe[prop];

              if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_0__["ɵPRE_STYLE"]) {
                preStyleProps.add(prop);
              } else if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"]) {
                postStyleProps.add(prop);
              }
            });

            if (!isEmpty) {
              finalKeyframe['offset'] = time / _this20.duration;
            }

            finalKeyframes.push(finalKeyframe);
          });
          /** @type {?} */


          var preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
          /** @type {?} */

          var postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : []; // special case for a 0-second animation (which is designed just to place styles onscreen)

          if (isEmpty) {
            /** @type {?} */
            var kf0 = finalKeyframes[0];
            /** @type {?} */

            var kf1 = copyObj(kf0);
            kf0['offset'] = 0;
            kf1['offset'] = 1;
            finalKeyframes = [kf0, kf1];
          }

          return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
        }
      }, {
        key: "currentTime",
        get: function get() {
          return this.startTime + this.duration;
        }
      }, {
        key: "properties",
        get: function get() {
          /** @type {?} */
          var properties = [];

          for (var prop in this._currentKeyframe) {
            properties.push(prop);
          }

          return properties;
        }
      }]);

      return TimelineBuilder;
    }();

    if (false) {}

    var SubTimelineBuilder = /*#__PURE__*/function (_TimelineBuilder) {
      _inherits(SubTimelineBuilder, _TimelineBuilder);

      var _super = _createSuper(SubTimelineBuilder);

      /**
       * @param {?} driver
       * @param {?} element
       * @param {?} keyframes
       * @param {?} preStyleProps
       * @param {?} postStyleProps
       * @param {?} timings
       * @param {?=} _stretchStartingKeyframe
       */
      function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings) {
        var _this21;

        var _stretchStartingKeyframe = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

        _classCallCheck(this, SubTimelineBuilder);

        _this21 = _super.call(this, driver, element, timings.delay);
        _this21.element = element;
        _this21.keyframes = keyframes;
        _this21.preStyleProps = preStyleProps;
        _this21.postStyleProps = postStyleProps;
        _this21._stretchStartingKeyframe = _stretchStartingKeyframe;
        _this21.timings = {
          duration: timings.duration,
          delay: timings.delay,
          easing: timings.easing
        };
        return _this21;
      }
      /**
       * @return {?}
       */


      _createClass(SubTimelineBuilder, [{
        key: "containsAnimation",
        value: function containsAnimation() {
          return this.keyframes.length > 1;
        }
        /**
         * @return {?}
         */

      }, {
        key: "buildKeyframes",
        value: function buildKeyframes() {
          /** @type {?} */
          var keyframes = this.keyframes;
          var _this$timings = this.timings,
              delay = _this$timings.delay,
              duration = _this$timings.duration,
              easing = _this$timings.easing;

          if (this._stretchStartingKeyframe && delay) {
            /** @type {?} */
            var newKeyframes = [];
            /** @type {?} */

            var totalTime = duration + delay;
            /** @type {?} */

            var startingGap = delay / totalTime; // the original starting keyframe now starts once the delay is done

            /** @type {?} */

            var newFirstKeyframe = copyStyles(keyframes[0], false);
            newFirstKeyframe['offset'] = 0;
            newKeyframes.push(newFirstKeyframe);
            /** @type {?} */

            var oldFirstKeyframe = copyStyles(keyframes[0], false);
            oldFirstKeyframe['offset'] = roundOffset(startingGap);
            newKeyframes.push(oldFirstKeyframe);
            /*
                    When the keyframe is stretched then it means that the delay before the animation
                    starts is gone. Instead the first keyframe is placed at the start of the animation
                    and it is then copied to where it starts when the original delay is over. This basically
                    means nothing animates during that delay, but the styles are still renderered. For this
                    to work the original offset values that exist in the original keyframes must be "warped"
                    so that they can take the new keyframe + delay into account.
            
                    delay=1000, duration=1000, keyframes = 0 .5 1
            
                    turns into
            
                    delay=0, duration=2000, keyframes = 0 .33 .66 1
                   */
            // offsets between 1 ... n -1 are all warped by the keyframe stretch

            /** @type {?} */

            var limit = keyframes.length - 1;

            for (var i = 1; i <= limit; i++) {
              /** @type {?} */
              var kf = copyStyles(keyframes[i], false);
              /** @type {?} */

              var oldOffset =
              /** @type {?} */
              kf['offset'];
              /** @type {?} */

              var timeAtKeyframe = delay + oldOffset * duration;
              kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
              newKeyframes.push(kf);
            } // the new starting keyframe should be added at the start


            duration = totalTime;
            delay = 0;
            easing = '';
            keyframes = newKeyframes;
          }

          return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
        }
      }]);

      return SubTimelineBuilder;
    }(TimelineBuilder);

    if (false) {}
    /**
     * @param {?} offset
     * @param {?=} decimalPoints
     * @return {?}
     */


    function roundOffset(offset) {
      var decimalPoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;

      /** @type {?} */
      var mult = Math.pow(10, decimalPoints - 1);
      return Math.round(offset * mult) / mult;
    }
    /**
     * @param {?} input
     * @param {?} allStyles
     * @return {?}
     */


    function flattenStyles(input, allStyles) {
      /** @type {?} */
      var styles = {};
      /** @type {?} */

      var allProperties;
      input.forEach(
      /**
      * @param {?} token
      * @return {?}
      */
      function (token) {
        if (token === '*') {
          allProperties = allProperties || Object.keys(allStyles);
          allProperties.forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            styles[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"];
          });
        } else {
          copyStyles(
          /** @type {?} */
          token, false, styles);
        }
      });
      return styles;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var Animation = /*#__PURE__*/function () {
      /**
       * @param {?} _driver
       * @param {?} input
       */
      function Animation(_driver, input) {
        _classCallCheck(this, Animation);

        this._driver = _driver;
        /** @type {?} */

        var errors = [];
        /** @type {?} */

        var ast = buildAnimationAst(_driver, input, errors);

        if (errors.length) {
          /** @type {?} */
          var errorMessage = "animation validation failed:\n".concat(errors.join('\n'));
          throw new Error(errorMessage);
        }

        this._animationAst = ast;
      }
      /**
       * @param {?} element
       * @param {?} startingStyles
       * @param {?} destinationStyles
       * @param {?} options
       * @param {?=} subInstructions
       * @return {?}
       */


      _createClass(Animation, [{
        key: "buildTimelines",
        value: function buildTimelines(element, startingStyles, destinationStyles, options, subInstructions) {
          /** @type {?} */
          var start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) :
          /** @type {?} */
          startingStyles;
          /** @type {?} */

          var dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) :
          /** @type {?} */
          destinationStyles;
          /** @type {?} */

          var errors = [];
          subInstructions = subInstructions || new ElementInstructionMap();
          /** @type {?} */

          var result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);

          if (errors.length) {
            /** @type {?} */
            var errorMessage = "animation building failed:\n".concat(errors.join('\n'));
            throw new Error(errorMessage);
          }

          return result;
        }
      }]);

      return Animation;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/style_normalization/animation_style_normalizer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * \@publicApi
     * @abstract
     */


    var AnimationStyleNormalizer = function AnimationStyleNormalizer() {
      _classCallCheck(this, AnimationStyleNormalizer);
    };

    if (false) {}
    /**
     * \@publicApi
     */


    var NoopAnimationStyleNormalizer = /*#__PURE__*/function () {
      function NoopAnimationStyleNormalizer() {
        _classCallCheck(this, NoopAnimationStyleNormalizer);
      }

      _createClass(NoopAnimationStyleNormalizer, [{
        key: "normalizePropertyName",

        /**
         * @param {?} propertyName
         * @param {?} errors
         * @return {?}
         */
        value: function normalizePropertyName(propertyName, errors) {
          return propertyName;
        }
        /**
         * @param {?} userProvidedProperty
         * @param {?} normalizedProperty
         * @param {?} value
         * @param {?} errors
         * @return {?}
         */

      }, {
        key: "normalizeStyleValue",
        value: function normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
          return (
            /** @type {?} */
            value
          );
        }
      }]);

      return NoopAnimationStyleNormalizer;
    }();
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/style_normalization/web_animations_style_normalizer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var WebAnimationsStyleNormalizer = /*#__PURE__*/function (_AnimationStyleNormal) {
      _inherits(WebAnimationsStyleNormalizer, _AnimationStyleNormal);

      var _super2 = _createSuper(WebAnimationsStyleNormalizer);

      function WebAnimationsStyleNormalizer() {
        _classCallCheck(this, WebAnimationsStyleNormalizer);

        return _super2.apply(this, arguments);
      }

      _createClass(WebAnimationsStyleNormalizer, [{
        key: "normalizePropertyName",

        /**
         * @param {?} propertyName
         * @param {?} errors
         * @return {?}
         */
        value: function normalizePropertyName(propertyName, errors) {
          return dashCaseToCamelCase(propertyName);
        }
        /**
         * @param {?} userProvidedProperty
         * @param {?} normalizedProperty
         * @param {?} value
         * @param {?} errors
         * @return {?}
         */

      }, {
        key: "normalizeStyleValue",
        value: function normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
          /** @type {?} */
          var unit = '';
          /** @type {?} */

          var strVal = value.toString().trim();

          if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
            if (typeof value === 'number') {
              unit = 'px';
            } else {
              /** @type {?} */
              var valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);

              if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                errors.push("Please provide a CSS unit value for ".concat(userProvidedProperty, ":").concat(value));
              }
            }
          }

          return strVal + unit;
        }
      }]);

      return WebAnimationsStyleNormalizer;
    }(AnimationStyleNormalizer);

    var ɵ0$1 =
    /**
    * @return {?}
    */
    function ɵ0$1() {
      return makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'.split(','));
    };
    /** @type {?} */


    var DIMENSIONAL_PROP_MAP = ɵ0$1();
    /**
     * @param {?} keys
     * @return {?}
     */

    function makeBooleanMap(keys) {
      /** @type {?} */
      var map = {};
      keys.forEach(
      /**
      * @param {?} key
      * @return {?}
      */
      function (key) {
        return map[key] = true;
      });
      return map;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_transition_instruction.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     */


    function AnimationTransitionInstruction() {}

    if (false) {}
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} fromState
     * @param {?} toState
     * @param {?} isRemovalTransition
     * @param {?} fromStyles
     * @param {?} toStyles
     * @param {?} timelines
     * @param {?} queriedElements
     * @param {?} preStyleProps
     * @param {?} postStyleProps
     * @param {?} totalTime
     * @param {?=} errors
     * @return {?}
     */


    function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
      return {
        type: 0
        /* TransitionAnimation */
        ,
        element: element,
        triggerName: triggerName,
        isRemovalTransition: isRemovalTransition,
        fromState: fromState,
        fromStyles: fromStyles,
        toState: toState,
        toStyles: toStyles,
        timelines: timelines,
        queriedElements: queriedElements,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        totalTime: totalTime,
        errors: errors
      };
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_transition_factory.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var EMPTY_OBJECT = {};

    var AnimationTransitionFactory = /*#__PURE__*/function () {
      /**
       * @param {?} _triggerName
       * @param {?} ast
       * @param {?} _stateStyles
       */
      function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
        _classCallCheck(this, AnimationTransitionFactory);

        this._triggerName = _triggerName;
        this.ast = ast;
        this._stateStyles = _stateStyles;
      }
      /**
       * @param {?} currentState
       * @param {?} nextState
       * @param {?} element
       * @param {?} params
       * @return {?}
       */


      _createClass(AnimationTransitionFactory, [{
        key: "match",
        value: function match(currentState, nextState, element, params) {
          return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);
        }
        /**
         * @param {?} stateName
         * @param {?} params
         * @param {?} errors
         * @return {?}
         */

      }, {
        key: "buildStyles",
        value: function buildStyles(stateName, params, errors) {
          /** @type {?} */
          var backupStateStyler = this._stateStyles['*'];
          /** @type {?} */

          var stateStyler = this._stateStyles[stateName];
          /** @type {?} */

          var backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
          return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
        }
        /**
         * @param {?} driver
         * @param {?} element
         * @param {?} currentState
         * @param {?} nextState
         * @param {?} enterClassName
         * @param {?} leaveClassName
         * @param {?=} currentOptions
         * @param {?=} nextOptions
         * @param {?=} subInstructions
         * @param {?=} skipAstBuild
         * @return {?}
         */

      }, {
        key: "build",
        value: function build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
          /** @type {?} */
          var errors = [];
          /** @type {?} */

          var transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
          /** @type {?} */

          var currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
          /** @type {?} */

          var currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
          /** @type {?} */

          var nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
          /** @type {?} */

          var nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
          /** @type {?} */

          var queriedElements = new Set();
          /** @type {?} */

          var preStyleMap = new Map();
          /** @type {?} */

          var postStyleMap = new Map();
          /** @type {?} */

          var isRemoval = nextState === 'void';
          /** @type {?} */

          var animationOptions = {
            params: Object.assign(Object.assign({}, transitionAnimationParams), nextAnimationParams)
          };
          /** @type {?} */

          var timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
          /** @type {?} */

          var totalTime = 0;
          timelines.forEach(
          /**
          * @param {?} tl
          * @return {?}
          */
          function (tl) {
            totalTime = Math.max(tl.duration + tl.delay, totalTime);
          });

          if (errors.length) {
            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
          }

          timelines.forEach(
          /**
          * @param {?} tl
          * @return {?}
          */
          function (tl) {
            /** @type {?} */
            var elm = tl.element;
            /** @type {?} */

            var preProps = getOrSetAsInMap(preStyleMap, elm, {});
            tl.preStyleProps.forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              return preProps[prop] = true;
            });
            /** @type {?} */

            var postProps = getOrSetAsInMap(postStyleMap, elm, {});
            tl.postStyleProps.forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              return postProps[prop] = true;
            });

            if (elm !== element) {
              queriedElements.add(elm);
            }
          });
          /** @type {?} */

          var queriedElementsList = iteratorToArray(queriedElements.values());
          return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);
        }
      }]);

      return AnimationTransitionFactory;
    }();

    if (false) {}
    /**
     * @param {?} matchFns
     * @param {?} currentState
     * @param {?} nextState
     * @param {?} element
     * @param {?} params
     * @return {?}
     */


    function oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {
      return matchFns.some(
      /**
      * @param {?} fn
      * @return {?}
      */
      function (fn) {
        return fn(currentState, nextState, element, params);
      });
    }

    var AnimationStateStyles = /*#__PURE__*/function () {
      /**
       * @param {?} styles
       * @param {?} defaultParams
       */
      function AnimationStateStyles(styles, defaultParams) {
        _classCallCheck(this, AnimationStateStyles);

        this.styles = styles;
        this.defaultParams = defaultParams;
      }
      /**
       * @param {?} params
       * @param {?} errors
       * @return {?}
       */


      _createClass(AnimationStateStyles, [{
        key: "buildStyles",
        value: function buildStyles(params, errors) {
          /** @type {?} */
          var finalStyles = {};
          /** @type {?} */

          var combinedParams = copyObj(this.defaultParams);
          Object.keys(params).forEach(
          /**
          * @param {?} key
          * @return {?}
          */
          function (key) {
            /** @type {?} */
            var value = params[key];

            if (value != null) {
              combinedParams[key] = value;
            }
          });
          this.styles.styles.forEach(
          /**
          * @param {?} value
          * @return {?}
          */
          function (value) {
            if (typeof value !== 'string') {
              /** @type {?} */
              var styleObj =
              /** @type {?} */
              value;
              Object.keys(styleObj).forEach(
              /**
              * @param {?} prop
              * @return {?}
              */
              function (prop) {
                /** @type {?} */
                var val = styleObj[prop];

                if (val.length > 1) {
                  val = interpolateParams(val, combinedParams, errors);
                }

                finalStyles[prop] = val;
              });
            }
          });
          return finalStyles;
        }
      }]);

      return AnimationStateStyles;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/dsl/animation_trigger.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@publicApi
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */


    function buildTrigger(name, ast) {
      return new AnimationTrigger(name, ast);
    }
    /**
     * \@publicApi
     */


    var AnimationTrigger = /*#__PURE__*/function () {
      /**
       * @param {?} name
       * @param {?} ast
       */
      function AnimationTrigger(name, ast) {
        var _this22 = this;

        _classCallCheck(this, AnimationTrigger);

        this.name = name;
        this.ast = ast;
        this.transitionFactories = [];
        this.states = {};
        ast.states.forEach(
        /**
        * @param {?} ast
        * @return {?}
        */
        function (ast) {
          /** @type {?} */
          var defaultParams = ast.options && ast.options.params || {};
          _this22.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);
        });
        balanceProperties(this.states, 'true', '1');
        balanceProperties(this.states, 'false', '0');
        ast.transitions.forEach(
        /**
        * @param {?} ast
        * @return {?}
        */
        function (ast) {
          _this22.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this22.states));
        });
        this.fallbackTransition = createFallbackTransition(name, this.states);
      }
      /**
       * @return {?}
       */


      _createClass(AnimationTrigger, [{
        key: "matchTransition",

        /**
         * @param {?} currentState
         * @param {?} nextState
         * @param {?} element
         * @param {?} params
         * @return {?}
         */
        value: function matchTransition(currentState, nextState, element, params) {
          /** @type {?} */
          var entry = this.transitionFactories.find(
          /**
          * @param {?} f
          * @return {?}
          */
          function (f) {
            return f.match(currentState, nextState, element, params);
          });
          return entry || null;
        }
        /**
         * @param {?} currentState
         * @param {?} params
         * @param {?} errors
         * @return {?}
         */

      }, {
        key: "matchStyles",
        value: function matchStyles(currentState, params, errors) {
          return this.fallbackTransition.buildStyles(currentState, params, errors);
        }
      }, {
        key: "containsQueries",
        get: function get() {
          return this.ast.queryCount > 0;
        }
      }]);

      return AnimationTrigger;
    }();

    if (false) {}
    /**
     * @param {?} triggerName
     * @param {?} states
     * @return {?}
     */


    function createFallbackTransition(triggerName, states) {
      /** @type {?} */
      var matchers = [
      /**
      * @param {?} fromState
      * @param {?} toState
      * @return {?}
      */
      function (fromState, toState) {
        return true;
      }];
      /** @type {?} */

      var animation = {
        type: 2
        /* Sequence */
        ,
        steps: [],
        options: null
      };
      /** @type {?} */

      var transition = {
        type: 1
        /* Transition */
        ,
        animation: animation,
        matchers: matchers,
        options: null,
        queryCount: 0,
        depCount: 0
      };
      return new AnimationTransitionFactory(triggerName, transition, states);
    }
    /**
     * @param {?} obj
     * @param {?} key1
     * @param {?} key2
     * @return {?}
     */


    function balanceProperties(obj, key1, key2) {
      if (obj.hasOwnProperty(key1)) {
        if (!obj.hasOwnProperty(key2)) {
          obj[key2] = obj[key1];
        }
      } else if (obj.hasOwnProperty(key2)) {
        obj[key1] = obj[key2];
      }
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/timeline_animation_engine.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();

    var TimelineAnimationEngine = /*#__PURE__*/function () {
      /**
       * @param {?} bodyNode
       * @param {?} _driver
       * @param {?} _normalizer
       */
      function TimelineAnimationEngine(bodyNode, _driver, _normalizer) {
        _classCallCheck(this, TimelineAnimationEngine);

        this.bodyNode = bodyNode;
        this._driver = _driver;
        this._normalizer = _normalizer;
        this._animations = {};
        this._playersById = {};
        this.players = [];
      }
      /**
       * @param {?} id
       * @param {?} metadata
       * @return {?}
       */


      _createClass(TimelineAnimationEngine, [{
        key: "register",
        value: function register(id, metadata) {
          /** @type {?} */
          var errors = [];
          /** @type {?} */

          var ast = buildAnimationAst(this._driver, metadata, errors);

          if (errors.length) {
            throw new Error("Unable to build the animation due to the following errors: ".concat(errors.join('\n')));
          } else {
            this._animations[id] = ast;
          }
        }
        /**
         * @private
         * @param {?} i
         * @param {?} preStyles
         * @param {?=} postStyles
         * @return {?}
         */

      }, {
        key: "_buildPlayer",
        value: function _buildPlayer(i, preStyles, postStyles) {
          /** @type {?} */
          var element = i.element;
          /** @type {?} */

          var keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
          return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);
        }
        /**
         * @param {?} id
         * @param {?} element
         * @param {?=} options
         * @return {?}
         */

      }, {
        key: "create",
        value: function create(id, element) {
          var _this23 = this;

          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          /** @type {?} */
          var errors = [];
          /** @type {?} */

          var ast = this._animations[id];
          /** @type {?} */

          var instructions;
          /** @type {?} */

          var autoStylesMap = new Map();

          if (ast) {
            instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
            instructions.forEach(
            /**
            * @param {?} inst
            * @return {?}
            */
            function (inst) {
              /** @type {?} */
              var styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
              inst.postStyleProps.forEach(
              /**
              * @param {?} prop
              * @return {?}
              */
              function (prop) {
                return styles[prop] = null;
              });
            });
          } else {
            errors.push('The requested animation doesn\'t exist or has already been destroyed');
            instructions = [];
          }

          if (errors.length) {
            throw new Error("Unable to create the animation due to the following errors: ".concat(errors.join('\n')));
          }

          autoStylesMap.forEach(
          /**
          * @param {?} styles
          * @param {?} element
          * @return {?}
          */
          function (styles, element) {
            Object.keys(styles).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              styles[prop] = _this23._driver.computeStyle(element, prop, _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"]);
            });
          });
          /** @type {?} */

          var players = instructions.map(
          /**
          * @param {?} i
          * @return {?}
          */
          function (i) {
            /** @type {?} */
            var styles = autoStylesMap.get(i.element);
            return _this23._buildPlayer(i, {}, styles);
          });
          /** @type {?} */

          var player = optimizeGroupPlayer(players);
          this._playersById[id] = player;
          player.onDestroy(
          /**
          * @return {?}
          */
          function () {
            return _this23.destroy(id);
          });
          this.players.push(player);
          return player;
        }
        /**
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy(id) {
          /** @type {?} */
          var player = this._getPlayer(id);

          player.destroy();
          delete this._playersById[id];
          /** @type {?} */

          var index = this.players.indexOf(player);

          if (index >= 0) {
            this.players.splice(index, 1);
          }
        }
        /**
         * @private
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "_getPlayer",
        value: function _getPlayer(id) {
          /** @type {?} */
          var player = this._playersById[id];

          if (!player) {
            throw new Error("Unable to find the timeline player referenced by ".concat(id));
          }

          return player;
        }
        /**
         * @param {?} id
         * @param {?} element
         * @param {?} eventName
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "listen",
        value: function listen(id, element, eventName, callback) {
          // triggerName, fromState, toState are all ignored for timeline animations

          /** @type {?} */
          var baseEvent = makeAnimationEvent(element, '', '', '');
          listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
          return (
            /**
            * @return {?}
            */
            function () {}
          );
        }
        /**
         * @param {?} id
         * @param {?} element
         * @param {?} command
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "command",
        value: function command(id, element, _command, args) {
          if (_command == 'register') {
            this.register(id,
            /** @type {?} */
            args[0]);
            return;
          }

          if (_command == 'create') {
            /** @type {?} */
            var options =
            /** @type {?} */
            args[0] || {};
            this.create(id, element, options);
            return;
          }
          /** @type {?} */


          var player = this._getPlayer(id);

          switch (_command) {
            case 'play':
              player.play();
              break;

            case 'pause':
              player.pause();
              break;

            case 'reset':
              player.reset();
              break;

            case 'restart':
              player.restart();
              break;

            case 'finish':
              player.finish();
              break;

            case 'init':
              player.init();
              break;

            case 'setPosition':
              player.setPosition(parseFloat(
              /** @type {?} */
              args[0]));
              break;

            case 'destroy':
              this.destroy(id);
              break;
          }
        }
      }]);

      return TimelineAnimationEngine;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/transition_animation_engine.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var QUEUED_CLASSNAME = 'ng-animate-queued';
    /** @type {?} */

    var QUEUED_SELECTOR = '.ng-animate-queued';
    /** @type {?} */

    var DISABLED_CLASSNAME = 'ng-animate-disabled';
    /** @type {?} */

    var DISABLED_SELECTOR = '.ng-animate-disabled';
    /** @type {?} */

    var STAR_CLASSNAME = 'ng-star-inserted';
    /** @type {?} */

    var STAR_SELECTOR = '.ng-star-inserted';
    /** @type {?} */

    var EMPTY_PLAYER_ARRAY = [];
    /** @type {?} */

    var NULL_REMOVAL_STATE = {
      namespaceId: '',
      setForRemoval: false,
      setForMove: false,
      hasAnimation: false,
      removedBeforeQueried: false
    };
    /** @type {?} */

    var NULL_REMOVED_QUERIED_STATE = {
      namespaceId: '',
      setForMove: false,
      setForRemoval: false,
      hasAnimation: false,
      removedBeforeQueried: true
    };
    /**
     * @record
     */

    function TriggerListener() {}

    if (false) {}
    /**
     * @record
     */


    function QueueInstruction() {}

    if (false) {}
    /** @type {?} */


    var REMOVAL_FLAG = '__ng_removed';
    /**
     * @record
     */

    function ElementAnimationState() {}

    if (false) {}

    var StateValue = /*#__PURE__*/function () {
      /**
       * @param {?} input
       * @param {?=} namespaceId
       */
      function StateValue(input) {
        var namespaceId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        _classCallCheck(this, StateValue);

        this.namespaceId = namespaceId;
        /** @type {?} */

        var isObj = input && input.hasOwnProperty('value');
        /** @type {?} */

        var value = isObj ? input['value'] : input;
        this.value = normalizeTriggerValue(value);

        if (isObj) {
          /** @type {?} */
          var options = copyObj(
          /** @type {?} */
          input);
          delete options['value'];
          this.options =
          /** @type {?} */
          options;
        } else {
          this.options = {};
        }

        if (!this.options.params) {
          this.options.params = {};
        }
      }
      /**
       * @return {?}
       */


      _createClass(StateValue, [{
        key: "absorbOptions",

        /**
         * @param {?} options
         * @return {?}
         */
        value: function absorbOptions(options) {
          /** @type {?} */
          var newParams = options.params;

          if (newParams) {
            /** @type {?} */
            var oldParams =
            /** @type {?} */
            this.options.params;
            Object.keys(newParams).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              if (oldParams[prop] == null) {
                oldParams[prop] = newParams[prop];
              }
            });
          }
        }
      }, {
        key: "params",
        get: function get() {
          return (
            /** @type {?} */
            this.options.params
          );
        }
      }]);

      return StateValue;
    }();

    if (false) {}
    /** @type {?} */


    var VOID_VALUE = 'void';
    /** @type {?} */

    var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);

    var AnimationTransitionNamespace = /*#__PURE__*/function () {
      /**
       * @param {?} id
       * @param {?} hostElement
       * @param {?} _engine
       */
      function AnimationTransitionNamespace(id, hostElement, _engine) {
        _classCallCheck(this, AnimationTransitionNamespace);

        this.id = id;
        this.hostElement = hostElement;
        this._engine = _engine;
        this.players = [];
        this._triggers = {};
        this._queue = [];
        this._elementListeners = new Map();
        this._hostClassName = 'ng-tns-' + id;
        addClass(hostElement, this._hostClassName);
      }
      /**
       * @param {?} element
       * @param {?} name
       * @param {?} phase
       * @param {?} callback
       * @return {?}
       */


      _createClass(AnimationTransitionNamespace, [{
        key: "listen",
        value: function listen(element, name, phase, callback) {
          var _this24 = this;

          if (!this._triggers.hasOwnProperty(name)) {
            throw new Error("Unable to listen on the animation trigger event \"".concat(phase, "\" because the animation trigger \"").concat(name, "\" doesn't exist!"));
          }

          if (phase == null || phase.length == 0) {
            throw new Error("Unable to listen on the animation trigger \"".concat(name, "\" because the provided event is undefined!"));
          }

          if (!isTriggerEventValid(phase)) {
            throw new Error("The provided animation trigger event \"".concat(phase, "\" for the animation trigger \"").concat(name, "\" is not supported!"));
          }
          /** @type {?} */


          var listeners = getOrSetAsInMap(this._elementListeners, element, []);
          /** @type {?} */

          var data = {
            name: name,
            phase: phase,
            callback: callback
          };
          listeners.push(data);
          /** @type {?} */

          var triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});

          if (!triggersWithStates.hasOwnProperty(name)) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
            triggersWithStates[name] = DEFAULT_STATE_VALUE;
          }

          return (
            /**
            * @return {?}
            */
            function () {
              // the event listener is removed AFTER the flush has occurred such
              // that leave animations callbacks can fire (otherwise if the node
              // is removed in between then the listeners would be deregistered)
              _this24._engine.afterFlush(
              /**
              * @return {?}
              */
              function () {
                /** @type {?} */
                var index = listeners.indexOf(data);

                if (index >= 0) {
                  listeners.splice(index, 1);
                }

                if (!_this24._triggers[name]) {
                  delete triggersWithStates[name];
                }
              });
            }
          );
        }
        /**
         * @param {?} name
         * @param {?} ast
         * @return {?}
         */

      }, {
        key: "register",
        value: function register(name, ast) {
          if (this._triggers[name]) {
            // throw
            return false;
          } else {
            this._triggers[name] = ast;
            return true;
          }
        }
        /**
         * @private
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "_getTrigger",
        value: function _getTrigger(name) {
          /** @type {?} */
          var trigger = this._triggers[name];

          if (!trigger) {
            throw new Error("The provided animation trigger \"".concat(name, "\" has not been registered!"));
          }

          return trigger;
        }
        /**
         * @param {?} element
         * @param {?} triggerName
         * @param {?} value
         * @param {?=} defaultToFallback
         * @return {?}
         */

      }, {
        key: "trigger",
        value: function trigger(element, triggerName, value) {
          var _this25 = this;

          var defaultToFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

          /** @type {?} */
          var trigger = this._getTrigger(triggerName);
          /** @type {?} */


          var player = new TransitionAnimationPlayer(this.id, triggerName, element);
          /** @type {?} */

          var triggersWithStates = this._engine.statesByElement.get(element);

          if (!triggersWithStates) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);

            this._engine.statesByElement.set(element, triggersWithStates = {});
          }
          /** @type {?} */


          var fromState = triggersWithStates[triggerName];
          /** @type {?} */

          var toState = new StateValue(value, this.id);
          /** @type {?} */

          var isObj = value && value.hasOwnProperty('value');

          if (!isObj && fromState) {
            toState.absorbOptions(fromState.options);
          }

          triggersWithStates[triggerName] = toState;

          if (!fromState) {
            fromState = DEFAULT_STATE_VALUE;
          }
          /** @type {?} */


          var isRemoval = toState.value === VOID_VALUE; // normally this isn't reached by here, however, if an object expression
          // is passed in then it may be a new object each time. Comparing the value
          // is important since that will stay the same despite there being a new object.
          // The removal arc here is special cased because the same element is triggered
          // twice in the event that it contains animations on the outer/inner portions
          // of the host container

          if (!isRemoval && fromState.value === toState.value) {
            // this means that despite the value not changing, some inner params
            // have changed which means that the animation final styles need to be applied
            if (!objEquals(fromState.params, toState.params)) {
              /** @type {?} */
              var errors = [];
              /** @type {?} */

              var fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);
              /** @type {?} */

              var toStyles = trigger.matchStyles(toState.value, toState.params, errors);

              if (errors.length) {
                this._engine.reportError(errors);
              } else {
                this._engine.afterFlush(
                /**
                * @return {?}
                */
                function () {
                  eraseStyles(element, fromStyles);
                  setStyles(element, toStyles);
                });
              }
            }

            return;
          }
          /** @type {?} */


          var playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
          playersOnElement.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            // only remove the player if it is queued on the EXACT same trigger/namespace
            // we only also deal with queued players here because if the animation has
            // started then we want to keep the player alive until the flush happens
            // (which is where the previousPlayers are passed into the new palyer)
            if (player.namespaceId == _this25.id && player.triggerName == triggerName && player.queued) {
              player.destroy();
            }
          });
          /** @type {?} */

          var transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);
          /** @type {?} */

          var isFallbackTransition = false;

          if (!transition) {
            if (!defaultToFallback) return;
            transition = trigger.fallbackTransition;
            isFallbackTransition = true;
          }

          this._engine.totalQueuedPlayers++;

          this._queue.push({
            element: element,
            triggerName: triggerName,
            transition: transition,
            fromState: fromState,
            toState: toState,
            player: player,
            isFallbackTransition: isFallbackTransition
          });

          if (!isFallbackTransition) {
            addClass(element, QUEUED_CLASSNAME);
            player.onStart(
            /**
            * @return {?}
            */
            function () {
              removeClass(element, QUEUED_CLASSNAME);
            });
          }

          player.onDone(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var index = _this25.players.indexOf(player);

            if (index >= 0) {
              _this25.players.splice(index, 1);
            }
            /** @type {?} */


            var players = _this25._engine.playersByElement.get(element);

            if (players) {
              /** @type {?} */
              var _index = players.indexOf(player);

              if (_index >= 0) {
                players.splice(_index, 1);
              }
            }
          });
          this.players.push(player);
          playersOnElement.push(player);
          return player;
        }
        /**
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "deregister",
        value: function deregister(name) {
          var _this26 = this;

          delete this._triggers[name];

          this._engine.statesByElement.forEach(
          /**
          * @param {?} stateMap
          * @param {?} element
          * @return {?}
          */
          function (stateMap, element) {
            delete stateMap[name];
          });

          this._elementListeners.forEach(
          /**
          * @param {?} listeners
          * @param {?} element
          * @return {?}
          */
          function (listeners, element) {
            _this26._elementListeners.set(element, listeners.filter(
            /**
            * @param {?} entry
            * @return {?}
            */
            function (entry) {
              return entry.name != name;
            }));
          });
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "clearElementCache",
        value: function clearElementCache(element) {
          this._engine.statesByElement["delete"](element);

          this._elementListeners["delete"](element);
          /** @type {?} */


          var elementPlayers = this._engine.playersByElement.get(element);

          if (elementPlayers) {
            elementPlayers.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              return player.destroy();
            });

            this._engine.playersByElement["delete"](element);
          }
        }
        /**
         * @private
         * @param {?} rootElement
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "_signalRemovalForInnerTriggers",
        value: function _signalRemovalForInnerTriggers(rootElement, context) {
          var _this27 = this;

          /** @type {?} */
          var elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true); // emulate a leave animation for all inner nodes within this node.
          // If there are no animations found for any of the nodes then clear the cache
          // for the element.


          elements.forEach(
          /**
          * @param {?} elm
          * @return {?}
          */
          function (elm) {
            // this means that an inner remove() operation has already kicked off
            // the animation on this element...
            if (elm[REMOVAL_FLAG]) return;
            /** @type {?} */

            var namespaces = _this27._engine.fetchNamespacesByElement(elm);

            if (namespaces.size) {
              namespaces.forEach(
              /**
              * @param {?} ns
              * @return {?}
              */
              function (ns) {
                return ns.triggerLeaveAnimation(elm, context, false, true);
              });
            } else {
              _this27.clearElementCache(elm);
            }
          }); // If the child elements were removed along with the parent, their animations might not
          // have completed. Clear all the elements from the cache so we don't end up with a memory leak.

          this._engine.afterFlushAnimationsDone(
          /**
          * @return {?}
          */
          function () {
            return elements.forEach(
            /**
            * @param {?} elm
            * @return {?}
            */
            function (elm) {
              return _this27.clearElementCache(elm);
            });
          });
        }
        /**
         * @param {?} element
         * @param {?} context
         * @param {?=} destroyAfterComplete
         * @param {?=} defaultToFallback
         * @return {?}
         */

      }, {
        key: "triggerLeaveAnimation",
        value: function triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {
          var _this28 = this;

          /** @type {?} */
          var triggerStates = this._engine.statesByElement.get(element);

          if (triggerStates) {
            /** @type {?} */
            var players = [];
            Object.keys(triggerStates).forEach(
            /**
            * @param {?} triggerName
            * @return {?}
            */
            function (triggerName) {
              // this check is here in the event that an element is removed
              // twice (both on the host level and the component level)
              if (_this28._triggers[triggerName]) {
                /** @type {?} */
                var player = _this28.trigger(element, triggerName, VOID_VALUE, defaultToFallback);

                if (player) {
                  players.push(player);
                }
              }
            });

            if (players.length) {
              this._engine.markElementAsRemoved(this.id, element, true, context);

              if (destroyAfterComplete) {
                optimizeGroupPlayer(players).onDone(
                /**
                * @return {?}
                */
                function () {
                  return _this28._engine.processLeaveNode(element);
                });
              }

              return true;
            }
          }

          return false;
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "prepareLeaveAnimationListeners",
        value: function prepareLeaveAnimationListeners(element) {
          var _this29 = this;

          /** @type {?} */
          var listeners = this._elementListeners.get(element);

          if (listeners) {
            /** @type {?} */
            var visitedTriggers = new Set();
            listeners.forEach(
            /**
            * @param {?} listener
            * @return {?}
            */
            function (listener) {
              /** @type {?} */
              var triggerName = listener.name;
              if (visitedTriggers.has(triggerName)) return;
              visitedTriggers.add(triggerName);
              /** @type {?} */

              var trigger = _this29._triggers[triggerName];
              /** @type {?} */

              var transition = trigger.fallbackTransition;
              /** @type {?} */

              var elementStates =
              /** @type {?} */
              _this29._engine.statesByElement.get(element);
              /** @type {?} */


              var fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
              /** @type {?} */

              var toState = new StateValue(VOID_VALUE);
              /** @type {?} */

              var player = new TransitionAnimationPlayer(_this29.id, triggerName, element);
              _this29._engine.totalQueuedPlayers++;

              _this29._queue.push({
                element: element,
                triggerName: triggerName,
                transition: transition,
                fromState: fromState,
                toState: toState,
                player: player,
                isFallbackTransition: true
              });
            });
          }
        }
        /**
         * @param {?} element
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "removeNode",
        value: function removeNode(element, context) {
          var _this30 = this;

          /** @type {?} */
          var engine = this._engine;

          if (element.childElementCount) {
            this._signalRemovalForInnerTriggers(element, context);
          } // this means that a * => VOID animation was detected and kicked off


          if (this.triggerLeaveAnimation(element, context, true)) return; // find the player that is animating and make sure that the
          // removal is delayed until that player has completed

          /** @type {?} */

          var containsPotentialParentTransition = false;

          if (engine.totalAnimations) {
            /** @type {?} */
            var currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : []; // when this `if statement` does not continue forward it means that
            // a previous animation query has selected the current element and
            // is animating it. In this situation want to continue forwards and
            // allow the element to be queued up for animation later.

            if (currentPlayers && currentPlayers.length) {
              containsPotentialParentTransition = true;
            } else {
              /** @type {?} */
              var parent = element;

              while (parent = parent.parentNode) {
                /** @type {?} */
                var triggers = engine.statesByElement.get(parent);

                if (triggers) {
                  containsPotentialParentTransition = true;
                  break;
                }
              }
            }
          } // at this stage we know that the element will either get removed
          // during flush or will be picked up by a parent query. Either way
          // we need to fire the listeners for this element when it DOES get
          // removed (once the query parent animation is done or after flush)


          this.prepareLeaveAnimationListeners(element); // whether or not a parent has an animation we need to delay the deferral of the leave
          // operation until we have more information (which we do after flush() has been called)

          if (containsPotentialParentTransition) {
            engine.markElementAsRemoved(this.id, element, false, context);
          } else {
            /** @type {?} */
            var removalFlag = element[REMOVAL_FLAG];

            if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {
              // we do this after the flush has occurred such
              // that the callbacks can be fired
              engine.afterFlush(
              /**
              * @return {?}
              */
              function () {
                return _this30.clearElementCache(element);
              });
              engine.destroyInnerAnimations(element);

              engine._onRemovalComplete(element, context);
            }
          }
        }
        /**
         * @param {?} element
         * @param {?} parent
         * @return {?}
         */

      }, {
        key: "insertNode",
        value: function insertNode(element, parent) {
          addClass(element, this._hostClassName);
        }
        /**
         * @param {?} microtaskId
         * @return {?}
         */

      }, {
        key: "drainQueuedTransitions",
        value: function drainQueuedTransitions(microtaskId) {
          var _this31 = this;

          /** @type {?} */
          var instructions = [];

          this._queue.forEach(
          /**
          * @param {?} entry
          * @return {?}
          */
          function (entry) {
            /** @type {?} */
            var player = entry.player;
            if (player.destroyed) return;
            /** @type {?} */

            var element = entry.element;
            /** @type {?} */

            var listeners = _this31._elementListeners.get(element);

            if (listeners) {
              listeners.forEach(
              /**
              * @param {?} listener
              * @return {?}
              */
              function (listener) {
                if (listener.name == entry.triggerName) {
                  /** @type {?} */
                  var baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);

                  /** @type {?} */
                  baseEvent['_data'] = microtaskId;
                  listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                }
              });
            }

            if (player.markedForDestroy) {
              _this31._engine.afterFlush(
              /**
              * @return {?}
              */
              function () {
                // now we can destroy the element properly since the event listeners have
                // been bound to the player
                player.destroy();
              });
            } else {
              instructions.push(entry);
            }
          });

          this._queue = [];
          return instructions.sort(
          /**
          * @param {?} a
          * @param {?} b
          * @return {?}
          */
          function (a, b) {
            // if depCount == 0 them move to front
            // otherwise if a contains b then move back

            /** @type {?} */
            var d0 = a.transition.ast.depCount;
            /** @type {?} */

            var d1 = b.transition.ast.depCount;

            if (d0 == 0 || d1 == 0) {
              return d0 - d1;
            }

            return _this31._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
          });
        }
        /**
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy(context) {
          this.players.forEach(
          /**
          * @param {?} p
          * @return {?}
          */
          function (p) {
            return p.destroy();
          });

          this._signalRemovalForInnerTriggers(this.hostElement, context);
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "elementContainsData",
        value: function elementContainsData(element) {
          /** @type {?} */
          var containsData = false;
          if (this._elementListeners.has(element)) containsData = true;
          containsData = (this._queue.find(
          /**
          * @param {?} entry
          * @return {?}
          */
          function (entry) {
            return entry.element === element;
          }) ? true : false) || containsData;
          return containsData;
        }
      }]);

      return AnimationTransitionNamespace;
    }();

    if (false) {}
    /**
     * @record
     */


    function QueuedTransition() {}

    if (false) {}

    var TransitionAnimationEngine = /*#__PURE__*/function () {
      /**
       * @param {?} bodyNode
       * @param {?} driver
       * @param {?} _normalizer
       */
      function TransitionAnimationEngine(bodyNode, driver, _normalizer) {
        _classCallCheck(this, TransitionAnimationEngine);

        this.bodyNode = bodyNode;
        this.driver = driver;
        this._normalizer = _normalizer;
        this.players = [];
        this.newHostElements = new Map();
        this.playersByElement = new Map();
        this.playersByQueriedElement = new Map();
        this.statesByElement = new Map();
        this.disabledNodes = new Set();
        this.totalAnimations = 0;
        this.totalQueuedPlayers = 0;
        this._namespaceLookup = {};
        this._namespaceList = [];
        this._flushFns = [];
        this._whenQuietFns = [];
        this.namespacesByHostElement = new Map();
        this.collectedEnterElements = [];
        this.collectedLeaveElements = []; // this method is designed to be overridden by the code that uses this engine

        this.onRemovalComplete =
        /**
        * @param {?} element
        * @param {?} context
        * @return {?}
        */
        function (element, context) {};
      }
      /**
       * \@internal
       * @param {?} element
       * @param {?} context
       * @return {?}
       */


      _createClass(TransitionAnimationEngine, [{
        key: "_onRemovalComplete",
        value: function _onRemovalComplete(element, context) {
          this.onRemovalComplete(element, context);
        }
        /**
         * @return {?}
         */

      }, {
        key: "createNamespace",

        /**
         * @param {?} namespaceId
         * @param {?} hostElement
         * @return {?}
         */
        value: function createNamespace(namespaceId, hostElement) {
          /** @type {?} */
          var ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);

          if (hostElement.parentNode) {
            this._balanceNamespaceList(ns, hostElement);
          } else {
            // defer this later until flush during when the host element has
            // been inserted so that we know exactly where to place it in
            // the namespace list
            this.newHostElements.set(hostElement, ns); // given that this host element is apart of the animation code, it
            // may or may not be inserted by a parent node that is an of an
            // animation renderer type. If this happens then we can still have
            // access to this item when we query for :enter nodes. If the parent
            // is a renderer then the set data-structure will normalize the entry

            this.collectEnterElement(hostElement);
          }

          return this._namespaceLookup[namespaceId] = ns;
        }
        /**
         * @private
         * @param {?} ns
         * @param {?} hostElement
         * @return {?}
         */

      }, {
        key: "_balanceNamespaceList",
        value: function _balanceNamespaceList(ns, hostElement) {
          /** @type {?} */
          var limit = this._namespaceList.length - 1;

          if (limit >= 0) {
            /** @type {?} */
            var found = false;

            for (var i = limit; i >= 0; i--) {
              /** @type {?} */
              var nextNamespace = this._namespaceList[i];

              if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
                this._namespaceList.splice(i + 1, 0, ns);

                found = true;
                break;
              }
            }

            if (!found) {
              this._namespaceList.splice(0, 0, ns);
            }
          } else {
            this._namespaceList.push(ns);
          }

          this.namespacesByHostElement.set(hostElement, ns);
          return ns;
        }
        /**
         * @param {?} namespaceId
         * @param {?} hostElement
         * @return {?}
         */

      }, {
        key: "register",
        value: function register(namespaceId, hostElement) {
          /** @type {?} */
          var ns = this._namespaceLookup[namespaceId];

          if (!ns) {
            ns = this.createNamespace(namespaceId, hostElement);
          }

          return ns;
        }
        /**
         * @param {?} namespaceId
         * @param {?} name
         * @param {?} trigger
         * @return {?}
         */

      }, {
        key: "registerTrigger",
        value: function registerTrigger(namespaceId, name, trigger) {
          /** @type {?} */
          var ns = this._namespaceLookup[namespaceId];

          if (ns && ns.register(name, trigger)) {
            this.totalAnimations++;
          }
        }
        /**
         * @param {?} namespaceId
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy(namespaceId, context) {
          var _this32 = this;

          if (!namespaceId) return;
          /** @type {?} */

          var ns = this._fetchNamespace(namespaceId);

          this.afterFlush(
          /**
          * @return {?}
          */
          function () {
            _this32.namespacesByHostElement["delete"](ns.hostElement);

            delete _this32._namespaceLookup[namespaceId];
            /** @type {?} */

            var index = _this32._namespaceList.indexOf(ns);

            if (index >= 0) {
              _this32._namespaceList.splice(index, 1);
            }
          });
          this.afterFlushAnimationsDone(
          /**
          * @return {?}
          */
          function () {
            return ns.destroy(context);
          });
        }
        /**
         * @private
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "_fetchNamespace",
        value: function _fetchNamespace(id) {
          return this._namespaceLookup[id];
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "fetchNamespacesByElement",
        value: function fetchNamespacesByElement(element) {
          // normally there should only be one namespace per element, however
          // if @triggers are placed on both the component element and then
          // its host element (within the component code) then there will be
          // two namespaces returned. We use a set here to simply the dedupe
          // of namespaces incase there are multiple triggers both the elm and host

          /** @type {?} */
          var namespaces = new Set();
          /** @type {?} */

          var elementStates = this.statesByElement.get(element);

          if (elementStates) {
            /** @type {?} */
            var keys = Object.keys(elementStates);

            for (var i = 0; i < keys.length; i++) {
              /** @type {?} */
              var nsId = elementStates[keys[i]].namespaceId;

              if (nsId) {
                /** @type {?} */
                var ns = this._fetchNamespace(nsId);

                if (ns) {
                  namespaces.add(ns);
                }
              }
            }
          }

          return namespaces;
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} name
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "trigger",
        value: function trigger(namespaceId, element, name, value) {
          if (isElementNode(element)) {
            /** @type {?} */
            var ns = this._fetchNamespace(namespaceId);

            if (ns) {
              ns.trigger(element, name, value);
              return true;
            }
          }

          return false;
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} parent
         * @param {?} insertBefore
         * @return {?}
         */

      }, {
        key: "insertNode",
        value: function insertNode(namespaceId, element, parent, insertBefore) {
          if (!isElementNode(element)) return; // special case for when an element is removed and reinserted (move operation)
          // when this occurs we do not want to use the element for deletion later

          /** @type {?} */

          var details =
          /** @type {?} */
          element[REMOVAL_FLAG];

          if (details && details.setForRemoval) {
            details.setForRemoval = false;
            details.setForMove = true;
            /** @type {?} */

            var index = this.collectedLeaveElements.indexOf(element);

            if (index >= 0) {
              this.collectedLeaveElements.splice(index, 1);
            }
          } // in the event that the namespaceId is blank then the caller
          // code does not contain any animation code in it, but it is
          // just being called so that the node is marked as being inserted


          if (namespaceId) {
            /** @type {?} */
            var ns = this._fetchNamespace(namespaceId); // This if-statement is a workaround for router issue #21947.
            // The router sometimes hits a race condition where while a route
            // is being instantiated a new navigation arrives, triggering leave
            // animation of DOM that has not been fully initialized, until this
            // is resolved, we need to handle the scenario when DOM is not in a
            // consistent state during the animation.


            if (ns) {
              ns.insertNode(element, parent);
            }
          } // only *directives and host elements are inserted before


          if (insertBefore) {
            this.collectEnterElement(element);
          }
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "collectEnterElement",
        value: function collectEnterElement(element) {
          this.collectedEnterElements.push(element);
        }
        /**
         * @param {?} element
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "markElementAsDisabled",
        value: function markElementAsDisabled(element, value) {
          if (value) {
            if (!this.disabledNodes.has(element)) {
              this.disabledNodes.add(element);
              addClass(element, DISABLED_CLASSNAME);
            }
          } else if (this.disabledNodes.has(element)) {
            this.disabledNodes["delete"](element);
            removeClass(element, DISABLED_CLASSNAME);
          }
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} isHostElement
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "removeNode",
        value: function removeNode(namespaceId, element, isHostElement, context) {
          if (isElementNode(element)) {
            /** @type {?} */
            var ns = namespaceId ? this._fetchNamespace(namespaceId) : null;

            if (ns) {
              ns.removeNode(element, context);
            } else {
              this.markElementAsRemoved(namespaceId, element, false, context);
            }

            if (isHostElement) {
              /** @type {?} */
              var hostNS = this.namespacesByHostElement.get(element);

              if (hostNS && hostNS.id !== namespaceId) {
                hostNS.removeNode(element, context);
              }
            }
          } else {
            this._onRemovalComplete(element, context);
          }
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?=} hasAnimation
         * @param {?=} context
         * @return {?}
         */

      }, {
        key: "markElementAsRemoved",
        value: function markElementAsRemoved(namespaceId, element, hasAnimation, context) {
          this.collectedLeaveElements.push(element);
          element[REMOVAL_FLAG] = {
            namespaceId: namespaceId,
            setForRemoval: context,
            hasAnimation: hasAnimation,
            removedBeforeQueried: false
          };
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} name
         * @param {?} phase
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "listen",
        value: function listen(namespaceId, element, name, phase, callback) {
          if (isElementNode(element)) {
            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
          }

          return (
            /**
            * @return {?}
            */
            function () {}
          );
        }
        /**
         * @private
         * @param {?} entry
         * @param {?} subTimelines
         * @param {?} enterClassName
         * @param {?} leaveClassName
         * @param {?=} skipBuildAst
         * @return {?}
         */

      }, {
        key: "_buildInstruction",
        value: function _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
          return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
        }
        /**
         * @param {?} containerElement
         * @return {?}
         */

      }, {
        key: "destroyInnerAnimations",
        value: function destroyInnerAnimations(containerElement) {
          var _this33 = this;

          /** @type {?} */
          var elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
          elements.forEach(
          /**
          * @param {?} element
          * @return {?}
          */
          function (element) {
            return _this33.destroyActiveAnimationsForElement(element);
          });
          if (this.playersByQueriedElement.size == 0) return;
          elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
          elements.forEach(
          /**
          * @param {?} element
          * @return {?}
          */
          function (element) {
            return _this33.finishActiveQueriedAnimationOnElement(element);
          });
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "destroyActiveAnimationsForElement",
        value: function destroyActiveAnimationsForElement(element) {
          /** @type {?} */
          var players = this.playersByElement.get(element);

          if (players) {
            players.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              // special case for when an element is set for destruction, but hasn't started.
              // in this situation we want to delay the destruction until the flush occurs
              // so that any event listeners attached to the player are triggered.
              if (player.queued) {
                player.markedForDestroy = true;
              } else {
                player.destroy();
              }
            });
          }
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "finishActiveQueriedAnimationOnElement",
        value: function finishActiveQueriedAnimationOnElement(element) {
          /** @type {?} */
          var players = this.playersByQueriedElement.get(element);

          if (players) {
            players.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              return player.finish();
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "whenRenderingDone",
        value: function whenRenderingDone() {
          var _this34 = this;

          return new Promise(
          /**
          * @param {?} resolve
          * @return {?}
          */
          function (resolve) {
            if (_this34.players.length) {
              return optimizeGroupPlayer(_this34.players).onDone(
              /**
              * @return {?}
              */
              function () {
                return resolve();
              });
            } else {
              resolve();
            }
          });
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "processLeaveNode",
        value: function processLeaveNode(element) {
          var _this35 = this;

          /** @type {?} */
          var details =
          /** @type {?} */
          element[REMOVAL_FLAG];

          if (details && details.setForRemoval) {
            // this will prevent it from removing it twice
            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;

            if (details.namespaceId) {
              this.destroyInnerAnimations(element);
              /** @type {?} */

              var ns = this._fetchNamespace(details.namespaceId);

              if (ns) {
                ns.clearElementCache(element);
              }
            }

            this._onRemovalComplete(element, details.setForRemoval);
          }

          if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
            this.markElementAsDisabled(element, false);
          }

          this.driver.query(element, DISABLED_SELECTOR, true).forEach(
          /**
          * @param {?} node
          * @return {?}
          */
          function (node) {
            _this35.markElementAsDisabled(node, false);
          });
        }
        /**
         * @param {?=} microtaskId
         * @return {?}
         */

      }, {
        key: "flush",
        value: function flush() {
          var _this36 = this;

          var microtaskId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

          /** @type {?} */
          var players = [];

          if (this.newHostElements.size) {
            this.newHostElements.forEach(
            /**
            * @param {?} ns
            * @param {?} element
            * @return {?}
            */
            function (ns, element) {
              return _this36._balanceNamespaceList(ns, element);
            });
            this.newHostElements.clear();
          }

          if (this.totalAnimations && this.collectedEnterElements.length) {
            for (var i = 0; i < this.collectedEnterElements.length; i++) {
              /** @type {?} */
              var elm = this.collectedEnterElements[i];
              addClass(elm, STAR_CLASSNAME);
            }
          }

          if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
            /** @type {?} */
            var cleanupFns = [];

            try {
              players = this._flushAnimations(cleanupFns, microtaskId);
            } finally {
              for (var _i2 = 0; _i2 < cleanupFns.length; _i2++) {
                cleanupFns[_i2]();
              }
            }
          } else {
            for (var _i3 = 0; _i3 < this.collectedLeaveElements.length; _i3++) {
              /** @type {?} */
              var element = this.collectedLeaveElements[_i3];
              this.processLeaveNode(element);
            }
          }

          this.totalQueuedPlayers = 0;
          this.collectedEnterElements.length = 0;
          this.collectedLeaveElements.length = 0;

          this._flushFns.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });

          this._flushFns = [];

          if (this._whenQuietFns.length) {
            // we move these over to a variable so that
            // if any new callbacks are registered in another
            // flush they do not populate the existing set

            /** @type {?} */
            var quietFns = this._whenQuietFns;
            this._whenQuietFns = [];

            if (players.length) {
              optimizeGroupPlayer(players).onDone(
              /**
              * @return {?}
              */
              function () {
                quietFns.forEach(
                /**
                * @param {?} fn
                * @return {?}
                */
                function (fn) {
                  return fn();
                });
              });
            } else {
              quietFns.forEach(
              /**
              * @param {?} fn
              * @return {?}
              */
              function (fn) {
                return fn();
              });
            }
          }
        }
        /**
         * @param {?} errors
         * @return {?}
         */

      }, {
        key: "reportError",
        value: function reportError(errors) {
          throw new Error("Unable to process animations due to the following failed trigger transitions\n ".concat(errors.join('\n')));
        }
        /**
         * @private
         * @param {?} cleanupFns
         * @param {?} microtaskId
         * @return {?}
         */

      }, {
        key: "_flushAnimations",
        value: function _flushAnimations(cleanupFns, microtaskId) {
          var _this37 = this;

          /** @type {?} */
          var subTimelines = new ElementInstructionMap();
          /** @type {?} */

          var skippedPlayers = [];
          /** @type {?} */

          var skippedPlayersMap = new Map();
          /** @type {?} */

          var queuedInstructions = [];
          /** @type {?} */

          var queriedElements = new Map();
          /** @type {?} */

          var allPreStyleElements = new Map();
          /** @type {?} */

          var allPostStyleElements = new Map();
          /** @type {?} */

          var disabledElementsSet = new Set();
          this.disabledNodes.forEach(
          /**
          * @param {?} node
          * @return {?}
          */
          function (node) {
            disabledElementsSet.add(node);
            /** @type {?} */

            var nodesThatAreDisabled = _this37.driver.query(node, QUEUED_SELECTOR, true);

            for (var _i4 = 0; _i4 < nodesThatAreDisabled.length; _i4++) {
              disabledElementsSet.add(nodesThatAreDisabled[_i4]);
            }
          });
          /** @type {?} */

          var bodyNode = this.bodyNode;
          /** @type {?} */

          var allTriggerElements = Array.from(this.statesByElement.keys());
          /** @type {?} */

          var enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements); // this must occur before the instructions are built below such that
          // the :enter queries match the elements (since the timeline queries
          // are fired during instruction building).

          /** @type {?} */

          var enterNodeMapIds = new Map();
          /** @type {?} */

          var i = 0;
          enterNodeMap.forEach(
          /**
          * @param {?} nodes
          * @param {?} root
          * @return {?}
          */
          function (nodes, root) {
            /** @type {?} */
            var className = ENTER_CLASSNAME + i++;
            enterNodeMapIds.set(root, className);
            nodes.forEach(
            /**
            * @param {?} node
            * @return {?}
            */
            function (node) {
              return addClass(node, className);
            });
          });
          /** @type {?} */

          var allLeaveNodes = [];
          /** @type {?} */

          var mergedLeaveNodes = new Set();
          /** @type {?} */

          var leaveNodesWithoutAnimations = new Set();

          for (var _i5 = 0; _i5 < this.collectedLeaveElements.length; _i5++) {
            /** @type {?} */
            var element = this.collectedLeaveElements[_i5];
            /** @type {?} */

            var details =
            /** @type {?} */
            element[REMOVAL_FLAG];

            if (details && details.setForRemoval) {
              allLeaveNodes.push(element);
              mergedLeaveNodes.add(element);

              if (details.hasAnimation) {
                this.driver.query(element, STAR_SELECTOR, true).forEach(
                /**
                * @param {?} elm
                * @return {?}
                */
                function (elm) {
                  return mergedLeaveNodes.add(elm);
                });
              } else {
                leaveNodesWithoutAnimations.add(element);
              }
            }
          }
          /** @type {?} */


          var leaveNodeMapIds = new Map();
          /** @type {?} */

          var leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
          leaveNodeMap.forEach(
          /**
          * @param {?} nodes
          * @param {?} root
          * @return {?}
          */
          function (nodes, root) {
            /** @type {?} */
            var className = LEAVE_CLASSNAME + i++;
            leaveNodeMapIds.set(root, className);
            nodes.forEach(
            /**
            * @param {?} node
            * @return {?}
            */
            function (node) {
              return addClass(node, className);
            });
          });
          cleanupFns.push(
          /**
          * @return {?}
          */
          function () {
            enterNodeMap.forEach(
            /**
            * @param {?} nodes
            * @param {?} root
            * @return {?}
            */
            function (nodes, root) {
              /** @type {?} */
              var className =
              /** @type {?} */
              enterNodeMapIds.get(root);
              nodes.forEach(
              /**
              * @param {?} node
              * @return {?}
              */
              function (node) {
                return removeClass(node, className);
              });
            });
            leaveNodeMap.forEach(
            /**
            * @param {?} nodes
            * @param {?} root
            * @return {?}
            */
            function (nodes, root) {
              /** @type {?} */
              var className =
              /** @type {?} */
              leaveNodeMapIds.get(root);
              nodes.forEach(
              /**
              * @param {?} node
              * @return {?}
              */
              function (node) {
                return removeClass(node, className);
              });
            });
            allLeaveNodes.forEach(
            /**
            * @param {?} element
            * @return {?}
            */
            function (element) {
              _this37.processLeaveNode(element);
            });
          });
          /** @type {?} */

          var allPlayers = [];
          /** @type {?} */

          var erroneousTransitions = [];

          for (var _i6 = this._namespaceList.length - 1; _i6 >= 0; _i6--) {
            /** @type {?} */
            var ns = this._namespaceList[_i6];
            ns.drainQueuedTransitions(microtaskId).forEach(
            /**
            * @param {?} entry
            * @return {?}
            */
            function (entry) {
              /** @type {?} */
              var player = entry.player;
              /** @type {?} */

              var element = entry.element;
              allPlayers.push(player);

              if (_this37.collectedEnterElements.length) {
                /** @type {?} */
                var _details =
                /** @type {?} */
                element[REMOVAL_FLAG]; // move animations are currently not supported...

                if (_details && _details.setForMove) {
                  player.destroy();
                  return;
                }
              }
              /** @type {?} */


              var nodeIsOrphaned = !bodyNode || !_this37.driver.containsElement(bodyNode, element);
              /** @type {?} */

              var leaveClassName =
              /** @type {?} */
              leaveNodeMapIds.get(element);
              /** @type {?} */

              var enterClassName =
              /** @type {?} */
              enterNodeMapIds.get(element);
              /** @type {?} */

              var instruction =
              /** @type {?} */
              _this37._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);

              if (instruction.errors && instruction.errors.length) {
                erroneousTransitions.push(instruction);
                return;
              } // even though the element may not be apart of the DOM, it may
              // still be added at a later point (due to the mechanics of content
              // projection and/or dynamic component insertion) therefore it's
              // important we still style the element.


              if (nodeIsOrphaned) {
                player.onStart(
                /**
                * @return {?}
                */
                function () {
                  return eraseStyles(element, instruction.fromStyles);
                });
                player.onDestroy(
                /**
                * @return {?}
                */
                function () {
                  return setStyles(element, instruction.toStyles);
                });
                skippedPlayers.push(player);
                return;
              } // if a unmatched transition is queued to go then it SHOULD NOT render
              // an animation and cancel the previously running animations.


              if (entry.isFallbackTransition) {
                player.onStart(
                /**
                * @return {?}
                */
                function () {
                  return eraseStyles(element, instruction.fromStyles);
                });
                player.onDestroy(
                /**
                * @return {?}
                */
                function () {
                  return setStyles(element, instruction.toStyles);
                });
                skippedPlayers.push(player);
                return;
              } // this means that if a parent animation uses this animation as a sub trigger
              // then it will instruct the timeline builder to not add a player delay, but
              // instead stretch the first keyframe gap up until the animation starts. The
              // reason this is important is to prevent extra initialization styles from being
              // required by the user in the animation.


              instruction.timelines.forEach(
              /**
              * @param {?} tl
              * @return {?}
              */
              function (tl) {
                return tl.stretchStartingKeyframe = true;
              });
              subTimelines.append(element, instruction.timelines);
              /** @type {?} */

              var tuple = {
                instruction: instruction,
                player: player,
                element: element
              };
              queuedInstructions.push(tuple);
              instruction.queriedElements.forEach(
              /**
              * @param {?} element
              * @return {?}
              */
              function (element) {
                return getOrSetAsInMap(queriedElements, element, []).push(player);
              });
              instruction.preStyleProps.forEach(
              /**
              * @param {?} stringMap
              * @param {?} element
              * @return {?}
              */
              function (stringMap, element) {
                /** @type {?} */
                var props = Object.keys(stringMap);

                if (props.length) {
                  /** @type {?} */
                  var setVal =
                  /** @type {?} */
                  allPreStyleElements.get(element);

                  if (!setVal) {
                    allPreStyleElements.set(element, setVal = new Set());
                  }

                  props.forEach(
                  /**
                  * @param {?} prop
                  * @return {?}
                  */
                  function (prop) {
                    return setVal.add(prop);
                  });
                }
              });
              instruction.postStyleProps.forEach(
              /**
              * @param {?} stringMap
              * @param {?} element
              * @return {?}
              */
              function (stringMap, element) {
                /** @type {?} */
                var props = Object.keys(stringMap);
                /** @type {?} */

                var setVal =
                /** @type {?} */
                allPostStyleElements.get(element);

                if (!setVal) {
                  allPostStyleElements.set(element, setVal = new Set());
                }

                props.forEach(
                /**
                * @param {?} prop
                * @return {?}
                */
                function (prop) {
                  return setVal.add(prop);
                });
              });
            });
          }

          if (erroneousTransitions.length) {
            /** @type {?} */
            var errors = [];
            erroneousTransitions.forEach(
            /**
            * @param {?} instruction
            * @return {?}
            */
            function (instruction) {
              errors.push("@".concat(instruction.triggerName, " has failed due to:\n"));

              /** @type {?} */
              instruction.errors.forEach(
              /**
              * @param {?} error
              * @return {?}
              */
              function (error) {
                return errors.push("- ".concat(error, "\n"));
              });
            });
            allPlayers.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              return player.destroy();
            });
            this.reportError(errors);
          }
          /** @type {?} */


          var allPreviousPlayersMap = new Map(); // this map works to tell which element in the DOM tree is contained by
          // which animation. Further down below this map will get populated once
          // the players are built and in doing so it can efficiently figure out
          // if a sub player is skipped due to a parent player having priority.

          /** @type {?} */

          var animationElementMap = new Map();
          queuedInstructions.forEach(
          /**
          * @param {?} entry
          * @return {?}
          */
          function (entry) {
            /** @type {?} */
            var element = entry.element;

            if (subTimelines.has(element)) {
              animationElementMap.set(element, element);

              _this37._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
            }
          });
          skippedPlayers.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            /** @type {?} */
            var element = player.element;
            /** @type {?} */

            var previousPlayers = _this37._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);

            previousPlayers.forEach(
            /**
            * @param {?} prevPlayer
            * @return {?}
            */
            function (prevPlayer) {
              getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
              prevPlayer.destroy();
            });
          }); // this is a special case for nodes that will be removed (either by)
          // having their own leave animations or by being queried in a container
          // that will be removed once a parent animation is complete. The idea
          // here is that * styles must be identical to ! styles because of
          // backwards compatibility (* is also filled in by default in many places).
          // Otherwise * styles will return an empty value or auto since the element
          // that is being getComputedStyle'd will not be visible (since * = destination)

          /** @type {?} */

          var replaceNodes = allLeaveNodes.filter(
          /**
          * @param {?} node
          * @return {?}
          */
          function (node) {
            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
          }); // POST STAGE: fill the * styles

          /** @type {?} */

          var postStylesMap = new Map();
          /** @type {?} */

          var allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AUTO_STYLE"]);
          allLeaveQueriedNodes.forEach(
          /**
          * @param {?} node
          * @return {?}
          */
          function (node) {
            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
              replaceNodes.push(node);
            }
          }); // PRE STAGE: fill the ! styles

          /** @type {?} */

          var preStylesMap = new Map();
          enterNodeMap.forEach(
          /**
          * @param {?} nodes
          * @param {?} root
          * @return {?}
          */
          function (nodes, root) {
            cloakAndComputeStyles(preStylesMap, _this37.driver, new Set(nodes), allPreStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_0__["ɵPRE_STYLE"]);
          });
          replaceNodes.forEach(
          /**
          * @param {?} node
          * @return {?}
          */
          function (node) {
            /** @type {?} */
            var post = postStylesMap.get(node);
            /** @type {?} */

            var pre = preStylesMap.get(node);
            postStylesMap.set(node,
            /** @type {?} */
            Object.assign(Object.assign({}, post), pre));
          });
          /** @type {?} */

          var rootPlayers = [];
          /** @type {?} */

          var subPlayers = [];
          /** @type {?} */

          var NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
          queuedInstructions.forEach(
          /**
          * @param {?} entry
          * @return {?}
          */
          function (entry) {
            var element = entry.element,
                player = entry.player,
                instruction = entry.instruction; // this means that it was never consumed by a parent animation which
            // means that it is independent and therefore should be set for animation

            if (subTimelines.has(element)) {
              if (disabledElementsSet.has(element)) {
                player.onDestroy(
                /**
                * @return {?}
                */
                function () {
                  return setStyles(element, instruction.toStyles);
                });
                player.disabled = true;
                player.overrideTotalTime(instruction.totalTime);
                skippedPlayers.push(player);
                return;
              } // this will flow up the DOM and query the map to figure out
              // if a parent animation has priority over it. In the situation
              // that a parent is detected then it will cancel the loop. If
              // nothing is detected, or it takes a few hops to find a parent,
              // then it will fill in the missing nodes and signal them as having
              // a detected parent (or a NO_PARENT value via a special constant).

              /** @type {?} */


              var parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;

              if (animationElementMap.size > 1) {
                /** @type {?} */
                var elm = element;
                /** @type {?} */

                var parentsToAdd = [];

                while (elm = elm.parentNode) {
                  /** @type {?} */
                  var detectedParent = animationElementMap.get(elm);

                  if (detectedParent) {
                    parentWithAnimation = detectedParent;
                    break;
                  }

                  parentsToAdd.push(elm);
                }

                parentsToAdd.forEach(
                /**
                * @param {?} parent
                * @return {?}
                */
                function (parent) {
                  return animationElementMap.set(parent, parentWithAnimation);
                });
              }
              /** @type {?} */


              var innerPlayer = _this37._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);

              player.setRealPlayer(innerPlayer);

              if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
                rootPlayers.push(player);
              } else {
                /** @type {?} */
                var parentPlayers = _this37.playersByElement.get(parentWithAnimation);

                if (parentPlayers && parentPlayers.length) {
                  player.parentPlayer = optimizeGroupPlayer(parentPlayers);
                }

                skippedPlayers.push(player);
              }
            } else {
              eraseStyles(element, instruction.fromStyles);
              player.onDestroy(
              /**
              * @return {?}
              */
              function () {
                return setStyles(element, instruction.toStyles);
              }); // there still might be a ancestor player animating this
              // element therefore we will still add it as a sub player
              // even if its animation may be disabled

              subPlayers.push(player);

              if (disabledElementsSet.has(element)) {
                skippedPlayers.push(player);
              }
            }
          }); // find all of the sub players' corresponding inner animation player

          subPlayers.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            // even if any players are not found for a sub animation then it
            // will still complete itself after the next tick since it's Noop

            /** @type {?} */
            var playersForElement = skippedPlayersMap.get(player.element);

            if (playersForElement && playersForElement.length) {
              /** @type {?} */
              var innerPlayer = optimizeGroupPlayer(playersForElement);
              player.setRealPlayer(innerPlayer);
            }
          }); // the reason why we don't actually play the animation is
          // because all that a skipped player is designed to do is to
          // fire the start/done transition callback events

          skippedPlayers.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            if (player.parentPlayer) {
              player.syncPlayerEvents(player.parentPlayer);
            } else {
              player.destroy();
            }
          }); // run through all of the queued removals and see if they
          // were picked up by a query. If not then perform the removal
          // operation right away unless a parent animation is ongoing.

          for (var _i7 = 0; _i7 < allLeaveNodes.length; _i7++) {
            /** @type {?} */
            var _element2 = allLeaveNodes[_i7];
            /** @type {?} */

            var _details2 =
            /** @type {?} */
            _element2[REMOVAL_FLAG];
            removeClass(_element2, LEAVE_CLASSNAME); // this means the element has a removal animation that is being
            // taken care of and therefore the inner elements will hang around
            // until that animation is over (or the parent queried animation)

            if (_details2 && _details2.hasAnimation) continue;
            /** @type {?} */

            var players = []; // if this element is queried or if it contains queried children
            // then we want for the element not to be removed from the page
            // until the queried animations have finished

            if (queriedElements.size) {
              /** @type {?} */
              var queriedPlayerResults = queriedElements.get(_element2);

              if (queriedPlayerResults && queriedPlayerResults.length) {
                players.push.apply(players, _toConsumableArray(queriedPlayerResults));
              }
              /** @type {?} */


              var queriedInnerElements = this.driver.query(_element2, NG_ANIMATING_SELECTOR, true);

              for (var j = 0; j < queriedInnerElements.length; j++) {
                /** @type {?} */
                var queriedPlayers = queriedElements.get(queriedInnerElements[j]);

                if (queriedPlayers && queriedPlayers.length) {
                  players.push.apply(players, _toConsumableArray(queriedPlayers));
                }
              }
            }
            /** @type {?} */


            var activePlayers = players.filter(
            /**
            * @param {?} p
            * @return {?}
            */
            function (p) {
              return !p.destroyed;
            });

            if (activePlayers.length) {
              removeNodesAfterAnimationDone(this, _element2, activePlayers);
            } else {
              this.processLeaveNode(_element2);
            }
          } // this is required so the cleanup method doesn't remove them


          allLeaveNodes.length = 0;
          rootPlayers.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            _this37.players.push(player);

            player.onDone(
            /**
            * @return {?}
            */
            function () {
              player.destroy();
              /** @type {?} */

              var index = _this37.players.indexOf(player);

              _this37.players.splice(index, 1);
            });
            player.play();
          });
          return rootPlayers;
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "elementContainsData",
        value: function elementContainsData(namespaceId, element) {
          /** @type {?} */
          var containsData = false;
          /** @type {?} */

          var details =
          /** @type {?} */
          element[REMOVAL_FLAG];
          if (details && details.setForRemoval) containsData = true;
          if (this.playersByElement.has(element)) containsData = true;
          if (this.playersByQueriedElement.has(element)) containsData = true;
          if (this.statesByElement.has(element)) containsData = true;
          return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
        }
        /**
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "afterFlush",
        value: function afterFlush(callback) {
          this._flushFns.push(callback);
        }
        /**
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "afterFlushAnimationsDone",
        value: function afterFlushAnimationsDone(callback) {
          this._whenQuietFns.push(callback);
        }
        /**
         * @private
         * @param {?} element
         * @param {?} isQueriedElement
         * @param {?=} namespaceId
         * @param {?=} triggerName
         * @param {?=} toStateValue
         * @return {?}
         */

      }, {
        key: "_getPreviousPlayers",
        value: function _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
          /** @type {?} */
          var players = [];

          if (isQueriedElement) {
            /** @type {?} */
            var queriedElementPlayers = this.playersByQueriedElement.get(element);

            if (queriedElementPlayers) {
              players = queriedElementPlayers;
            }
          } else {
            /** @type {?} */
            var elementPlayers = this.playersByElement.get(element);

            if (elementPlayers) {
              /** @type {?} */
              var isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
              elementPlayers.forEach(
              /**
              * @param {?} player
              * @return {?}
              */
              function (player) {
                if (player.queued) return;
                if (!isRemovalAnimation && player.triggerName != triggerName) return;
                players.push(player);
              });
            }
          }

          if (namespaceId || triggerName) {
            players = players.filter(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              if (namespaceId && namespaceId != player.namespaceId) return false;
              if (triggerName && triggerName != player.triggerName) return false;
              return true;
            });
          }

          return players;
        }
        /**
         * @private
         * @param {?} namespaceId
         * @param {?} instruction
         * @param {?} allPreviousPlayersMap
         * @return {?}
         */

      }, {
        key: "_beforeAnimationBuild",
        value: function _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
          var _this38 = this;

          /** @type {?} */
          var triggerName = instruction.triggerName;
          /** @type {?} */

          var rootElement = instruction.element; // when a removal animation occurs, ALL previous players are collected
          // and destroyed (even if they are outside of the current namespace)

          /** @type {?} */

          var targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
          /** @type {?} */

          var targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;

          var _iterator2 = _createForOfIteratorHelper(instruction.timelines),
              _step2;

          try {
            var _loop3 = function _loop3() {
              var timelineInstruction = _step2.value;

              /** @type {?} */
              var element = timelineInstruction.element;
              /** @type {?} */

              var isQueriedElement = element !== rootElement;
              /** @type {?} */

              var players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
              /** @type {?} */

              var previousPlayers = _this38._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);

              previousPlayers.forEach(
              /**
              * @param {?} player
              * @return {?}
              */
              function (player) {
                /** @type {?} */
                var realPlayer =
                /** @type {?} */

                /** @type {?} */
                player.getRealPlayer();

                if (realPlayer.beforeDestroy) {
                  realPlayer.beforeDestroy();
                }

                player.destroy();
                players.push(player);
              });
            };

            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              _loop3();
            } // this needs to be done so that the PRE/POST styles can be
            // computed properly without interfering with the previous animation

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          eraseStyles(rootElement, instruction.fromStyles);
        }
        /**
         * @private
         * @param {?} namespaceId
         * @param {?} instruction
         * @param {?} allPreviousPlayersMap
         * @param {?} skippedPlayersMap
         * @param {?} preStylesMap
         * @param {?} postStylesMap
         * @return {?}
         */

      }, {
        key: "_buildAnimation",
        value: function _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
          var _this39 = this;

          /** @type {?} */
          var triggerName = instruction.triggerName;
          /** @type {?} */

          var rootElement = instruction.element; // we first run this so that the previous animation player
          // data can be passed into the successive animation players

          /** @type {?} */

          var allQueriedPlayers = [];
          /** @type {?} */

          var allConsumedElements = new Set();
          /** @type {?} */

          var allSubElements = new Set();
          /** @type {?} */

          var allNewPlayers = instruction.timelines.map(
          /**
          * @param {?} timelineInstruction
          * @return {?}
          */
          function (timelineInstruction) {
            /** @type {?} */
            var element = timelineInstruction.element;
            allConsumedElements.add(element); // FIXME (matsko): make sure to-be-removed animations are removed properly

            /** @type {?} */

            var details = element[REMOVAL_FLAG];
            if (details && details.removedBeforeQueried) return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__["NoopAnimationPlayer"](timelineInstruction.duration, timelineInstruction.delay);
            /** @type {?} */

            var isQueriedElement = element !== rootElement;
            /** @type {?} */

            var previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(
            /**
            * @param {?} p
            * @return {?}
            */
            function (p) {
              return p.getRealPlayer();
            })).filter(
            /**
            * @param {?} p
            * @return {?}
            */
            function (p) {
              // the `element` is not apart of the AnimationPlayer definition, but
              // Mock/WebAnimations
              // use the element within their implementation. This will be added in Angular5 to
              // AnimationPlayer

              /** @type {?} */
              var pp =
              /** @type {?} */
              p;
              return pp.element ? pp.element === element : false;
            });
            /** @type {?} */

            var preStyles = preStylesMap.get(element);
            /** @type {?} */

            var postStyles = postStylesMap.get(element);
            /** @type {?} */

            var keyframes = normalizeKeyframes(_this39.driver, _this39._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
            /** @type {?} */

            var player = _this39._buildPlayer(timelineInstruction, keyframes, previousPlayers); // this means that this particular player belongs to a sub trigger. It is
            // important that we match this player up with the corresponding (@trigger.listener)


            if (timelineInstruction.subTimeline && skippedPlayersMap) {
              allSubElements.add(element);
            }

            if (isQueriedElement) {
              /** @type {?} */
              var wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
              wrappedPlayer.setRealPlayer(player);
              allQueriedPlayers.push(wrappedPlayer);
            }

            return player;
          });
          allQueriedPlayers.forEach(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            getOrSetAsInMap(_this39.playersByQueriedElement, player.element, []).push(player);
            player.onDone(
            /**
            * @return {?}
            */
            function () {
              return deleteOrUnsetInMap(_this39.playersByQueriedElement, player.element, player);
            });
          });
          allConsumedElements.forEach(
          /**
          * @param {?} element
          * @return {?}
          */
          function (element) {
            return addClass(element, NG_ANIMATING_CLASSNAME);
          });
          /** @type {?} */

          var player = optimizeGroupPlayer(allNewPlayers);
          player.onDestroy(
          /**
          * @return {?}
          */
          function () {
            allConsumedElements.forEach(
            /**
            * @param {?} element
            * @return {?}
            */
            function (element) {
              return removeClass(element, NG_ANIMATING_CLASSNAME);
            });
            setStyles(rootElement, instruction.toStyles);
          }); // this basically makes all of the callbacks for sub element animations
          // be dependent on the upper players for when they finish

          allSubElements.forEach(
          /**
          * @param {?} element
          * @return {?}
          */
          function (element) {
            getOrSetAsInMap(skippedPlayersMap, element, []).push(player);
          });
          return player;
        }
        /**
         * @private
         * @param {?} instruction
         * @param {?} keyframes
         * @param {?} previousPlayers
         * @return {?}
         */

      }, {
        key: "_buildPlayer",
        value: function _buildPlayer(instruction, keyframes, previousPlayers) {
          if (keyframes.length > 0) {
            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
          } // special case for when an empty transition|definition is provided
          // ... there is no point in rendering an empty animation


          return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__["NoopAnimationPlayer"](instruction.duration, instruction.delay);
        }
      }, {
        key: "queuedPlayers",
        get: function get() {
          /** @type {?} */
          var players = [];

          this._namespaceList.forEach(
          /**
          * @param {?} ns
          * @return {?}
          */
          function (ns) {
            ns.players.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              if (player.queued) {
                players.push(player);
              }
            });
          });

          return players;
        }
      }]);

      return TransitionAnimationEngine;
    }();

    if (false) {}

    var TransitionAnimationPlayer = /*#__PURE__*/function () {
      /**
       * @param {?} namespaceId
       * @param {?} triggerName
       * @param {?} element
       */
      function TransitionAnimationPlayer(namespaceId, triggerName, element) {
        _classCallCheck(this, TransitionAnimationPlayer);

        this.namespaceId = namespaceId;
        this.triggerName = triggerName;
        this.element = element;
        this._player = new _angular_animations__WEBPACK_IMPORTED_MODULE_0__["NoopAnimationPlayer"]();
        this._containsRealPlayer = false;
        this._queuedCallbacks = {};
        this.destroyed = false;
        this.markedForDestroy = false;
        this.disabled = false;
        this.queued = true;
        this.totalTime = 0;
      }
      /**
       * @param {?} player
       * @return {?}
       */


      _createClass(TransitionAnimationPlayer, [{
        key: "setRealPlayer",
        value: function setRealPlayer(player) {
          var _this40 = this;

          if (this._containsRealPlayer) return;
          this._player = player;
          Object.keys(this._queuedCallbacks).forEach(
          /**
          * @param {?} phase
          * @return {?}
          */
          function (phase) {
            _this40._queuedCallbacks[phase].forEach(
            /**
            * @param {?} callback
            * @return {?}
            */
            function (callback) {
              return listenOnPlayer(player, phase, undefined, callback);
            });
          });
          this._queuedCallbacks = {};
          this._containsRealPlayer = true;
          this.overrideTotalTime(player.totalTime);

          /** @type {?} */
          this.queued = false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getRealPlayer",
        value: function getRealPlayer() {
          return this._player;
        }
        /**
         * @param {?} totalTime
         * @return {?}
         */

      }, {
        key: "overrideTotalTime",
        value: function overrideTotalTime(totalTime) {
          /** @type {?} */
          this.totalTime = totalTime;
        }
        /**
         * @param {?} player
         * @return {?}
         */

      }, {
        key: "syncPlayerEvents",
        value: function syncPlayerEvents(player) {
          var _this41 = this;

          /** @type {?} */
          var p =
          /** @type {?} */
          this._player;

          if (p.triggerCallback) {
            player.onStart(
            /**
            * @return {?}
            */
            function () {
              return (
                /** @type {?} */
                p.triggerCallback('start')
              );
            });
          }

          player.onDone(
          /**
          * @return {?}
          */
          function () {
            return _this41.finish();
          });
          player.onDestroy(
          /**
          * @return {?}
          */
          function () {
            return _this41.destroy();
          });
        }
        /**
         * @private
         * @param {?} name
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "_queueEvent",
        value: function _queueEvent(name, callback) {
          getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDone",
        value: function onDone(fn) {
          if (this.queued) {
            this._queueEvent('done', fn);
          }

          this._player.onDone(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onStart",
        value: function onStart(fn) {
          if (this.queued) {
            this._queueEvent('start', fn);
          }

          this._player.onStart(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDestroy",
        value: function onDestroy(fn) {
          if (this.queued) {
            this._queueEvent('destroy', fn);
          }

          this._player.onDestroy(fn);
        }
        /**
         * @return {?}
         */

      }, {
        key: "init",
        value: function init() {
          this._player.init();
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasStarted",
        value: function hasStarted() {
          return this.queued ? false : this._player.hasStarted();
        }
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          !this.queued && this._player.play();
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {
          !this.queued && this._player.pause();
        }
        /**
         * @return {?}
         */

      }, {
        key: "restart",
        value: function restart() {
          !this.queued && this._player.restart();
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this._player.finish();
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          /** @type {?} */
          this.destroyed = true;

          this._player.destroy();
        }
        /**
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset() {
          !this.queued && this._player.reset();
        }
        /**
         * @param {?} p
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(p) {
          if (!this.queued) {
            this._player.setPosition(p);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          return this.queued ? 0 : this._player.getPosition();
        }
        /**
         * \@internal
         * @param {?} phaseName
         * @return {?}
         */

      }, {
        key: "triggerCallback",
        value: function triggerCallback(phaseName) {
          /** @type {?} */
          var p =
          /** @type {?} */
          this._player;

          if (p.triggerCallback) {
            p.triggerCallback(phaseName);
          }
        }
      }]);

      return TransitionAnimationPlayer;
    }();

    if (false) {}
    /**
     * @param {?} map
     * @param {?} key
     * @param {?} value
     * @return {?}
     */


    function deleteOrUnsetInMap(map, key, value) {
      /** @type {?} */
      var currentValues;

      if (map instanceof Map) {
        currentValues = map.get(key);

        if (currentValues) {
          if (currentValues.length) {
            /** @type {?} */
            var index = currentValues.indexOf(value);
            currentValues.splice(index, 1);
          }

          if (currentValues.length == 0) {
            map["delete"](key);
          }
        }
      } else {
        currentValues = map[key];

        if (currentValues) {
          if (currentValues.length) {
            /** @type {?} */
            var _index2 = currentValues.indexOf(value);

            currentValues.splice(_index2, 1);
          }

          if (currentValues.length == 0) {
            delete map[key];
          }
        }
      }

      return currentValues;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function normalizeTriggerValue(value) {
      // we use `!= null` here because it's the most simple
      // way to test against a "falsy" value without mixing
      // in empty strings or a zero value. DO NOT OPTIMIZE.
      return value != null ? value : null;
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function isElementNode(node) {
      return node && node['nodeType'] === 1;
    }
    /**
     * @param {?} eventName
     * @return {?}
     */


    function isTriggerEventValid(eventName) {
      return eventName == 'start' || eventName == 'done';
    }
    /**
     * @param {?} element
     * @param {?=} value
     * @return {?}
     */


    function cloakElement(element, value) {
      /** @type {?} */
      var oldValue = element.style.display;
      element.style.display = value != null ? value : 'none';
      return oldValue;
    }
    /**
     * @param {?} valuesMap
     * @param {?} driver
     * @param {?} elements
     * @param {?} elementPropsMap
     * @param {?} defaultStyle
     * @return {?}
     */


    function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
      /** @type {?} */
      var cloakVals = [];
      elements.forEach(
      /**
      * @param {?} element
      * @return {?}
      */
      function (element) {
        return cloakVals.push(cloakElement(element));
      });
      /** @type {?} */

      var failedElements = [];
      elementPropsMap.forEach(
      /**
      * @param {?} props
      * @param {?} element
      * @return {?}
      */
      function (props, element) {
        /** @type {?} */
        var styles = {};
        props.forEach(
        /**
        * @param {?} prop
        * @return {?}
        */
        function (prop) {
          /** @type {?} */
          var value = styles[prop] = driver.computeStyle(element, prop, defaultStyle); // there is no easy way to detect this because a sub element could be removed
          // by a parent animation element being detached.

          if (!value || value.length == 0) {
            element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
            failedElements.push(element);
          }
        });
        valuesMap.set(element, styles);
      }); // we use a index variable here since Set.forEach(a, i) does not return
      // an index value for the closure (but instead just the value)

      /** @type {?} */

      var i = 0;
      elements.forEach(
      /**
      * @param {?} element
      * @return {?}
      */
      function (element) {
        return cloakElement(element, cloakVals[i++]);
      });
      return failedElements;
    }
    /*
    Since the Angular renderer code will return a collection of inserted
    nodes in all areas of a DOM tree, it's up to this algorithm to figure
    out which nodes are roots for each animation @trigger.
    
    By placing each inserted node into a Set and traversing upwards, it
    is possible to find the @trigger elements and well any direct *star
    insertion nodes, if a @trigger root is found then the enter element
    is placed into the Map[@trigger] spot.
     */

    /**
     * @param {?} roots
     * @param {?} nodes
     * @return {?}
     */


    function buildRootMap(roots, nodes) {
      /** @type {?} */
      var rootMap = new Map();
      roots.forEach(
      /**
      * @param {?} root
      * @return {?}
      */
      function (root) {
        return rootMap.set(root, []);
      });
      if (nodes.length == 0) return rootMap;
      /** @type {?} */

      var NULL_NODE = 1;
      /** @type {?} */

      var nodeSet = new Set(nodes);
      /** @type {?} */

      var localRootMap = new Map();
      /**
       * @param {?} node
       * @return {?}
       */

      function getRoot(node) {
        if (!node) return NULL_NODE;
        /** @type {?} */

        var root = localRootMap.get(node);
        if (root) return root;
        /** @type {?} */

        var parent = node.parentNode;

        if (rootMap.has(parent)) {
          // ngIf inside @trigger
          root = parent;
        } else if (nodeSet.has(parent)) {
          // ngIf inside ngIf
          root = NULL_NODE;
        } else {
          // recurse upwards
          root = getRoot(parent);
        }

        localRootMap.set(node, root);
        return root;
      }

      nodes.forEach(
      /**
      * @param {?} node
      * @return {?}
      */
      function (node) {
        /** @type {?} */
        var root = getRoot(node);

        if (root !== NULL_NODE) {
          /** @type {?} */
          rootMap.get(root).push(node);
        }
      });
      return rootMap;
    }
    /** @type {?} */


    var CLASSES_CACHE_KEY = '$$classes';
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */

    function containsClass(element, className) {
      if (element.classList) {
        return element.classList.contains(className);
      } else {
        /** @type {?} */
        var classes = element[CLASSES_CACHE_KEY];
        return classes && classes[className];
      }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */


    function addClass(element, className) {
      if (element.classList) {
        element.classList.add(className);
      } else {
        /** @type {?} */
        var classes = element[CLASSES_CACHE_KEY];

        if (!classes) {
          classes = element[CLASSES_CACHE_KEY] = {};
        }

        classes[className] = true;
      }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */


    function removeClass(element, className) {
      if (element.classList) {
        element.classList.remove(className);
      } else {
        /** @type {?} */
        var classes = element[CLASSES_CACHE_KEY];

        if (classes) {
          delete classes[className];
        }
      }
    }
    /**
     * @param {?} engine
     * @param {?} element
     * @param {?} players
     * @return {?}
     */


    function removeNodesAfterAnimationDone(engine, element, players) {
      optimizeGroupPlayer(players).onDone(
      /**
      * @return {?}
      */
      function () {
        return engine.processLeaveNode(element);
      });
    }
    /**
     * @param {?} players
     * @return {?}
     */


    function flattenGroupPlayers(players) {
      /** @type {?} */
      var finalPlayers = [];

      _flattenGroupPlayersRecur(players, finalPlayers);

      return finalPlayers;
    }
    /**
     * @param {?} players
     * @param {?} finalPlayers
     * @return {?}
     */


    function _flattenGroupPlayersRecur(players, finalPlayers) {
      for (var i = 0; i < players.length; i++) {
        /** @type {?} */
        var player = players[i];

        if (player instanceof _angular_animations__WEBPACK_IMPORTED_MODULE_0__["ɵAnimationGroupPlayer"]) {
          _flattenGroupPlayersRecur(player.players, finalPlayers);
        } else {
          finalPlayers.push(player);
        }
      }
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function objEquals(a, b) {
      /** @type {?} */
      var k1 = Object.keys(a);
      /** @type {?} */

      var k2 = Object.keys(b);
      if (k1.length != k2.length) return false;

      for (var i = 0; i < k1.length; i++) {
        /** @type {?} */
        var prop = k1[i];
        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;
      }

      return true;
    }
    /**
     * @param {?} element
     * @param {?} allPreStyleElements
     * @param {?} allPostStyleElements
     * @return {?}
     */


    function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
      /** @type {?} */
      var postEntry = allPostStyleElements.get(element);
      if (!postEntry) return false;
      /** @type {?} */

      var preEntry = allPreStyleElements.get(element);

      if (preEntry) {
        postEntry.forEach(
        /**
        * @param {?} data
        * @return {?}
        */
        function (data) {
          return (
            /** @type {?} */
            preEntry.add(data)
          );
        });
      } else {
        allPreStyleElements.set(element, postEntry);
      }

      allPostStyleElements["delete"](element);
      return true;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/animation_engine_next.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var AnimationEngine = /*#__PURE__*/function () {
      /**
       * @param {?} bodyNode
       * @param {?} _driver
       * @param {?} normalizer
       */
      function AnimationEngine(bodyNode, _driver, normalizer) {
        var _this42 = this;

        _classCallCheck(this, AnimationEngine);

        this.bodyNode = bodyNode;
        this._driver = _driver;
        this._triggerCache = {}; // this method is designed to be overridden by the code that uses this engine

        this.onRemovalComplete =
        /**
        * @param {?} element
        * @param {?} context
        * @return {?}
        */
        function (element, context) {};

        this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, normalizer);
        this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, normalizer);

        this._transitionEngine.onRemovalComplete =
        /**
        * @param {?} element
        * @param {?} context
        * @return {?}
        */
        function (element, context) {
          return _this42.onRemovalComplete(element, context);
        };
      }
      /**
       * @param {?} componentId
       * @param {?} namespaceId
       * @param {?} hostElement
       * @param {?} name
       * @param {?} metadata
       * @return {?}
       */


      _createClass(AnimationEngine, [{
        key: "registerTrigger",
        value: function registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
          /** @type {?} */
          var cacheKey = componentId + '-' + name;
          /** @type {?} */

          var trigger = this._triggerCache[cacheKey];

          if (!trigger) {
            /** @type {?} */
            var errors = [];
            /** @type {?} */

            var ast =
            /** @type {?} */
            buildAnimationAst(this._driver,
            /** @type {?} */
            metadata, errors);

            if (errors.length) {
              throw new Error("The animation trigger \"".concat(name, "\" has failed to build due to the following errors:\n - ").concat(errors.join('\n - ')));
            }

            trigger = buildTrigger(name, ast);
            this._triggerCache[cacheKey] = trigger;
          }

          this._transitionEngine.registerTrigger(namespaceId, name, trigger);
        }
        /**
         * @param {?} namespaceId
         * @param {?} hostElement
         * @return {?}
         */

      }, {
        key: "register",
        value: function register(namespaceId, hostElement) {
          this._transitionEngine.register(namespaceId, hostElement);
        }
        /**
         * @param {?} namespaceId
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy(namespaceId, context) {
          this._transitionEngine.destroy(namespaceId, context);
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} parent
         * @param {?} insertBefore
         * @return {?}
         */

      }, {
        key: "onInsert",
        value: function onInsert(namespaceId, element, parent, insertBefore) {
          this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} context
         * @param {?=} isHostElement
         * @return {?}
         */

      }, {
        key: "onRemove",
        value: function onRemove(namespaceId, element, context, isHostElement) {
          this._transitionEngine.removeNode(namespaceId, element, isHostElement || false, context);
        }
        /**
         * @param {?} element
         * @param {?} disable
         * @return {?}
         */

      }, {
        key: "disableAnimations",
        value: function disableAnimations(element, disable) {
          this._transitionEngine.markElementAsDisabled(element, disable);
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} property
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "process",
        value: function process(namespaceId, element, property, value) {
          if (property.charAt(0) == '@') {
            var _parseTimelineCommand = parseTimelineCommand(property),
                _parseTimelineCommand2 = _slicedToArray(_parseTimelineCommand, 2),
                id = _parseTimelineCommand2[0],
                action = _parseTimelineCommand2[1];
            /** @type {?} */


            var args =
            /** @type {?} */
            value;

            this._timelineEngine.command(id, element, action, args);
          } else {
            this._transitionEngine.trigger(namespaceId, element, property, value);
          }
        }
        /**
         * @param {?} namespaceId
         * @param {?} element
         * @param {?} eventName
         * @param {?} eventPhase
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "listen",
        value: function listen(namespaceId, element, eventName, eventPhase, callback) {
          // @@listen
          if (eventName.charAt(0) == '@') {
            var _parseTimelineCommand3 = parseTimelineCommand(eventName),
                _parseTimelineCommand4 = _slicedToArray(_parseTimelineCommand3, 2),
                id = _parseTimelineCommand4[0],
                action = _parseTimelineCommand4[1];

            return this._timelineEngine.listen(id, element, action, callback);
          }

          return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
        }
        /**
         * @param {?=} microtaskId
         * @return {?}
         */

      }, {
        key: "flush",
        value: function flush() {
          var microtaskId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

          this._transitionEngine.flush(microtaskId);
        }
        /**
         * @return {?}
         */

      }, {
        key: "whenRenderingDone",

        /**
         * @return {?}
         */
        value: function whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone();
        }
      }, {
        key: "players",
        get: function get() {
          return (
            /** @type {?} */
            this._transitionEngine.players.concat(
            /** @type {?} */
            this._timelineEngine.players)
          );
        }
      }]);

      return AnimationEngine;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/special_cased_styles.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns an instance of `SpecialCasedStyles` if and when any special (non animateable) styles are
     * detected.
     *
     * In CSS there exist properties that cannot be animated within a keyframe animation
     * (whether it be via CSS keyframes or web-animations) and the animation implementation
     * will ignore them. This function is designed to detect those special cased styles and
     * return a container that will be executed at the start and end of the animation.
     *
     * @param {?} element
     * @param {?} styles
     * @return {?} an instance of `SpecialCasedStyles` if any special styles are detected otherwise `null`
     */


    function packageNonAnimatableStyles(element, styles) {
      /** @type {?} */
      var startStyles = null;
      /** @type {?} */

      var endStyles = null;

      if (Array.isArray(styles) && styles.length) {
        startStyles = filterNonAnimatableStyles(styles[0]);

        if (styles.length > 1) {
          endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);
        }
      } else if (styles) {
        startStyles = filterNonAnimatableStyles(styles);
      }

      return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
    }
    /**
     * Designed to be executed during a keyframe-based animation to apply any special-cased styles.
     *
     * When started (when the `start()` method is run) then the provided `startStyles`
     * will be applied. When finished (when the `finish()` method is called) the
     * `endStyles` will be applied as well any any starting styles. Finally when
     * `destroy()` is called then all styles will be removed.
     */


    var SpecialCasedStyles = /*#__PURE__*/function () {
      /**
       * @param {?} _element
       * @param {?} _startStyles
       * @param {?} _endStyles
       */
      function SpecialCasedStyles(_element, _startStyles, _endStyles) {
        _classCallCheck(this, SpecialCasedStyles);

        this._element = _element;
        this._startStyles = _startStyles;
        this._endStyles = _endStyles;
        this._state = 0
        /* Pending */
        ;
        /** @type {?} */

        var initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);

        if (!initialStyles) {
          SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = {});
        }

        this._initialStyles = initialStyles;
      }
      /**
       * @return {?}
       */


      _createClass(SpecialCasedStyles, [{
        key: "start",
        value: function start() {
          if (this._state < 1
          /* Started */
          ) {
              if (this._startStyles) {
                setStyles(this._element, this._startStyles, this._initialStyles);
              }

              this._state = 1
              /* Started */
              ;
            }
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this.start();

          if (this._state < 2
          /* Finished */
          ) {
              setStyles(this._element, this._initialStyles);

              if (this._endStyles) {
                setStyles(this._element, this._endStyles);
                this._endStyles = null;
              }

              this._state = 1
              /* Started */
              ;
            }
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.finish();

          if (this._state < 3
          /* Destroyed */
          ) {
              SpecialCasedStyles.initialStylesByElement["delete"](this._element);

              if (this._startStyles) {
                eraseStyles(this._element, this._startStyles);
                this._endStyles = null;
              }

              if (this._endStyles) {
                eraseStyles(this._element, this._endStyles);
                this._endStyles = null;
              }

              setStyles(this._element, this._initialStyles);
              this._state = 3
              /* Destroyed */
              ;
            }
        }
      }]);

      return SpecialCasedStyles;
    }();

    SpecialCasedStyles.initialStylesByElement = new WeakMap();

    if (false) {}
    /** @enum {number} */


    var SpecialCasedStylesState = {
      Pending: 0,
      Started: 1,
      Finished: 2,
      Destroyed: 3
    };
    /**
     * @param {?} styles
     * @return {?}
     */

    function filterNonAnimatableStyles(styles) {
      /** @type {?} */
      var result = null;
      /** @type {?} */

      var props = Object.keys(styles);

      for (var i = 0; i < props.length; i++) {
        /** @type {?} */
        var prop = props[i];

        if (isNonAnimatableStyle(prop)) {
          result = result || {};
          result[prop] = styles[prop];
        }
      }

      return result;
    }
    /**
     * @param {?} prop
     * @return {?}
     */


    function isNonAnimatableStyle(prop) {
      return prop === 'display' || prop === 'position';
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/css_keyframes/element_animation_style_handler.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     * @type {?}
     */


    var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
    /** @type {?} */

    var ANIMATION_PROP = 'animation';
    /** @type {?} */

    var ANIMATIONEND_EVENT = 'animationend';
    /** @type {?} */

    var ONE_SECOND$1 = 1000;

    var ElementAnimationStyleHandler = /*#__PURE__*/function () {
      /**
       * @param {?} _element
       * @param {?} _name
       * @param {?} _duration
       * @param {?} _delay
       * @param {?} _easing
       * @param {?} _fillMode
       * @param {?} _onDoneFn
       */
      function ElementAnimationStyleHandler(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {
        var _this43 = this;

        _classCallCheck(this, ElementAnimationStyleHandler);

        this._element = _element;
        this._name = _name;
        this._duration = _duration;
        this._delay = _delay;
        this._easing = _easing;
        this._fillMode = _fillMode;
        this._onDoneFn = _onDoneFn;
        this._finished = false;
        this._destroyed = false;
        this._startTime = 0;
        this._position = 0;

        this._eventFn =
        /**
        * @param {?} e
        * @return {?}
        */
        function (e) {
          return _this43._handleCallback(e);
        };
      }
      /**
       * @return {?}
       */


      _createClass(ElementAnimationStyleHandler, [{
        key: "apply",
        value: function apply() {
          applyKeyframeAnimation(this._element, "".concat(this._duration, "ms ").concat(this._easing, " ").concat(this._delay, "ms 1 normal ").concat(this._fillMode, " ").concat(this._name));
          addRemoveAnimationEvent(this._element, this._eventFn, false);
          this._startTime = Date.now();
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {
          playPauseAnimation(this._element, this._name, 'paused');
        }
        /**
         * @return {?}
         */

      }, {
        key: "resume",
        value: function resume() {
          playPauseAnimation(this._element, this._name, 'running');
        }
        /**
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(position) {
          /** @type {?} */
          var index = findIndexForAnimation(this._element, this._name);
          this._position = position * this._duration;
          setAnimationStyle(this._element, 'Delay', "-".concat(this._position, "ms"), index);
        }
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          return this._position;
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleCallback",
        value: function _handleCallback(event) {
          /** @type {?} */
          var timestamp = event._ngTestManualTimestamp || Date.now();
          /** @type {?} */

          var elapsedTime = parseFloat(event.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)) * ONE_SECOND$1;

          if (event.animationName == this._name && Math.max(timestamp - this._startTime, 0) >= this._delay && elapsedTime >= this._duration) {
            this.finish();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          if (this._finished) return;
          this._finished = true;

          this._onDoneFn();

          addRemoveAnimationEvent(this._element, this._eventFn, true);
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          if (this._destroyed) return;
          this._destroyed = true;
          this.finish();
          removeKeyframeAnimation(this._element, this._name);
        }
      }]);

      return ElementAnimationStyleHandler;
    }();

    if (false) {}
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} status
     * @return {?}
     */


    function playPauseAnimation(element, name, status) {
      /** @type {?} */
      var index = findIndexForAnimation(element, name);
      setAnimationStyle(element, 'PlayState', status, index);
    }
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */


    function applyKeyframeAnimation(element, value) {
      /** @type {?} */
      var anim = getAnimationStyle(element, '').trim();
      /** @type {?} */

      var index = 0;

      if (anim.length) {
        index = countChars(anim, ',') + 1;
        value = "".concat(anim, ", ").concat(value);
      }

      setAnimationStyle(element, '', value);
      return index;
    }
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */


    function removeKeyframeAnimation(element, name) {
      /** @type {?} */
      var anim = getAnimationStyle(element, '');
      /** @type {?} */

      var tokens = anim.split(',');
      /** @type {?} */

      var index = findMatchingTokenIndex(tokens, name);

      if (index >= 0) {
        tokens.splice(index, 1);
        /** @type {?} */

        var newValue = tokens.join(',');
        setAnimationStyle(element, '', newValue);
      }
    }
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */


    function findIndexForAnimation(element, value) {
      /** @type {?} */
      var anim = getAnimationStyle(element, '');

      if (anim.indexOf(',') > 0) {
        /** @type {?} */
        var tokens = anim.split(',');
        return findMatchingTokenIndex(tokens, value);
      }

      return findMatchingTokenIndex([anim], value);
    }
    /**
     * @param {?} tokens
     * @param {?} searchToken
     * @return {?}
     */


    function findMatchingTokenIndex(tokens, searchToken) {
      for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].indexOf(searchToken) >= 0) {
          return i;
        }
      }

      return -1;
    }
    /**
     * @param {?} element
     * @param {?} fn
     * @param {?} doRemove
     * @return {?}
     */


    function addRemoveAnimationEvent(element, fn, doRemove) {
      doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) : element.addEventListener(ANIMATIONEND_EVENT, fn);
    }
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @param {?=} index
     * @return {?}
     */


    function setAnimationStyle(element, name, value, index) {
      /** @type {?} */
      var prop = ANIMATION_PROP + name;

      if (index != null) {
        /** @type {?} */
        var oldValue = element.style[prop];

        if (oldValue.length) {
          /** @type {?} */
          var tokens = oldValue.split(',');
          tokens[index] = value;
          value = tokens.join(',');
        }
      }

      element.style[prop] = value;
    }
    /**
     * @param {?} element
     * @param {?} name
     * @return {?}
     */


    function getAnimationStyle(element, name) {
      return element.style[ANIMATION_PROP + name];
    }
    /**
     * @param {?} value
     * @param {?} char
     * @return {?}
     */


    function countChars(value, _char) {
      /** @type {?} */
      var count = 0;

      for (var i = 0; i < value.length; i++) {
        /** @type {?} */
        var c = value.charAt(i);
        if (c === _char) count++;
      }

      return count;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/css_keyframes/css_keyframes_player.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var DEFAULT_FILL_MODE = 'forwards';
    /** @type {?} */

    var DEFAULT_EASING = 'linear';
    /** @enum {number} */

    var AnimatorControlState = {
      INITIALIZED: 1,
      STARTED: 2,
      FINISHED: 3,
      DESTROYED: 4
    };

    var CssKeyframesPlayer = /*#__PURE__*/function () {
      /**
       * @param {?} element
       * @param {?} keyframes
       * @param {?} animationName
       * @param {?} _duration
       * @param {?} _delay
       * @param {?} easing
       * @param {?} _finalStyles
       * @param {?=} _specialStyles
       */
      function CssKeyframesPlayer(element, keyframes, animationName, _duration, _delay, easing, _finalStyles, _specialStyles) {
        _classCallCheck(this, CssKeyframesPlayer);

        this.element = element;
        this.keyframes = keyframes;
        this.animationName = animationName;
        this._duration = _duration;
        this._delay = _delay;
        this._finalStyles = _finalStyles;
        this._specialStyles = _specialStyles;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._started = false;
        this.currentSnapshot = {};
        this._state = 0;
        this.easing = easing || DEFAULT_EASING;
        this.totalTime = _duration + _delay;

        this._buildStyler();
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      _createClass(CssKeyframesPlayer, [{
        key: "onStart",
        value: function onStart(fn) {
          this._onStartFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDone",
        value: function onDone(fn) {
          this._onDoneFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDestroy",
        value: function onDestroy(fn) {
          this._onDestroyFns.push(fn);
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.init();
          if (this._state >= 4
          /* DESTROYED */
          ) return;
          this._state = 4
          /* DESTROYED */
          ;

          this._styler.destroy();

          this._flushStartFns();

          this._flushDoneFns();

          if (this._specialStyles) {
            this._specialStyles.destroy();
          }

          this._onDestroyFns.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });

          this._onDestroyFns = [];
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_flushDoneFns",
        value: function _flushDoneFns() {
          this._onDoneFns.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });

          this._onDoneFns = [];
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_flushStartFns",
        value: function _flushStartFns() {
          this._onStartFns.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });

          this._onStartFns = [];
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this.init();
          if (this._state >= 3
          /* FINISHED */
          ) return;
          this._state = 3
          /* FINISHED */
          ;

          this._styler.finish();

          this._flushStartFns();

          if (this._specialStyles) {
            this._specialStyles.finish();
          }

          this._flushDoneFns();
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(value) {
          this._styler.setPosition(value);
        }
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          return this._styler.getPosition();
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasStarted",
        value: function hasStarted() {
          return this._state >= 2
          /* STARTED */
          ;
        }
        /**
         * @return {?}
         */

      }, {
        key: "init",
        value: function init() {
          if (this._state >= 1
          /* INITIALIZED */
          ) return;
          this._state = 1
          /* INITIALIZED */
          ;
          /** @type {?} */

          var elm = this.element;

          this._styler.apply();

          if (this._delay) {
            this._styler.pause();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          this.init();

          if (!this.hasStarted()) {
            this._flushStartFns();

            this._state = 2
            /* STARTED */
            ;

            if (this._specialStyles) {
              this._specialStyles.start();
            }
          }

          this._styler.resume();
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {
          this.init();

          this._styler.pause();
        }
        /**
         * @return {?}
         */

      }, {
        key: "restart",
        value: function restart() {
          this.reset();
          this.play();
        }
        /**
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset() {
          this._styler.destroy();

          this._buildStyler();

          this._styler.apply();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_buildStyler",
        value: function _buildStyler() {
          var _this44 = this;

          this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, DEFAULT_FILL_MODE,
          /**
          * @return {?}
          */
          function () {
            return _this44.finish();
          });
        }
        /**
         * \@internal
         * @param {?} phaseName
         * @return {?}
         */

      }, {
        key: "triggerCallback",
        value: function triggerCallback(phaseName) {
          /** @type {?} */
          var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
          methods.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });
          methods.length = 0;
        }
        /**
         * @return {?}
         */

      }, {
        key: "beforeDestroy",
        value: function beforeDestroy() {
          var _this45 = this;

          this.init();
          /** @type {?} */

          var styles = {};

          if (this.hasStarted()) {
            /** @type {?} */
            var finished = this._state >= 3
            /* FINISHED */
            ;
            Object.keys(this._finalStyles).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              if (prop != 'offset') {
                styles[prop] = finished ? _this45._finalStyles[prop] : computeStyle(_this45.element, prop);
              }
            });
          }

          this.currentSnapshot = styles;
        }
      }]);

      return CssKeyframesPlayer;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/css_keyframes/direct_style_player.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var DirectStylePlayer = /*#__PURE__*/function (_angular_animations__) {
      _inherits(DirectStylePlayer, _angular_animations__);

      var _super3 = _createSuper(DirectStylePlayer);

      /**
       * @param {?} element
       * @param {?} styles
       */
      function DirectStylePlayer(element, styles) {
        var _this46;

        _classCallCheck(this, DirectStylePlayer);

        _this46 = _super3.call(this);
        _this46.element = element;
        _this46._startingStyles = {};
        _this46.__initialized = false;
        _this46._styles = hypenatePropsObject(styles);
        return _this46;
      }
      /**
       * @return {?}
       */


      _createClass(DirectStylePlayer, [{
        key: "init",
        value: function init() {
          var _this47 = this;

          if (this.__initialized || !this._startingStyles) return;
          this.__initialized = true;
          Object.keys(this._styles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            /** @type {?} */
            _this47._startingStyles[prop] = _this47.element.style[prop];
          });

          _get(_getPrototypeOf(DirectStylePlayer.prototype), "init", this).call(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          var _this48 = this;

          if (!this._startingStyles) return;
          this.init();
          Object.keys(this._styles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            return _this48.element.style.setProperty(prop, _this48._styles[prop]);
          });

          _get(_getPrototypeOf(DirectStylePlayer.prototype), "play", this).call(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this49 = this;

          if (!this._startingStyles) return;
          Object.keys(this._startingStyles).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            /** @type {?} */
            var value =
            /** @type {?} */
            _this49._startingStyles[prop];

            if (value) {
              _this49.element.style.setProperty(prop, value);
            } else {
              _this49.element.style.removeProperty(prop);
            }
          });
          this._startingStyles = null;

          _get(_getPrototypeOf(DirectStylePlayer.prototype), "destroy", this).call(this);
        }
      }]);

      return DirectStylePlayer;
    }(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["NoopAnimationPlayer"]);

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/css_keyframes/css_keyframes_driver.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var KEYFRAMES_NAME_PREFIX = 'gen_css_kf_';
    /** @type {?} */

    var TAB_SPACE = ' ';

    var CssKeyframesDriver = /*#__PURE__*/function () {
      function CssKeyframesDriver() {
        _classCallCheck(this, CssKeyframesDriver);

        this._count = 0;
        this._head = document.querySelector('head');
        this._warningIssued = false;
      }
      /**
       * @param {?} prop
       * @return {?}
       */


      _createClass(CssKeyframesDriver, [{
        key: "validateStyleProperty",
        value: function validateStyleProperty(prop) {
          return _validateStyleProperty(prop);
        }
        /**
         * @param {?} element
         * @param {?} selector
         * @return {?}
         */

      }, {
        key: "matchesElement",
        value: function matchesElement(element, selector) {
          return _matchesElement(element, selector);
        }
        /**
         * @param {?} elm1
         * @param {?} elm2
         * @return {?}
         */

      }, {
        key: "containsElement",
        value: function containsElement(elm1, elm2) {
          return _containsElement(elm1, elm2);
        }
        /**
         * @param {?} element
         * @param {?} selector
         * @param {?} multi
         * @return {?}
         */

      }, {
        key: "query",
        value: function query(element, selector, multi) {
          return invokeQuery(element, selector, multi);
        }
        /**
         * @param {?} element
         * @param {?} prop
         * @param {?=} defaultValue
         * @return {?}
         */

      }, {
        key: "computeStyle",
        value: function computeStyle(element, prop, defaultValue) {
          return (
            /** @type {?} */

            /** @type {?} */
            window.getComputedStyle(element)[prop]
          );
        }
        /**
         * @param {?} element
         * @param {?} name
         * @param {?} keyframes
         * @return {?}
         */

      }, {
        key: "buildKeyframeElement",
        value: function buildKeyframeElement(element, name, keyframes) {
          keyframes = keyframes.map(
          /**
          * @param {?} kf
          * @return {?}
          */
          function (kf) {
            return hypenatePropsObject(kf);
          });
          /** @type {?} */

          var keyframeStr = "@keyframes ".concat(name, " {\n");
          /** @type {?} */

          var tab = '';
          keyframes.forEach(
          /**
          * @param {?} kf
          * @return {?}
          */
          function (kf) {
            tab = TAB_SPACE;
            /** @type {?} */

            var offset = parseFloat(kf['offset']);
            keyframeStr += "".concat(tab).concat(offset * 100, "% {\n");
            tab += TAB_SPACE;
            Object.keys(kf).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              /** @type {?} */
              var value = kf[prop];

              switch (prop) {
                case 'offset':
                  return;

                case 'easing':
                  if (value) {
                    keyframeStr += "".concat(tab, "animation-timing-function: ").concat(value, ";\n");
                  }

                  return;

                default:
                  keyframeStr += "".concat(tab).concat(prop, ": ").concat(value, ";\n");
                  return;
              }
            });
            keyframeStr += "".concat(tab, "}\n");
          });
          keyframeStr += "}\n";
          /** @type {?} */

          var kfElm = document.createElement('style');
          kfElm.innerHTML = keyframeStr;
          return kfElm;
        }
        /**
         * @param {?} element
         * @param {?} keyframes
         * @param {?} duration
         * @param {?} delay
         * @param {?} easing
         * @param {?=} previousPlayers
         * @param {?=} scrubberAccessRequested
         * @return {?}
         */

      }, {
        key: "animate",
        value: function animate(element, keyframes, duration, delay, easing) {
          var previousPlayers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
          var scrubberAccessRequested = arguments.length > 6 ? arguments[6] : undefined;

          if (scrubberAccessRequested) {
            this._notifyFaultyScrubber();
          }
          /** @type {?} */


          var previousCssKeyframePlayers =
          /** @type {?} */
          previousPlayers.filter(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player instanceof CssKeyframesPlayer;
          });
          /** @type {?} */

          var previousStyles = {};

          if (allowPreviousPlayerStylesMerge(duration, delay)) {
            previousCssKeyframePlayers.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              /** @type {?} */
              var styles = player.currentSnapshot;
              Object.keys(styles).forEach(
              /**
              * @param {?} prop
              * @return {?}
              */
              function (prop) {
                return previousStyles[prop] = styles[prop];
              });
            });
          }

          keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);
          /** @type {?} */

          var finalStyles = flattenKeyframesIntoStyles(keyframes); // if there is no animation then there is no point in applying
          // styles and waiting for an event to get fired. This causes lag.
          // It's better to just directly apply the styles to the element
          // via the direct styling animation player.

          if (duration == 0) {
            return new DirectStylePlayer(element, finalStyles);
          }
          /** @type {?} */


          var animationName = "".concat(KEYFRAMES_NAME_PREFIX).concat(this._count++);
          /** @type {?} */

          var kfElm = this.buildKeyframeElement(element, animationName, keyframes);

          /** @type {?} */
          document.querySelector('head').appendChild(kfElm);
          /** @type {?} */

          var specialStyles = packageNonAnimatableStyles(element, keyframes);
          /** @type {?} */

          var player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles, specialStyles);
          player.onDestroy(
          /**
          * @return {?}
          */
          function () {
            return removeElement(kfElm);
          });
          return player;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_notifyFaultyScrubber",
        value: function _notifyFaultyScrubber() {
          if (!this._warningIssued) {
            console.warn('@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n', '  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill.');
            this._warningIssued = true;
          }
        }
      }]);

      return CssKeyframesDriver;
    }();

    if (false) {}
    /**
     * @param {?} keyframes
     * @return {?}
     */


    function flattenKeyframesIntoStyles(keyframes) {
      /** @type {?} */
      var flatKeyframes = {};

      if (keyframes) {
        /** @type {?} */
        var kfs = Array.isArray(keyframes) ? keyframes : [keyframes];
        kfs.forEach(
        /**
        * @param {?} kf
        * @return {?}
        */
        function (kf) {
          Object.keys(kf).forEach(
          /**
          * @param {?} prop
          * @return {?}
          */
          function (prop) {
            if (prop == 'offset' || prop == 'easing') return;
            flatKeyframes[prop] = kf[prop];
          });
        });
      }

      return flatKeyframes;
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function removeElement(node) {
      node.parentNode.removeChild(node);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/web_animations/web_animations_player.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var WebAnimationsPlayer = /*#__PURE__*/function () {
      /**
       * @param {?} element
       * @param {?} keyframes
       * @param {?} options
       * @param {?=} _specialStyles
       */
      function WebAnimationsPlayer(element, keyframes, options, _specialStyles) {
        _classCallCheck(this, WebAnimationsPlayer);

        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this._specialStyles = _specialStyles;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._initialized = false;
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this.time = 0;
        this.parentPlayer = null;
        this.currentSnapshot = {};
        this._duration =
        /** @type {?} */
        options['duration'];
        this._delay =
        /** @type {?} */
        options['delay'] || 0;
        this.time = this._duration + this._delay;
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(WebAnimationsPlayer, [{
        key: "_onFinish",
        value: function _onFinish() {
          if (!this._finished) {
            this._finished = true;

            this._onDoneFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onDoneFns = [];
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "init",
        value: function init() {
          this._buildPlayer();

          this._preparePlayerBeforeStart();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_buildPlayer",
        value: function _buildPlayer() {
          var _this50 = this;

          if (this._initialized) return;
          this._initialized = true;
          /** @type {?} */

          var keyframes = this.keyframes;

          /** @type {?} */
          this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options);
          this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
          this.domPlayer.addEventListener('finish',
          /**
          * @return {?}
          */
          function () {
            return _this50._onFinish();
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_preparePlayerBeforeStart",
        value: function _preparePlayerBeforeStart() {
          // this is required so that the player doesn't start to animate right away
          if (this._delay) {
            this._resetDomPlayerState();
          } else {
            this.domPlayer.pause();
          }
        }
        /**
         * \@internal
         * @param {?} element
         * @param {?} keyframes
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "_triggerWebAnimation",
        value: function _triggerWebAnimation(element, keyframes, options) {
          // jscompiler doesn't seem to know animate is a native property because it's not fully
          // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
          return (
            /** @type {?} */
            element['animate'](keyframes, options)
          );
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onStart",
        value: function onStart(fn) {
          this._onStartFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDone",
        value: function onDone(fn) {
          this._onDoneFns.push(fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDestroy",
        value: function onDestroy(fn) {
          this._onDestroyFns.push(fn);
        }
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          this._buildPlayer();

          if (!this.hasStarted()) {
            this._onStartFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onStartFns = [];
            this._started = true;

            if (this._specialStyles) {
              this._specialStyles.start();
            }
          }

          this.domPlayer.play();
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {
          this.init();
          this.domPlayer.pause();
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this.init();

          if (this._specialStyles) {
            this._specialStyles.finish();
          }

          this._onFinish();

          this.domPlayer.finish();
        }
        /**
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset() {
          this._resetDomPlayerState();

          this._destroyed = false;
          this._finished = false;
          this._started = false;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_resetDomPlayerState",
        value: function _resetDomPlayerState() {
          if (this.domPlayer) {
            this.domPlayer.cancel();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "restart",
        value: function restart() {
          this.reset();
          this.play();
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasStarted",
        value: function hasStarted() {
          return this._started;
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          if (!this._destroyed) {
            this._destroyed = true;

            this._resetDomPlayerState();

            this._onFinish();

            if (this._specialStyles) {
              this._specialStyles.destroy();
            }

            this._onDestroyFns.forEach(
            /**
            * @param {?} fn
            * @return {?}
            */
            function (fn) {
              return fn();
            });

            this._onDestroyFns = [];
          }
        }
        /**
         * @param {?} p
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(p) {
          this.domPlayer.currentTime = p * this.time;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          return this.domPlayer.currentTime / this.time;
        }
        /**
         * @return {?}
         */

      }, {
        key: "beforeDestroy",

        /**
         * @return {?}
         */
        value: function beforeDestroy() {
          var _this51 = this;

          /** @type {?} */
          var styles = {};

          if (this.hasStarted()) {
            Object.keys(this._finalKeyframe).forEach(
            /**
            * @param {?} prop
            * @return {?}
            */
            function (prop) {
              if (prop != 'offset') {
                styles[prop] = _this51._finished ? _this51._finalKeyframe[prop] : computeStyle(_this51.element, prop);
              }
            });
          }

          this.currentSnapshot = styles;
        }
        /**
         * \@internal
         * @param {?} phaseName
         * @return {?}
         */

      }, {
        key: "triggerCallback",
        value: function triggerCallback(phaseName) {
          /** @type {?} */
          var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
          methods.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          function (fn) {
            return fn();
          });
          methods.length = 0;
        }
      }, {
        key: "totalTime",
        get: function get() {
          return this._delay + this._duration;
        }
      }]);

      return WebAnimationsPlayer;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/render/web_animations/web_animations_driver.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var WebAnimationsDriver = /*#__PURE__*/function () {
      function WebAnimationsDriver() {
        _classCallCheck(this, WebAnimationsDriver);

        this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(getElementAnimateFn().toString());
        this._cssKeyframesDriver = new CssKeyframesDriver();
      }
      /**
       * @param {?} prop
       * @return {?}
       */


      _createClass(WebAnimationsDriver, [{
        key: "validateStyleProperty",
        value: function validateStyleProperty(prop) {
          return _validateStyleProperty(prop);
        }
        /**
         * @param {?} element
         * @param {?} selector
         * @return {?}
         */

      }, {
        key: "matchesElement",
        value: function matchesElement(element, selector) {
          return _matchesElement(element, selector);
        }
        /**
         * @param {?} elm1
         * @param {?} elm2
         * @return {?}
         */

      }, {
        key: "containsElement",
        value: function containsElement(elm1, elm2) {
          return _containsElement(elm1, elm2);
        }
        /**
         * @param {?} element
         * @param {?} selector
         * @param {?} multi
         * @return {?}
         */

      }, {
        key: "query",
        value: function query(element, selector, multi) {
          return invokeQuery(element, selector, multi);
        }
        /**
         * @param {?} element
         * @param {?} prop
         * @param {?=} defaultValue
         * @return {?}
         */

      }, {
        key: "computeStyle",
        value: function computeStyle(element, prop, defaultValue) {
          return (
            /** @type {?} */

            /** @type {?} */
            window.getComputedStyle(element)[prop]
          );
        }
        /**
         * @param {?} supported
         * @return {?}
         */

      }, {
        key: "overrideWebAnimationsSupport",
        value: function overrideWebAnimationsSupport(supported) {
          this._isNativeImpl = supported;
        }
        /**
         * @param {?} element
         * @param {?} keyframes
         * @param {?} duration
         * @param {?} delay
         * @param {?} easing
         * @param {?=} previousPlayers
         * @param {?=} scrubberAccessRequested
         * @return {?}
         */

      }, {
        key: "animate",
        value: function animate(element, keyframes, duration, delay, easing) {
          var previousPlayers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
          var scrubberAccessRequested = arguments.length > 6 ? arguments[6] : undefined;

          /** @type {?} */
          var useKeyframes = !scrubberAccessRequested && !this._isNativeImpl;

          if (useKeyframes) {
            return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);
          }
          /** @type {?} */


          var fill = delay == 0 ? 'both' : 'forwards';
          /** @type {?} */

          var playerOptions = {
            duration: duration,
            delay: delay,
            fill: fill
          }; // we check for this to avoid having a null|undefined value be present
          // for the easing (which results in an error for certain browsers #9752)

          if (easing) {
            playerOptions['easing'] = easing;
          }
          /** @type {?} */


          var previousStyles = {};
          /** @type {?} */

          var previousWebAnimationPlayers =
          /** @type {?} */
          previousPlayers.filter(
          /**
          * @param {?} player
          * @return {?}
          */
          function (player) {
            return player instanceof WebAnimationsPlayer;
          });

          if (allowPreviousPlayerStylesMerge(duration, delay)) {
            previousWebAnimationPlayers.forEach(
            /**
            * @param {?} player
            * @return {?}
            */
            function (player) {
              /** @type {?} */
              var styles = player.currentSnapshot;
              Object.keys(styles).forEach(
              /**
              * @param {?} prop
              * @return {?}
              */
              function (prop) {
                return previousStyles[prop] = styles[prop];
              });
            });
          }

          keyframes = keyframes.map(
          /**
          * @param {?} styles
          * @return {?}
          */
          function (styles) {
            return copyStyles(styles, false);
          });
          keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);
          /** @type {?} */

          var specialStyles = packageNonAnimatableStyles(element, keyframes);
          return new WebAnimationsPlayer(element, keyframes, playerOptions, specialStyles);
        }
      }]);

      return WebAnimationsDriver;
    }();

    if (false) {}
    /**
     * @return {?}
     */


    function supportsWebAnimations() {
      return typeof getElementAnimateFn() === 'function';
    }
    /**
     * @return {?}
     */


    function getElementAnimateFn() {
      return isBrowser() &&
      /** @type {?} */
      Element.prototype['animate'] || {};
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/private_export.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/src/browser.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/animations/browser/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=browser.js.map

    /***/

  },

  /***/
  "../../node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js":
  /*!*************************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js ***!
    \*************************************************************************************************************************/

  /*! exports provided: ANIMATION_MODULE_TYPE, BrowserAnimationsModule, NoopAnimationsModule, ɵAnimationRenderer, ɵAnimationRendererFactory, ɵBrowserAnimationBuilder, ɵBrowserAnimationFactory, ɵInjectableAnimationEngine, ɵangular_packages_platform_browser_animations_animations_a, ɵangular_packages_platform_browser_animations_animations_b, ɵangular_packages_platform_browser_animations_animations_c, ɵangular_packages_platform_browser_animations_animations_d, ɵangular_packages_platform_browser_animations_animations_e, ɵangular_packages_platform_browser_animations_animations_f */

  /***/
  function node_modulesAngularPlatformBrowser__ivy_ngcc__Fesm2015AnimationsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ANIMATION_MODULE_TYPE", function () {
      return ANIMATION_MODULE_TYPE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BrowserAnimationsModule", function () {
      return BrowserAnimationsModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NoopAnimationsModule", function () {
      return NoopAnimationsModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAnimationRenderer", function () {
      return AnimationRenderer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAnimationRendererFactory", function () {
      return AnimationRendererFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵBrowserAnimationBuilder", function () {
      return BrowserAnimationBuilder;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵBrowserAnimationFactory", function () {
      return BrowserAnimationFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵInjectableAnimationEngine", function () {
      return InjectableAnimationEngine;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_platform_browser_animations_animations_a", function () {
      return instantiateSupportedAnimationDriver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_platform_browser_animations_animations_b", function () {
      return instantiateDefaultStyleNormalizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_platform_browser_animations_animations_c", function () {
      return instantiateRendererFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_platform_browser_animations_animations_d", function () {
      return BROWSER_ANIMATIONS_PROVIDERS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_platform_browser_animations_animations_e", function () {
      return BROWSER_NOOP_ANIMATIONS_PROVIDERS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_platform_browser_animations_animations_f", function () {
      return BaseAnimationRenderer;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/platform-browser */
    "@angular/platform-browser");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/animations */
    "../../node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js");
    /* harmony import */


    var _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/animations/browser */
    "../../node_modules/@angular/animations/__ivy_ngcc__/fesm2015/browser.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/common */
    "@angular/common");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_4__);
    /**
     * @license Angular v9.1.11
     * (c) 2010-2020 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/src/animation_builder.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var BrowserAnimationBuilder = /*#__PURE__*/function (_angular_animations__2) {
      _inherits(BrowserAnimationBuilder, _angular_animations__2);

      var _super4 = _createSuper(BrowserAnimationBuilder);

      /**
       * @param {?} rootRenderer
       * @param {?} doc
       */
      function BrowserAnimationBuilder(rootRenderer, doc) {
        var _this52;

        _classCallCheck(this, BrowserAnimationBuilder);

        _this52 = _super4.call(this);
        _this52._nextAnimationId = 0;
        /** @type {?} */

        var typeData =
        /** @type {?} */
        {
          id: '0',
          encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
          styles: [],
          data: {
            animation: []
          }
        };
        _this52._renderer =
        /** @type {?} */
        rootRenderer.createRenderer(doc.body, typeData);
        return _this52;
      }
      /**
       * @param {?} animation
       * @return {?}
       */


      _createClass(BrowserAnimationBuilder, [{
        key: "build",
        value: function build(animation) {
          /** @type {?} */
          var id = this._nextAnimationId.toString();

          this._nextAnimationId++;
          /** @type {?} */

          var entry = Array.isArray(animation) ? Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["sequence"])(animation) : animation;
          issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
          return new BrowserAnimationFactory(id, this._renderer);
        }
      }]);

      return BrowserAnimationBuilder;
    }(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["AnimationBuilder"]);

    BrowserAnimationBuilder.ɵfac = function BrowserAnimationBuilder_Factory(t) {
      return new (t || BrowserAnimationBuilder)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__["DOCUMENT"]));
    };

    BrowserAnimationBuilder.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: BrowserAnimationBuilder,
      factory: BrowserAnimationBuilder.ɵfac
    });
    /** @nocollapse */

    BrowserAnimationBuilder.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__["DOCUMENT"]]
        }]
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](BrowserAnimationBuilder, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"]
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"],
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__["DOCUMENT"]]
          }]
        }];
      }, null);
    })();

    if (false) {}

    var BrowserAnimationFactory = /*#__PURE__*/function (_angular_animations__3) {
      _inherits(BrowserAnimationFactory, _angular_animations__3);

      var _super5 = _createSuper(BrowserAnimationFactory);

      /**
       * @param {?} _id
       * @param {?} _renderer
       */
      function BrowserAnimationFactory(_id, _renderer) {
        var _this53;

        _classCallCheck(this, BrowserAnimationFactory);

        _this53 = _super5.call(this);
        _this53._id = _id;
        _this53._renderer = _renderer;
        return _this53;
      }
      /**
       * @param {?} element
       * @param {?=} options
       * @return {?}
       */


      _createClass(BrowserAnimationFactory, [{
        key: "create",
        value: function create(element, options) {
          return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
        }
      }]);

      return BrowserAnimationFactory;
    }(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["AnimationFactory"]);

    if (false) {}

    var RendererAnimationPlayer = /*#__PURE__*/function () {
      /**
       * @param {?} id
       * @param {?} element
       * @param {?} options
       * @param {?} _renderer
       */
      function RendererAnimationPlayer(id, element, options, _renderer) {
        _classCallCheck(this, RendererAnimationPlayer);

        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;

        this._command('create', options);
      }
      /**
       * @private
       * @param {?} eventName
       * @param {?} callback
       * @return {?}
       */


      _createClass(RendererAnimationPlayer, [{
        key: "_listen",
        value: function _listen(eventName, callback) {
          return this._renderer.listen(this.element, "@@".concat(this.id, ":").concat(eventName), callback);
        }
        /**
         * @private
         * @param {?} command
         * @param {...?} args
         * @return {?}
         */

      }, {
        key: "_command",
        value: function _command(command) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDone",
        value: function onDone(fn) {
          this._listen('done', fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onStart",
        value: function onStart(fn) {
          this._listen('start', fn);
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "onDestroy",
        value: function onDestroy(fn) {
          this._listen('destroy', fn);
        }
        /**
         * @return {?}
         */

      }, {
        key: "init",
        value: function init() {
          this._command('init');
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasStarted",
        value: function hasStarted() {
          return this._started;
        }
        /**
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          this._command('play');

          this._started = true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "pause",
        value: function pause() {
          this._command('pause');
        }
        /**
         * @return {?}
         */

      }, {
        key: "restart",
        value: function restart() {
          this._command('restart');
        }
        /**
         * @return {?}
         */

      }, {
        key: "finish",
        value: function finish() {
          this._command('finish');
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this._command('destroy');
        }
        /**
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset() {
          this._command('reset');
        }
        /**
         * @param {?} p
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(p) {
          this._command('setPosition', p);
        }
        /**
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          return 0;
        }
      }]);

      return RendererAnimationPlayer;
    }();

    if (false) {}
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} id
     * @param {?} command
     * @param {?} args
     * @return {?}
     */


    function issueAnimationCommand(renderer, element, id, command, args) {
      return renderer.setProperty(element, "@@".concat(id, ":").concat(command), args);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/src/animation_renderer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ANIMATION_PREFIX = '@';
    /** @type {?} */

    var DISABLE_ANIMATIONS_FLAG = '@.disabled';
    /**
     * @record
     */

    function RecursiveAnimationTriggerMetadata() {}

    var AnimationRendererFactory = /*#__PURE__*/function () {
      /**
       * @param {?} delegate
       * @param {?} engine
       * @param {?} _zone
       */
      function AnimationRendererFactory(delegate, engine, _zone) {
        _classCallCheck(this, AnimationRendererFactory);

        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        this.promise = Promise.resolve(0);

        engine.onRemovalComplete =
        /**
        * @param {?} element
        * @param {?} delegate
        * @return {?}
        */
        function (element, delegate) {
          // Note: if an component element has a leave animation, and the component
          // a host leave animation, the view engine will call `removeChild` for the parent
          // component renderer as well as for the child component renderer.
          // Therefore, we need to check if we already removed the element.
          if (delegate && delegate.parentNode(element)) {
            delegate.removeChild(element.parentNode, element);
          }
        };
      }
      /**
       * @param {?} hostElement
       * @param {?} type
       * @return {?}
       */


      _createClass(AnimationRendererFactory, [{
        key: "createRenderer",
        value: function createRenderer(hostElement, type) {
          var _this54 = this;

          /** @type {?} */
          var EMPTY_NAMESPACE_ID = ''; // cache the delegates to find out which cached delegate can
          // be used by which cached renderer

          /** @type {?} */

          var delegate = this.delegate.createRenderer(hostElement, type);

          if (!hostElement || !type || !type.data || !type.data['animation']) {
            /** @type {?} */
            var renderer = this._rendererCache.get(delegate);

            if (!renderer) {
              renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine); // only cache this result when the base renderer is used

              this._rendererCache.set(delegate, renderer);
            }

            return renderer;
          }
          /** @type {?} */


          var componentId = type.id;
          /** @type {?} */

          var namespaceId = type.id + '-' + this._currentId;
          this._currentId++;
          this.engine.register(namespaceId, hostElement);
          /** @type {?} */

          var registerTrigger =
          /**
          * @param {?} trigger
          * @return {?}
          */
          function registerTrigger(trigger) {
            if (Array.isArray(trigger)) {
              trigger.forEach(registerTrigger);
            } else {
              _this54.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
            }
          };
          /** @type {?} */


          var animationTriggers =
          /** @type {?} */
          type.data['animation'];
          animationTriggers.forEach(registerTrigger);
          return new AnimationRenderer(this, namespaceId, delegate, this.engine);
        }
        /**
         * @return {?}
         */

      }, {
        key: "begin",
        value: function begin() {
          this._cdRecurDepth++;

          if (this.delegate.begin) {
            this.delegate.begin();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_scheduleCountTask",
        value: function _scheduleCountTask() {
          var _this55 = this;

          // always use promise to schedule microtask instead of use Zone
          this.promise.then(
          /**
          * @return {?}
          */
          function () {
            _this55._microtaskId++;
          });
        }
        /**
         * \@internal
         * @param {?} count
         * @param {?} fn
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "scheduleListenerCallback",
        value: function scheduleListenerCallback(count, fn, data) {
          var _this56 = this;

          if (count >= 0 && count < this._microtaskId) {
            this._zone.run(
            /**
            * @return {?}
            */
            function () {
              return fn(data);
            });

            return;
          }

          if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(
            /**
            * @return {?}
            */
            function () {
              _this56._zone.run(
              /**
              * @return {?}
              */
              function () {
                _this56._animationCallbacksBuffer.forEach(
                /**
                * @param {?} tuple
                * @return {?}
                */
                function (tuple) {
                  var _tuple = _slicedToArray(tuple, 2),
                      fn = _tuple[0],
                      data = _tuple[1];

                  fn(data);
                });

                _this56._animationCallbacksBuffer = [];
              });
            });
          }

          this._animationCallbacksBuffer.push([fn, data]);
        }
        /**
         * @return {?}
         */

      }, {
        key: "end",
        value: function end() {
          var _this57 = this;

          this._cdRecurDepth--; // this is to prevent animations from running twice when an inner
          // component does CD when a parent component instead has inserted it

          if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(
            /**
            * @return {?}
            */
            function () {
              _this57._scheduleCountTask();

              _this57.engine.flush(_this57._microtaskId);
            });
          }

          if (this.delegate.end) {
            this.delegate.end();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "whenRenderingDone",
        value: function whenRenderingDone() {
          return this.engine.whenRenderingDone();
        }
      }]);

      return AnimationRendererFactory;
    }();

    AnimationRendererFactory.ɵfac = function AnimationRendererFactory_Factory(t) {
      return new (t || AnimationRendererFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationEngine"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]));
    };

    AnimationRendererFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: AnimationRendererFactory,
      factory: AnimationRendererFactory.ɵfac
    });
    /** @nocollapse */

    AnimationRendererFactory.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"]
      }, {
        type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationEngine"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AnimationRendererFactory, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"]
        }, {
          type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationEngine"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
        }];
      }, null);
    })();

    if (false) {}

    var BaseAnimationRenderer = /*#__PURE__*/function () {
      /**
       * @param {?} namespaceId
       * @param {?} delegate
       * @param {?} engine
       */
      function BaseAnimationRenderer(namespaceId, delegate, engine) {
        _classCallCheck(this, BaseAnimationRenderer);

        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ?
        /**
        * @param {?} n
        * @return {?}
        */
        function (n) {
          return (
            /** @type {?} */
            delegate.destroyNode(n)
          );
        } : null;
      }
      /**
       * @return {?}
       */


      _createClass(BaseAnimationRenderer, [{
        key: "destroy",

        /**
         * @return {?}
         */
        value: function destroy() {
          this.engine.destroy(this.namespaceId, this.delegate);
          this.delegate.destroy();
        }
        /**
         * @param {?} name
         * @param {?=} namespace
         * @return {?}
         */

      }, {
        key: "createElement",
        value: function createElement(name, namespace) {
          return this.delegate.createElement(name, namespace);
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "createComment",
        value: function createComment(value) {
          return this.delegate.createComment(value);
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "createText",
        value: function createText(value) {
          return this.delegate.createText(value);
        }
        /**
         * @param {?} parent
         * @param {?} newChild
         * @return {?}
         */

      }, {
        key: "appendChild",
        value: function appendChild(parent, newChild) {
          this.delegate.appendChild(parent, newChild);
          this.engine.onInsert(this.namespaceId, newChild, parent, false);
        }
        /**
         * @param {?} parent
         * @param {?} newChild
         * @param {?} refChild
         * @return {?}
         */

      }, {
        key: "insertBefore",
        value: function insertBefore(parent, newChild, refChild) {
          this.delegate.insertBefore(parent, newChild, refChild);
          this.engine.onInsert(this.namespaceId, newChild, parent, true);
        }
        /**
         * @param {?} parent
         * @param {?} oldChild
         * @param {?} isHostElement
         * @return {?}
         */

      }, {
        key: "removeChild",
        value: function removeChild(parent, oldChild, isHostElement) {
          this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);
        }
        /**
         * @param {?} selectorOrNode
         * @param {?=} preserveContent
         * @return {?}
         */

      }, {
        key: "selectRootElement",
        value: function selectRootElement(selectorOrNode, preserveContent) {
          return this.delegate.selectRootElement(selectorOrNode, preserveContent);
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "parentNode",
        value: function parentNode(node) {
          return this.delegate.parentNode(node);
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "nextSibling",
        value: function nextSibling(node) {
          return this.delegate.nextSibling(node);
        }
        /**
         * @param {?} el
         * @param {?} name
         * @param {?} value
         * @param {?=} namespace
         * @return {?}
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(el, name, value, namespace) {
          this.delegate.setAttribute(el, name, value, namespace);
        }
        /**
         * @param {?} el
         * @param {?} name
         * @param {?=} namespace
         * @return {?}
         */

      }, {
        key: "removeAttribute",
        value: function removeAttribute(el, name, namespace) {
          this.delegate.removeAttribute(el, name, namespace);
        }
        /**
         * @param {?} el
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "addClass",
        value: function addClass(el, name) {
          this.delegate.addClass(el, name);
        }
        /**
         * @param {?} el
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "removeClass",
        value: function removeClass(el, name) {
          this.delegate.removeClass(el, name);
        }
        /**
         * @param {?} el
         * @param {?} style
         * @param {?} value
         * @param {?=} flags
         * @return {?}
         */

      }, {
        key: "setStyle",
        value: function setStyle(el, style, value, flags) {
          this.delegate.setStyle(el, style, value, flags);
        }
        /**
         * @param {?} el
         * @param {?} style
         * @param {?=} flags
         * @return {?}
         */

      }, {
        key: "removeStyle",
        value: function removeStyle(el, style, flags) {
          this.delegate.removeStyle(el, style, flags);
        }
        /**
         * @param {?} el
         * @param {?} name
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setProperty",
        value: function setProperty(el, name, value) {
          if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
          } else {
            this.delegate.setProperty(el, name, value);
          }
        }
        /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setValue",
        value: function setValue(node, value) {
          this.delegate.setValue(node, value);
        }
        /**
         * @param {?} target
         * @param {?} eventName
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "listen",
        value: function listen(target, eventName, callback) {
          return this.delegate.listen(target, eventName, callback);
        }
        /**
         * @protected
         * @param {?} element
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disableAnimations",
        value: function disableAnimations(element, value) {
          this.engine.disableAnimations(element, value);
        }
      }, {
        key: "data",
        get: function get() {
          return this.delegate.data;
        }
      }]);

      return BaseAnimationRenderer;
    }();

    if (false) {}

    var AnimationRenderer = /*#__PURE__*/function (_BaseAnimationRendere) {
      _inherits(AnimationRenderer, _BaseAnimationRendere);

      var _super6 = _createSuper(AnimationRenderer);

      /**
       * @param {?} factory
       * @param {?} namespaceId
       * @param {?} delegate
       * @param {?} engine
       */
      function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this58;

        _classCallCheck(this, AnimationRenderer);

        _this58 = _super6.call(this, namespaceId, delegate, engine);
        _this58.factory = factory;
        _this58.namespaceId = namespaceId;
        return _this58;
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @return {?}
       */


      _createClass(AnimationRenderer, [{
        key: "setProperty",
        value: function setProperty(el, name, value) {
          if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
              value = value === undefined ? true : !!value;
              this.disableAnimations(el,
              /** @type {?} */
              value);
            } else {
              this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
          } else {
            this.delegate.setProperty(el, name, value);
          }
        }
        /**
         * @param {?} target
         * @param {?} eventName
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "listen",
        value: function listen(target, eventName, callback) {
          var _this59 = this;

          if (eventName.charAt(0) == ANIMATION_PREFIX) {
            /** @type {?} */
            var element = resolveElementFromTarget(target);
            /** @type {?} */

            var name = eventName.substr(1);
            /** @type {?} */

            var phase = ''; // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks

            if (name.charAt(0) != ANIMATION_PREFIX) {
              var _parseTriggerCallback = parseTriggerCallbackName(name);

              var _parseTriggerCallback2 = _slicedToArray(_parseTriggerCallback, 2);

              name = _parseTriggerCallback2[0];
              phase = _parseTriggerCallback2[1];
            }

            return this.engine.listen(this.namespaceId, element, name, phase,
            /**
            * @param {?} event
            * @return {?}
            */
            function (event) {
              /** @type {?} */
              var countId =
              /** @type {?} */
              event['_data'] || -1;

              _this59.factory.scheduleListenerCallback(countId, callback, event);
            });
          }

          return this.delegate.listen(target, eventName, callback);
        }
      }]);

      return AnimationRenderer;
    }(BaseAnimationRenderer);

    if (false) {}
    /**
     * @param {?} target
     * @return {?}
     */


    function resolveElementFromTarget(target) {
      switch (target) {
        case 'body':
          return document.body;

        case 'document':
          return document;

        case 'window':
          return window;

        default:
          return target;
      }
    }
    /**
     * @param {?} triggerName
     * @return {?}
     */


    function parseTriggerCallbackName(triggerName) {
      /** @type {?} */
      var dotIndex = triggerName.indexOf('.');
      /** @type {?} */

      var trigger = triggerName.substring(0, dotIndex);
      /** @type {?} */

      var phase = triggerName.substr(dotIndex + 1);
      return [trigger, phase];
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/src/providers.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var InjectableAnimationEngine = /*#__PURE__*/function (_angular_animations_b) {
      _inherits(InjectableAnimationEngine, _angular_animations_b);

      var _super7 = _createSuper(InjectableAnimationEngine);

      /**
       * @param {?} doc
       * @param {?} driver
       * @param {?} normalizer
       */
      function InjectableAnimationEngine(doc, driver, normalizer) {
        _classCallCheck(this, InjectableAnimationEngine);

        return _super7.call(this, doc.body, driver, normalizer);
      }

      return InjectableAnimationEngine;
    }(_angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationEngine"]);

    InjectableAnimationEngine.ɵfac = function InjectableAnimationEngine_Factory(t) {
      return new (t || InjectableAnimationEngine)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__["DOCUMENT"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["AnimationDriver"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationStyleNormalizer"]));
    };

    InjectableAnimationEngine.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: InjectableAnimationEngine,
      factory: InjectableAnimationEngine.ɵfac
    });
    /** @nocollapse */

    InjectableAnimationEngine.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__["DOCUMENT"]]
        }]
      }, {
        type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["AnimationDriver"]
      }, {
        type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationStyleNormalizer"]
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](InjectableAnimationEngine, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
      }], function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"],
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__["DOCUMENT"]]
          }]
        }, {
          type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["AnimationDriver"]
        }, {
          type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationStyleNormalizer"]
        }];
      }, null);
    })();
    /**
     * @return {?}
     */


    function instantiateSupportedAnimationDriver() {
      return Object(_angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵsupportsWebAnimations"])() ? new _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵWebAnimationsDriver"]() : new _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵCssKeyframesDriver"]();
    }
    /**
     * @return {?}
     */


    function instantiateDefaultStyleNormalizer() {
      return new _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵWebAnimationsStyleNormalizer"]();
    }
    /**
     * @param {?} renderer
     * @param {?} engine
     * @param {?} zone
     * @return {?}
     */


    function instantiateRendererFactory(renderer, engine, zone) {
      return new AnimationRendererFactory(renderer, engine, zone);
    }
    /**
     * \@publicApi
     * @type {?}
     */


    var ANIMATION_MODULE_TYPE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('AnimationModuleType');
    /** @type {?} */

    var SHARED_ANIMATION_PROVIDERS = [{
      provide: _angular_animations__WEBPACK_IMPORTED_MODULE_2__["AnimationBuilder"],
      useClass: BrowserAnimationBuilder
    }, {
      provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationStyleNormalizer"],
      useFactory: instantiateDefaultStyleNormalizer
    }, {
      provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationEngine"],
      useClass: InjectableAnimationEngine
    }, {
      provide: _angular_core__WEBPACK_IMPORTED_MODULE_0__["RendererFactory2"],
      useFactory: instantiateRendererFactory,
      deps: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["ɵDomRendererFactory2"], _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵAnimationEngine"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]]
    }];
    /**
     * Separate providers from the actual module so that we can do a local modification in Google3 to
     * include them in the BrowserModule.
     * @type {?}
     */

    var BROWSER_ANIMATIONS_PROVIDERS = [{
      provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["AnimationDriver"],
      useFactory: instantiateSupportedAnimationDriver
    }, {
      provide: ANIMATION_MODULE_TYPE,
      useValue: 'BrowserAnimations'
    }].concat(SHARED_ANIMATION_PROVIDERS);
    /**
     * Separate providers from the actual module so that we can do a local modification in Google3 to
     * include them in the BrowserTestingModule.
     * @type {?}
     */

    var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{
      provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["AnimationDriver"],
      useClass: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_3__["ɵNoopAnimationDriver"]
    }, {
      provide: ANIMATION_MODULE_TYPE,
      useValue: 'NoopAnimations'
    }].concat(SHARED_ANIMATION_PROVIDERS);
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/src/module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)
     * for use with animations. See [Animations](guide/animations).
     * \@publicApi
     */

    var BrowserAnimationsModule = function BrowserAnimationsModule() {
      _classCallCheck(this, BrowserAnimationsModule);
    };

    BrowserAnimationsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: BrowserAnimationsModule
    });
    BrowserAnimationsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function BrowserAnimationsModule_Factory(t) {
        return new (t || BrowserAnimationsModule)();
      },
      providers: BROWSER_ANIMATIONS_PROVIDERS,
      imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](BrowserAnimationsModule, {
        exports: function exports() {
          return [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"]];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](BrowserAnimationsModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          exports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"]],
          providers: BROWSER_ANIMATIONS_PROVIDERS
        }]
      }], null, null);
    })();
    /**
     * A null player that must be imported to allow disabling of animations.
     * \@publicApi
     */


    var NoopAnimationsModule = function NoopAnimationsModule() {
      _classCallCheck(this, NoopAnimationsModule);
    };

    NoopAnimationsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: NoopAnimationsModule
    });
    NoopAnimationsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function NoopAnimationsModule_Factory(t) {
        return new (t || NoopAnimationsModule)();
      },
      providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
      imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](NoopAnimationsModule, {
        exports: function exports() {
          return [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"]];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NoopAnimationsModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          exports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"]],
          providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS
        }]
      }], null, null);
    })();
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/src/private_export.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/src/animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/platform-browser/animations/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=animations.js.map

    /***/

  },

  /***/
  "../../node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js ***!
    \***********************************************************************************************************/

  /*! exports provided: ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultUrlSerializer, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, NoPreloading, OutletContext, PRIMARY_OUTLET, PreloadAllModules, PreloadingStrategy, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, ROUTES, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, Router, RouterEvent, RouterLink, RouterLinkActive, RouterLinkWithHref, RouterModule, RouterOutlet, RouterPreloader, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, convertToParamMap, provideRoutes, ɵEmptyOutletComponent, ɵROUTER_PROVIDERS, ɵangular_packages_router_router_a, ɵangular_packages_router_router_b, ɵangular_packages_router_router_c, ɵangular_packages_router_router_d, ɵangular_packages_router_router_e, ɵangular_packages_router_router_f, ɵangular_packages_router_router_g, ɵangular_packages_router_router_h, ɵangular_packages_router_router_i, ɵangular_packages_router_router_j, ɵangular_packages_router_router_k, ɵangular_packages_router_router_l, ɵangular_packages_router_router_m, ɵangular_packages_router_router_n, ɵangular_packages_router_router_o, ɵflatten */

  /***/
  function node_modulesAngularRouter__ivy_ngcc__Fesm2015RouterJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ActivatedRoute", function () {
      return ActivatedRoute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ActivatedRouteSnapshot", function () {
      return ActivatedRouteSnapshot;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ActivationEnd", function () {
      return ActivationEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ActivationStart", function () {
      return ActivationStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ChildActivationEnd", function () {
      return ChildActivationEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ChildActivationStart", function () {
      return ChildActivationStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ChildrenOutletContexts", function () {
      return ChildrenOutletContexts;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DefaultUrlSerializer", function () {
      return DefaultUrlSerializer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GuardsCheckEnd", function () {
      return GuardsCheckEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GuardsCheckStart", function () {
      return GuardsCheckStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NavigationCancel", function () {
      return NavigationCancel;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NavigationEnd", function () {
      return NavigationEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NavigationError", function () {
      return NavigationError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NavigationStart", function () {
      return NavigationStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NoPreloading", function () {
      return NoPreloading;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OutletContext", function () {
      return OutletContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PRIMARY_OUTLET", function () {
      return PRIMARY_OUTLET;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PreloadAllModules", function () {
      return PreloadAllModules;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PreloadingStrategy", function () {
      return PreloadingStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ROUTER_CONFIGURATION", function () {
      return ROUTER_CONFIGURATION;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ROUTER_INITIALIZER", function () {
      return ROUTER_INITIALIZER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ROUTES", function () {
      return ROUTES;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ResolveEnd", function () {
      return ResolveEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ResolveStart", function () {
      return ResolveStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouteConfigLoadEnd", function () {
      return RouteConfigLoadEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouteConfigLoadStart", function () {
      return RouteConfigLoadStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouteReuseStrategy", function () {
      return RouteReuseStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Router", function () {
      return Router;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterEvent", function () {
      return RouterEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterLink", function () {
      return RouterLink;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterLinkActive", function () {
      return RouterLinkActive;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterLinkWithHref", function () {
      return RouterLinkWithHref;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterModule", function () {
      return RouterModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterOutlet", function () {
      return RouterOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterPreloader", function () {
      return RouterPreloader;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterState", function () {
      return RouterState;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RouterStateSnapshot", function () {
      return RouterStateSnapshot;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RoutesRecognized", function () {
      return RoutesRecognized;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Scroll", function () {
      return Scroll;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UrlHandlingStrategy", function () {
      return UrlHandlingStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UrlSegment", function () {
      return UrlSegment;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UrlSegmentGroup", function () {
      return UrlSegmentGroup;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UrlSerializer", function () {
      return UrlSerializer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UrlTree", function () {
      return UrlTree;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VERSION", function () {
      return VERSION;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "convertToParamMap", function () {
      return convertToParamMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "provideRoutes", function () {
      return provideRoutes;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵEmptyOutletComponent", function () {
      return ɵEmptyOutletComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵROUTER_PROVIDERS", function () {
      return ROUTER_PROVIDERS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_a", function () {
      return ROUTER_FORROOT_GUARD;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_b", function () {
      return routerNgProbeToken;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_c", function () {
      return createRouterScroller;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_d", function () {
      return provideLocationStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_e", function () {
      return provideForRootGuard;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_f", function () {
      return setupRouter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_g", function () {
      return rootRoute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_h", function () {
      return RouterInitializer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_i", function () {
      return getAppInitializer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_j", function () {
      return getBootstrapListener;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_k", function () {
      return provideRouterInitializer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_l", function () {
      return ɵEmptyOutletComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_m", function () {
      return Tree;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_n", function () {
      return TreeNode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_router_router_o", function () {
      return RouterScroller;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵflatten", function () {
      return flatten;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "@angular/common");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! rxjs */
    "rxjs");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! rxjs/operators */
    "../../node_modules/rxjs/_esm2015/operators/index.js");
    /**
     * @license Angular v9.1.11
     * (c) 2010-2020 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/events.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Base for events the router goes through, as opposed to events tied to a specific
     * route. Fired one time for any given navigation.
     *
     * \@usageNotes
     *
     * ```ts
     * class MyService {
     *   constructor(public router: Router, logger: Logger) {
     *     router.events.pipe(
     *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)
     *     ).subscribe((e: RouterEvent) => {
     *       logger.log(e.id, e.url);
     *     });
     *   }
     * }
     * ```
     *
     * @see `Event`
     * \@publicApi
     */


    var RouterEvent =
    /**
     * @param {?} id
     * @param {?} url
     */
    function RouterEvent(id, url) {
      _classCallCheck(this, RouterEvent);

      this.id = id;
      this.url = url;
    };

    if (false) {}
    /**
     * An event triggered when a navigation starts.
     *
     * \@publicApi
     */


    var NavigationStart = /*#__PURE__*/function (_RouterEvent) {
      _inherits(NavigationStart, _RouterEvent);

      var _super8 = _createSuper(NavigationStart);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?=} navigationTrigger
       * @param {?=} restoredState
       */
      function NavigationStart(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url) {
        var _this60;

        var navigationTrigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'imperative';
        var restoredState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        _classCallCheck(this, NavigationStart);

        _this60 = _super8.call(this, id, url);
        _this60.navigationTrigger = navigationTrigger;
        _this60.restoredState = restoredState;
        return _this60;
      }
      /**
       * \@docsNotRequired
       * @return {?}
       */


      _createClass(NavigationStart, [{
        key: "toString",
        value: function toString() {
          return "NavigationStart(id: ".concat(this.id, ", url: '").concat(this.url, "')");
        }
      }]);

      return NavigationStart;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered when a navigation ends successfully.
     *
     * \@publicApi
     */


    var NavigationEnd = /*#__PURE__*/function (_RouterEvent2) {
      _inherits(NavigationEnd, _RouterEvent2);

      var _super9 = _createSuper(NavigationEnd);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} urlAfterRedirects
       */
      function NavigationEnd(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, urlAfterRedirects) {
        var _this61;

        _classCallCheck(this, NavigationEnd);

        _this61 = _super9.call(this, id, url);
        _this61.urlAfterRedirects = urlAfterRedirects;
        return _this61;
      }
      /**
       * \@docsNotRequired
       * @return {?}
       */


      _createClass(NavigationEnd, [{
        key: "toString",
        value: function toString() {
          return "NavigationEnd(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "')");
        }
      }]);

      return NavigationEnd;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered when a navigation is canceled, directly or indirectly.
     *
     * This can happen when a [route guard](guide/router#milestone-5-route-guards)
     * returns `false` or initiates a redirect by returning a `UrlTree`.
     *
     * \@publicApi
     */


    var NavigationCancel = /*#__PURE__*/function (_RouterEvent3) {
      _inherits(NavigationCancel, _RouterEvent3);

      var _super10 = _createSuper(NavigationCancel);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} reason
       */
      function NavigationCancel(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, reason) {
        var _this62;

        _classCallCheck(this, NavigationCancel);

        _this62 = _super10.call(this, id, url);
        _this62.reason = reason;
        return _this62;
      }
      /**
       * \@docsNotRequired
       * @return {?}
       */


      _createClass(NavigationCancel, [{
        key: "toString",
        value: function toString() {
          return "NavigationCancel(id: ".concat(this.id, ", url: '").concat(this.url, "')");
        }
      }]);

      return NavigationCancel;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered when a navigation fails due to an unexpected error.
     *
     * \@publicApi
     */


    var NavigationError = /*#__PURE__*/function (_RouterEvent4) {
      _inherits(NavigationError, _RouterEvent4);

      var _super11 = _createSuper(NavigationError);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} error
       */
      function NavigationError(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, error) {
        var _this63;

        _classCallCheck(this, NavigationError);

        _this63 = _super11.call(this, id, url);
        _this63.error = error;
        return _this63;
      }
      /**
       * \@docsNotRequired
       * @return {?}
       */


      _createClass(NavigationError, [{
        key: "toString",
        value: function toString() {
          return "NavigationError(id: ".concat(this.id, ", url: '").concat(this.url, "', error: ").concat(this.error, ")");
        }
      }]);

      return NavigationError;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered when routes are recognized.
     *
     * \@publicApi
     */


    var RoutesRecognized = /*#__PURE__*/function (_RouterEvent5) {
      _inherits(RoutesRecognized, _RouterEvent5);

      var _super12 = _createSuper(RoutesRecognized);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} urlAfterRedirects
       * @param {?} state
       */
      function RoutesRecognized(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, urlAfterRedirects, state) {
        var _this64;

        _classCallCheck(this, RoutesRecognized);

        _this64 = _super12.call(this, id, url);
        _this64.urlAfterRedirects = urlAfterRedirects;
        _this64.state = state;
        return _this64;
      }
      /**
       * \@docsNotRequired
       * @return {?}
       */


      _createClass(RoutesRecognized, [{
        key: "toString",
        value: function toString() {
          return "RoutesRecognized(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")");
        }
      }]);

      return RoutesRecognized;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered at the start of the Guard phase of routing.
     *
     * \@publicApi
     */


    var GuardsCheckStart = /*#__PURE__*/function (_RouterEvent6) {
      _inherits(GuardsCheckStart, _RouterEvent6);

      var _super13 = _createSuper(GuardsCheckStart);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} urlAfterRedirects
       * @param {?} state
       */
      function GuardsCheckStart(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, urlAfterRedirects, state) {
        var _this65;

        _classCallCheck(this, GuardsCheckStart);

        _this65 = _super13.call(this, id, url);
        _this65.urlAfterRedirects = urlAfterRedirects;
        _this65.state = state;
        return _this65;
      }
      /**
       * @return {?}
       */


      _createClass(GuardsCheckStart, [{
        key: "toString",
        value: function toString() {
          return "GuardsCheckStart(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")");
        }
      }]);

      return GuardsCheckStart;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered at the end of the Guard phase of routing.
     *
     * \@publicApi
     */


    var GuardsCheckEnd = /*#__PURE__*/function (_RouterEvent7) {
      _inherits(GuardsCheckEnd, _RouterEvent7);

      var _super14 = _createSuper(GuardsCheckEnd);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} urlAfterRedirects
       * @param {?} state
       * @param {?} shouldActivate
       */
      function GuardsCheckEnd(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, urlAfterRedirects, state, shouldActivate) {
        var _this66;

        _classCallCheck(this, GuardsCheckEnd);

        _this66 = _super14.call(this, id, url);
        _this66.urlAfterRedirects = urlAfterRedirects;
        _this66.state = state;
        _this66.shouldActivate = shouldActivate;
        return _this66;
      }
      /**
       * @return {?}
       */


      _createClass(GuardsCheckEnd, [{
        key: "toString",
        value: function toString() {
          return "GuardsCheckEnd(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ", shouldActivate: ").concat(this.shouldActivate, ")");
        }
      }]);

      return GuardsCheckEnd;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered at the the start of the Resolve phase of routing.
     *
     * Runs in the "resolve" phase whether or not there is anything to resolve.
     * In future, may change to only run when there are things to be resolved.
     *
     * \@publicApi
     */


    var ResolveStart = /*#__PURE__*/function (_RouterEvent8) {
      _inherits(ResolveStart, _RouterEvent8);

      var _super15 = _createSuper(ResolveStart);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} urlAfterRedirects
       * @param {?} state
       */
      function ResolveStart(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, urlAfterRedirects, state) {
        var _this67;

        _classCallCheck(this, ResolveStart);

        _this67 = _super15.call(this, id, url);
        _this67.urlAfterRedirects = urlAfterRedirects;
        _this67.state = state;
        return _this67;
      }
      /**
       * @return {?}
       */


      _createClass(ResolveStart, [{
        key: "toString",
        value: function toString() {
          return "ResolveStart(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")");
        }
      }]);

      return ResolveStart;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered at the end of the Resolve phase of routing.
     * @see `ResolveStart`.
     *
     * \@publicApi
     */


    var ResolveEnd = /*#__PURE__*/function (_RouterEvent9) {
      _inherits(ResolveEnd, _RouterEvent9);

      var _super16 = _createSuper(ResolveEnd);

      /**
       * @param {?} id
       * @param {?} url
       * @param {?} urlAfterRedirects
       * @param {?} state
       */
      function ResolveEnd(
      /** @docsNotRequired */
      id,
      /** @docsNotRequired */
      url, urlAfterRedirects, state) {
        var _this68;

        _classCallCheck(this, ResolveEnd);

        _this68 = _super16.call(this, id, url);
        _this68.urlAfterRedirects = urlAfterRedirects;
        _this68.state = state;
        return _this68;
      }
      /**
       * @return {?}
       */


      _createClass(ResolveEnd, [{
        key: "toString",
        value: function toString() {
          return "ResolveEnd(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")");
        }
      }]);

      return ResolveEnd;
    }(RouterEvent);

    if (false) {}
    /**
     * An event triggered before lazy loading a route configuration.
     *
     * \@publicApi
     */


    var RouteConfigLoadStart = /*#__PURE__*/function () {
      /**
       * @param {?} route
       */
      function RouteConfigLoadStart(route) {
        _classCallCheck(this, RouteConfigLoadStart);

        this.route = route;
      }
      /**
       * @return {?}
       */


      _createClass(RouteConfigLoadStart, [{
        key: "toString",
        value: function toString() {
          return "RouteConfigLoadStart(path: ".concat(this.route.path, ")");
        }
      }]);

      return RouteConfigLoadStart;
    }();

    if (false) {}
    /**
     * An event triggered when a route has been lazy loaded.
     *
     * \@publicApi
     */


    var RouteConfigLoadEnd = /*#__PURE__*/function () {
      /**
       * @param {?} route
       */
      function RouteConfigLoadEnd(route) {
        _classCallCheck(this, RouteConfigLoadEnd);

        this.route = route;
      }
      /**
       * @return {?}
       */


      _createClass(RouteConfigLoadEnd, [{
        key: "toString",
        value: function toString() {
          return "RouteConfigLoadEnd(path: ".concat(this.route.path, ")");
        }
      }]);

      return RouteConfigLoadEnd;
    }();

    if (false) {}
    /**
     * An event triggered at the start of the child-activation
     * part of the Resolve phase of routing.
     * @see `ChildActivationEnd`
     * @see `ResolveStart`
     *
     * \@publicApi
     */


    var ChildActivationStart = /*#__PURE__*/function () {
      /**
       * @param {?} snapshot
       */
      function ChildActivationStart(snapshot) {
        _classCallCheck(this, ChildActivationStart);

        this.snapshot = snapshot;
      }
      /**
       * @return {?}
       */


      _createClass(ChildActivationStart, [{
        key: "toString",
        value: function toString() {
          /** @type {?} */
          var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
          return "ChildActivationStart(path: '".concat(path, "')");
        }
      }]);

      return ChildActivationStart;
    }();

    if (false) {}
    /**
     * An event triggered at the end of the child-activation part
     * of the Resolve phase of routing.
     * @see `ChildActivationStart`
     * @see `ResolveStart` *
     * \@publicApi
     */


    var ChildActivationEnd = /*#__PURE__*/function () {
      /**
       * @param {?} snapshot
       */
      function ChildActivationEnd(snapshot) {
        _classCallCheck(this, ChildActivationEnd);

        this.snapshot = snapshot;
      }
      /**
       * @return {?}
       */


      _createClass(ChildActivationEnd, [{
        key: "toString",
        value: function toString() {
          /** @type {?} */
          var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
          return "ChildActivationEnd(path: '".concat(path, "')");
        }
      }]);

      return ChildActivationEnd;
    }();

    if (false) {}
    /**
     * An event triggered at the start of the activation part
     * of the Resolve phase of routing.
     * @see ActivationEnd`
     * @see `ResolveStart`
     *
     * \@publicApi
     */


    var ActivationStart = /*#__PURE__*/function () {
      /**
       * @param {?} snapshot
       */
      function ActivationStart(snapshot) {
        _classCallCheck(this, ActivationStart);

        this.snapshot = snapshot;
      }
      /**
       * @return {?}
       */


      _createClass(ActivationStart, [{
        key: "toString",
        value: function toString() {
          /** @type {?} */
          var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
          return "ActivationStart(path: '".concat(path, "')");
        }
      }]);

      return ActivationStart;
    }();

    if (false) {}
    /**
     * An event triggered at the end of the activation part
     * of the Resolve phase of routing.
     * @see `ActivationStart`
     * @see `ResolveStart`
     *
     * \@publicApi
     */


    var ActivationEnd = /*#__PURE__*/function () {
      /**
       * @param {?} snapshot
       */
      function ActivationEnd(snapshot) {
        _classCallCheck(this, ActivationEnd);

        this.snapshot = snapshot;
      }
      /**
       * @return {?}
       */


      _createClass(ActivationEnd, [{
        key: "toString",
        value: function toString() {
          /** @type {?} */
          var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
          return "ActivationEnd(path: '".concat(path, "')");
        }
      }]);

      return ActivationEnd;
    }();

    if (false) {}
    /**
     * An event triggered by scrolling.
     *
     * \@publicApi
     */


    var Scroll = /*#__PURE__*/function () {
      /**
       * @param {?} routerEvent
       * @param {?} position
       * @param {?} anchor
       */
      function Scroll(routerEvent, position, anchor) {
        _classCallCheck(this, Scroll);

        this.routerEvent = routerEvent;
        this.position = position;
        this.anchor = anchor;
      }
      /**
       * @return {?}
       */


      _createClass(Scroll, [{
        key: "toString",
        value: function toString() {
          /** @type {?} */
          var pos = this.position ? "".concat(this.position[0], ", ").concat(this.position[1]) : null;
          return "Scroll(anchor: '".concat(this.anchor, "', position: '").concat(pos, "')");
        }
      }]);

      return Scroll;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/components/empty_outlet.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * This component is used internally within the router to be a placeholder when an empty
     * router-outlet is needed. For example, with a config such as:
     *
     * `{path: 'parent', outlet: 'nav', children: [...]}`
     *
     * In order to render, there needs to be a component on this config, which will default
     * to this `EmptyOutletComponent`.
     */


    var ɵEmptyOutletComponent = function ɵEmptyOutletComponent() {
      _classCallCheck(this, ɵEmptyOutletComponent);
    };

    ɵEmptyOutletComponent.ɵfac = function ɵEmptyOutletComponent_Factory(t) {
      return new (t || ɵEmptyOutletComponent)();
    };

    ɵEmptyOutletComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
      type: ɵEmptyOutletComponent,
      selectors: [["ng-component"]],
      decls: 1,
      vars: 0,
      template: function ɵEmptyOutletComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "router-outlet");
        }
      },
      directives: function directives() {
        return [RouterOutlet];
      },
      encapsulation: 2
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](ɵEmptyOutletComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
        args: [{
          template: "<router-outlet></router-outlet>"
        }]
      }], null, null);
    })();
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/shared.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * The primary routing outlet.
     *
     * \@publicApi
     * @type {?}
     */


    var PRIMARY_OUTLET = 'primary';
    /**
     * A map that provides access to the required and optional parameters
     * specific to a route.
     * The map supports retrieving a single value with `get()`
     * or multiple values with `getAll()`.
     *
     * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)
     *
     * \@publicApi
     * @record
     */

    function ParamMap() {}

    if (false) {}

    var ParamsAsMap = /*#__PURE__*/function () {
      /**
       * @param {?} params
       */
      function ParamsAsMap(params) {
        _classCallCheck(this, ParamsAsMap);

        this.params = params || {};
      }
      /**
       * @param {?} name
       * @return {?}
       */


      _createClass(ParamsAsMap, [{
        key: "has",
        value: function has(name) {
          return this.params.hasOwnProperty(name);
        }
        /**
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "get",
        value: function get(name) {
          if (this.has(name)) {
            /** @type {?} */
            var v = this.params[name];
            return Array.isArray(v) ? v[0] : v;
          }

          return null;
        }
        /**
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "getAll",
        value: function getAll(name) {
          if (this.has(name)) {
            /** @type {?} */
            var v = this.params[name];
            return Array.isArray(v) ? v : [v];
          }

          return [];
        }
        /**
         * @return {?}
         */

      }, {
        key: "keys",
        get: function get() {
          return Object.keys(this.params);
        }
      }]);

      return ParamsAsMap;
    }();

    if (false) {}
    /**
     * Converts a `Params` instance to a `ParamMap`.
     * \@publicApi
     * @param {?} params The instance to convert.
     * @return {?} The new map instance.
     *
     */


    function convertToParamMap(params) {
      return new ParamsAsMap(params);
    }
    /** @type {?} */


    var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
    /**
     * @param {?} message
     * @return {?}
     */

    function navigationCancelingError(message) {
      /** @type {?} */
      var error = Error('NavigationCancelingError: ' + message);

      /** @type {?} */
      error[NAVIGATION_CANCELING_ERROR] = true;
      return error;
    }
    /**
     * @param {?} error
     * @return {?}
     */


    function isNavigationCancelingError(error) {
      return error &&
      /** @type {?} */
      error[NAVIGATION_CANCELING_ERROR];
    } // Matches the route configuration (`route`) against the actual URL (`segments`).

    /**
     * @param {?} segments
     * @param {?} segmentGroup
     * @param {?} route
     * @return {?}
     */


    function defaultUrlMatcher(segments, segmentGroup, route) {
      /** @type {?} */
      var parts =
      /** @type {?} */
      route.path.split('/');

      if (parts.length > segments.length) {
        // The actual URL is shorter than the config, no match
        return null;
      }

      if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {
        // The config is longer than the actual URL but we are looking for a full match, return null
        return null;
      }
      /** @type {?} */


      var posParams = {}; // Check each config part against the actual URL

      for (var index = 0; index < parts.length; index++) {
        /** @type {?} */
        var part = parts[index];
        /** @type {?} */

        var segment = segments[index];
        /** @type {?} */

        var isParameter = part.startsWith(':');

        if (isParameter) {
          posParams[part.substring(1)] = segment;
        } else if (part !== segment.path) {
          // The actual URL part does not match the config, no match
          return null;
        }
      }

      return {
        consumed: segments.slice(0, parts.length),
        posParams: posParams
      };
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/config.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A configuration object that defines a single route.
     * A set of routes are collected in a `Routes` array to define a `Router` configuration.
     * The router attempts to match segments of a given URL against each route,
     * using the configuration options defined in this object.
     *
     * Supports static, parameterized, redirect, and wildcard routes, as well as
     * custom route data and resolve methods.
     *
     * For detailed usage information, see the [Routing Guide](guide/router).
     *
     * \@usageNotes
     *
     * ### Simple Configuration
     *
     * The following route specifies that when navigating to, for example,
     * `/team/11/user/bob`, the router creates the 'Team' component
     * with the 'User' child component in it.
     *
     * ```
     * [{
     *   path: 'team/:id',
     *  component: Team,
     *   children: [{
     *     path: 'user/:name',
     *     component: User
     *   }]
     * }]
     * ```
     *
     * ### Multiple Outlets
     *
     * The following route creates sibling components with multiple outlets.
     * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to
     * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.
     *
     * ```
     * [{
     *   path: 'team/:id',
     *   component: Team
     * }, {
     *   path: 'chat/:user',
     *   component: Chat
     *   outlet: 'aux'
     * }]
     * ```
     *
     * ### Wild Cards
     *
     * The following route uses wild-card notation to specify a component
     * that is always instantiated regardless of where you navigate to.
     *
     * ```
     * [{
     *   path: '**',
     *   component: WildcardComponent
     * }]
     * ```
     *
     * ### Redirects
     *
     * The following route uses the `redirectTo` property to ignore a segment of
     * a given URL when looking for a child path.
     *
     * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment
     * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates
     * the Team component with the User child component in it.
     *
     * ```
     * [{
     *   path: 'team/:id',
     *   component: Team,
     *   children: [{
     *     path: 'legacy/user/:name',
     *     redirectTo: 'user/:name'
     *   }, {
     *     path: 'user/:name',
     *     component: User
     *   }]
     * }]
     * ```
     *
     * The redirect path can be relative, as shown in this example, or absolute.
     * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',
     * the result URL is also absolute, '/user/jim'.
     * ### Empty Path
     *
     * Empty-path route configurations can be used to instantiate components that do not 'consume'
     * any URL segments.
     *
     * In the following configuration, when navigating to
     * `/team/11`, the router instantiates the 'AllUsers' component.
     *
     * ```
     * [{
     *   path: 'team/:id',
     *   component: Team,
     *   children: [{
     *     path: '',
     *     component: AllUsers
     *   }, {
     *     path: 'user/:name',
     *     component: User
     *   }]
     * }]
     * ```
     *
     * Empty-path routes can have children. In the following example, when navigating
     * to `/team/11/user/jim`, the router instantiates the wrapper component with
     * the user component in it.
     *
     * Note that an empty path route inherits its parent's parameters and data.
     *
     * ```
     * [{
     *   path: 'team/:id',
     *   component: Team,
     *   children: [{
     *     path: '',
     *     component: WrapperCmp,
     *     children: [{
     *       path: 'user/:name',
     *       component: User
     *     }]
     *   }]
     * }]
     * ```
     *
     * ### Matching Strategy
     *
     * The default path-match strategy is 'prefix', which means that the router
     * checks URL elements from the left to see if the URL matches a specified path.
     * For example, '/team/11/user' matches 'team/:id'.
     *
     * ```
     * [{
     *   path: '',
     *   pathMatch: 'prefix', //default
     *   redirectTo: 'main'
     * }, {
     *   path: 'main',
     *   component: Main
     * }]
     * ```
     *
     * You can specify the path-match strategy 'full' to make sure that the path
     * covers the whole unconsumed URL. It is important to do this when redirecting
     * empty-path routes. Otherwise, because an empty path is a prefix of any URL,
     * the router would apply the redirect even when navigating to the redirect destination,
     * creating an endless loop.
     *
     * In the following example, supplying the 'full' `pathMatch` strategy ensures
     * that the router applies the redirect if and only if navigating to '/'.
     *
     * ```
     * [{
     *   path: '',
     *   pathMatch: 'full',
     *   redirectTo: 'main'
     * }, {
     *   path: 'main',
     *   component: Main
     * }]
     * ```
     *
     * ### Componentless Routes
     *
     * You can share parameters between sibling components.
     * For example, suppose that two sibling components should go next to each other,
     * and both of them require an ID parameter. You can accomplish this using a route
     * that does not specify a component at the top level.
     *
     * In the following example, 'MainChild' and 'AuxChild' are siblings.
     * When navigating to 'parent/10/(a//aux:b)', the route instantiates
     * the main child and aux child components next to each other.
     * For this to work, the application component must have the primary and aux outlets defined.
     *
     * ```
     * [{
     *    path: 'parent/:id',
     *    children: [
     *      { path: 'a', component: MainChild },
     *      { path: 'b', component: AuxChild, outlet: 'aux' }
     *    ]
     * }]
     * ```
     *
     * The router merges the parameters, data, and resolve of the componentless
     * parent into the parameters, data, and resolve of the children.
     *
     * This is especially useful when child components are defined
     * with an empty path string, as in the following example.
     * With this configuration, navigating to '/parent/10' creates
     * the main child and aux components.
     *
     * ```
     * [{
     *    path: 'parent/:id',
     *    children: [
     *      { path: '', component: MainChild },
     *      { path: '', component: AuxChild, outlet: 'aux' }
     *    ]
     * }]
     * ```
     *
     * ### Lazy Loading
     *
     * Lazy loading speeds up application load time by splitting the application
     * into multiple bundles and loading them on demand.
     * To use lazy loading, provide the `loadChildren` property  instead of the `children` property.
     *
     * Given the following example route, the router will lazy load
     * the associated module on demand using the browser native import system.
     *
     * ```
     * [{
     *   path: 'lazy',
     *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),
     * }];
     * ```
     *
     * \@publicApi
     * @record
     */


    function Route() {}

    if (false) {}

    var LoadedRouterConfig =
    /**
     * @param {?} routes
     * @param {?} module
     */
    function LoadedRouterConfig(routes, module) {
      _classCallCheck(this, LoadedRouterConfig);

      this.routes = routes;
      this.module = module;
    };

    if (false) {}
    /**
     * @param {?} config
     * @param {?=} parentPath
     * @return {?}
     */


    function validateConfig(config) {
      var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      // forEach doesn't iterate undefined values
      for (var i = 0; i < config.length; i++) {
        /** @type {?} */
        var route = config[i];
        /** @type {?} */

        var fullPath = getFullPath(parentPath, route);
        validateNode(route, fullPath);
      }
    }
    /**
     * @param {?} route
     * @param {?} fullPath
     * @return {?}
     */


    function validateNode(route, fullPath) {
      if (!route) {
        throw new Error("\n      Invalid configuration of route '".concat(fullPath, "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    "));
      }

      if (Array.isArray(route)) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': Array cannot be specified"));
      }

      if (!route.component && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': a componentless route without children or loadChildren cannot have a named outlet set"));
      }

      if (route.redirectTo && route.children) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': redirectTo and children cannot be used together"));
      }

      if (route.redirectTo && route.loadChildren) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': redirectTo and loadChildren cannot be used together"));
      }

      if (route.children && route.loadChildren) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': children and loadChildren cannot be used together"));
      }

      if (route.redirectTo && route.component) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': redirectTo and component cannot be used together"));
      }

      if (route.path && route.matcher) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': path and matcher cannot be used together"));
      }

      if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "'. One of the following must be provided: component, redirectTo, children or loadChildren"));
      }

      if (route.path === void 0 && route.matcher === void 0) {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': routes must have either a path or a matcher specified"));
      }

      if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': path cannot start with a slash"));
      }

      if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
        /** @type {?} */
        var exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
        throw new Error("Invalid configuration of route '{path: \"".concat(fullPath, "\", redirectTo: \"").concat(route.redirectTo, "\"}': please provide 'pathMatch'. ").concat(exp));
      }

      if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
        throw new Error("Invalid configuration of route '".concat(fullPath, "': pathMatch can only be set to 'prefix' or 'full'"));
      }

      if (route.children) {
        validateConfig(route.children, fullPath);
      }
    }
    /**
     * @param {?} parentPath
     * @param {?} currentRoute
     * @return {?}
     */


    function getFullPath(parentPath, currentRoute) {
      if (!currentRoute) {
        return parentPath;
      }

      if (!parentPath && !currentRoute.path) {
        return '';
      } else if (parentPath && !currentRoute.path) {
        return "".concat(parentPath, "/");
      } else if (!parentPath && currentRoute.path) {
        return currentRoute.path;
      } else {
        return "".concat(parentPath, "/").concat(currentRoute.path);
      }
    }
    /**
     * Makes a copy of the config and adds any default required properties.
     * @param {?} r
     * @return {?}
     */


    function standardizeConfig(r) {
      /** @type {?} */
      var children = r.children && r.children.map(standardizeConfig);
      /** @type {?} */

      var c = children ? Object.assign(Object.assign({}, r), {
        children: children
      }) : Object.assign({}, r);

      if (!c.component && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
        c.component = ɵEmptyOutletComponent;
      }

      return c;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/utils/collection.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function shallowEqualArrays(a, b) {
      if (a.length !== b.length) return false;

      for (var i = 0; i < a.length; ++i) {
        if (!shallowEqual(a[i], b[i])) return false;
      }

      return true;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function shallowEqual(a, b) {
      // Casting Object.keys return values to include `undefined` as there are some cases
      // in IE 11 where this can happen. Cannot provide a test because the behavior only
      // exists in certain circumstances in IE 11, therefore doing this cast ensures the
      // logic is correct for when this edge case is hit.

      /** @type {?} */
      var k1 =
      /** @type {?} */
      Object.keys(a);
      /** @type {?} */

      var k2 =
      /** @type {?} */
      Object.keys(b);

      if (!k1 || !k2 || k1.length != k2.length) {
        return false;
      }
      /** @type {?} */


      var key;

      for (var i = 0; i < k1.length; i++) {
        key = k1[i];

        if (!equalArraysOrString(a[key], b[key])) {
          return false;
        }
      }

      return true;
    }
    /**
     * Test equality for arrays of strings or a string.
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function equalArraysOrString(a, b) {
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length != b.length) return false;
        return a.every(
        /**
        * @param {?} aItem
        * @return {?}
        */
        function (aItem) {
          return b.indexOf(aItem) > -1;
        });
      } else {
        return a === b;
      }
    }
    /**
     * Flattens single-level nested arrays.
     * @template T
     * @param {?} arr
     * @return {?}
     */


    function flatten(arr) {
      return Array.prototype.concat.apply([], arr);
    }
    /**
     * Return the last element of an array.
     * @template T
     * @param {?} a
     * @return {?}
     */


    function last(a) {
      return a.length > 0 ? a[a.length - 1] : null;
    }
    /**
     * Verifys all booleans in an array are `true`.
     * @param {?} bools
     * @return {?}
     */


    function and(bools) {
      return !bools.some(
      /**
      * @param {?} v
      * @return {?}
      */
      function (v) {
        return !v;
      });
    }
    /**
     * @template K, V
     * @param {?} map
     * @param {?} callback
     * @return {?}
     */


    function forEach(map, callback) {
      for (var prop in map) {
        if (map.hasOwnProperty(prop)) {
          callback(map[prop], prop);
        }
      }
    }
    /**
     * @template A, B
     * @param {?} obj
     * @param {?} fn
     * @return {?}
     */


    function waitForMap(obj, fn) {
      if (Object.keys(obj).length === 0) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])({});
      }
      /** @type {?} */


      var waitHead = [];
      /** @type {?} */

      var waitTail = [];
      /** @type {?} */

      var res = {};
      forEach(obj,
      /**
      * @param {?} a
      * @param {?} k
      * @return {?}
      */
      function (a, k) {
        /** @type {?} */
        var mapped = fn(k, a).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
        /**
        * @param {?} r
        * @return {?}
        */
        function (r) {
          return res[k] = r;
        }));

        if (k === PRIMARY_OUTLET) {
          waitHead.push(mapped);
        } else {
          waitTail.push(mapped);
        }
      }); // Closure compiler has problem with using spread operator here. So we use "Array.concat".
      // Note that we also need to cast the new promise because TypeScript cannot infer the type
      // when calling the "of" function through "Function.apply"

      return (
        /** @type {?} */
        rxjs__WEBPACK_IMPORTED_MODULE_2__["of"].apply(null, waitHead.concat(waitTail)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatAll"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["last"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
        /**
        * @return {?}
        */
        function () {
          return res;
        }))
      );
    }
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */


    function wrapIntoObservable(value) {
      if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵisObservable"])(value)) {
        return value;
      }

      if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵisPromise"])(value)) {
        // Use `Promise.resolve()` to wrap promise-like instances.
        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
        // change detection.
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(Promise.resolve(value));
      }

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(value);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/url_tree.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @return {?}
     */


    function createEmptyUrlTree() {
      return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
    }
    /**
     * @param {?} container
     * @param {?} containee
     * @param {?} exact
     * @return {?}
     */


    function containsTree(container, containee, exact) {
      if (exact) {
        return equalQueryParams(container.queryParams, containee.queryParams) && equalSegmentGroups(container.root, containee.root);
      }

      return containsQueryParams(container.queryParams, containee.queryParams) && containsSegmentGroup(container.root, containee.root);
    }
    /**
     * @param {?} container
     * @param {?} containee
     * @return {?}
     */


    function equalQueryParams(container, containee) {
      // TODO: This does not handle array params correctly.
      return shallowEqual(container, containee);
    }
    /**
     * @param {?} container
     * @param {?} containee
     * @return {?}
     */


    function equalSegmentGroups(container, containee) {
      if (!equalPath(container.segments, containee.segments)) return false;
      if (container.numberOfChildren !== containee.numberOfChildren) return false;

      for (var c in containee.children) {
        if (!container.children[c]) return false;
        if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;
      }

      return true;
    }
    /**
     * @param {?} container
     * @param {?} containee
     * @return {?}
     */


    function containsQueryParams(container, containee) {
      // TODO: This does not handle array params correctly.
      return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(
      /**
      * @param {?} key
      * @return {?}
      */
      function (key) {
        return equalArraysOrString(container[key], containee[key]);
      });
    }
    /**
     * @param {?} container
     * @param {?} containee
     * @return {?}
     */


    function containsSegmentGroup(container, containee) {
      return containsSegmentGroupHelper(container, containee, containee.segments);
    }
    /**
     * @param {?} container
     * @param {?} containee
     * @param {?} containeePaths
     * @return {?}
     */


    function containsSegmentGroupHelper(container, containee, containeePaths) {
      if (container.segments.length > containeePaths.length) {
        /** @type {?} */
        var current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths)) return false;
        if (containee.hasChildren()) return false;
        return true;
      } else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths)) return false;

        for (var c in containee.children) {
          if (!container.children[c]) return false;
          if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;
        }

        return true;
      } else {
        /** @type {?} */
        var _current = containeePaths.slice(0, container.segments.length);
        /** @type {?} */


        var next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, _current)) return false;
        if (!container.children[PRIMARY_OUTLET]) return false;
        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
      }
    }
    /**
     * \@description
     *
     * Represents the parsed URL.
     *
     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
     * serialized tree.
     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
     *
     * \@usageNotes
     * ### Example
     *
     * ```
     * \@Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree =
     *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
     *     const f = tree.fragment; // return 'fragment'
     *     const q = tree.queryParams; // returns {debug: 'true'}
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
     *     g.children['support'].segments; // return 1 segment 'help'
     *   }
     * }
     * ```
     *
     * \@publicApi
     */


    var UrlTree = /*#__PURE__*/function () {
      /**
       * \@internal
       * @param {?} root
       * @param {?} queryParams
       * @param {?} fragment
       */
      function UrlTree(root, queryParams, fragment) {
        _classCallCheck(this, UrlTree);

        this.root = root;
        this.queryParams = queryParams;
        this.fragment = fragment;
      }
      /**
       * @return {?}
       */


      _createClass(UrlTree, [{
        key: "toString",

        /**
         * \@docsNotRequired
         * @return {?}
         */
        value: function toString() {
          return DEFAULT_SERIALIZER.serialize(this);
        }
      }, {
        key: "queryParamMap",
        get: function get() {
          if (!this._queryParamMap) {
            this._queryParamMap = convertToParamMap(this.queryParams);
          }

          return this._queryParamMap;
        }
      }]);

      return UrlTree;
    }();

    if (false) {}
    /**
     * \@description
     *
     * Represents the parsed URL segment group.
     *
     * See `UrlTree` for more information.
     *
     * \@publicApi
     */


    var UrlSegmentGroup = /*#__PURE__*/function () {
      /**
       * @param {?} segments
       * @param {?} children
       */
      function UrlSegmentGroup(segments, children) {
        var _this69 = this;

        _classCallCheck(this, UrlSegmentGroup);

        this.segments = segments;
        this.children = children;
        /**
         * The parent node in the url tree
         */

        this.parent = null;
        forEach(children,
        /**
        * @template THIS
        * @this {THIS}
        * @param {?} v
        * @param {?} k
        * @return {THIS}
        */
        function (v, k) {
          return v.parent = _this69;
        });
      }
      /**
       * Whether the segment has child segments
       * @return {?}
       */


      _createClass(UrlSegmentGroup, [{
        key: "hasChildren",
        value: function hasChildren() {
          return this.numberOfChildren > 0;
        }
        /**
         * Number of child segments
         * @return {?}
         */

      }, {
        key: "toString",

        /**
         * \@docsNotRequired
         * @return {?}
         */
        value: function toString() {
          return serializePaths(this);
        }
      }, {
        key: "numberOfChildren",
        get: function get() {
          return Object.keys(this.children).length;
        }
      }]);

      return UrlSegmentGroup;
    }();

    if (false) {}
    /**
     * \@description
     *
     * Represents a single URL segment.
     *
     * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
     * parameters associated with the segment.
     *
     * \@usageNotes
     *  ### Example
     *
     * ```
     * \@Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree = router.parseUrl('/team;id=33');
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments;
     *     s[0].path; // returns 'team'
     *     s[0].parameters; // returns {id: 33}
     *   }
     * }
     * ```
     *
     * \@publicApi
     */


    var UrlSegment = /*#__PURE__*/function () {
      /**
       * @param {?} path
       * @param {?} parameters
       */
      function UrlSegment(path, parameters) {
        _classCallCheck(this, UrlSegment);

        this.path = path;
        this.parameters = parameters;
      }
      /**
       * @return {?}
       */


      _createClass(UrlSegment, [{
        key: "toString",

        /**
         * \@docsNotRequired
         * @return {?}
         */
        value: function toString() {
          return serializePath(this);
        }
      }, {
        key: "parameterMap",
        get: function get() {
          if (!this._parameterMap) {
            this._parameterMap = convertToParamMap(this.parameters);
          }

          return this._parameterMap;
        }
      }]);

      return UrlSegment;
    }();

    if (false) {}
    /**
     * @param {?} as
     * @param {?} bs
     * @return {?}
     */


    function equalSegments(as, bs) {
      return equalPath(as, bs) && as.every(
      /**
      * @param {?} a
      * @param {?} i
      * @return {?}
      */
      function (a, i) {
        return shallowEqual(a.parameters, bs[i].parameters);
      });
    }
    /**
     * @param {?} as
     * @param {?} bs
     * @return {?}
     */


    function equalPath(as, bs) {
      if (as.length !== bs.length) return false;
      return as.every(
      /**
      * @param {?} a
      * @param {?} i
      * @return {?}
      */
      function (a, i) {
        return a.path === bs[i].path;
      });
    }
    /**
     * @template T
     * @param {?} segment
     * @param {?} fn
     * @return {?}
     */


    function mapChildrenIntoArray(segment, fn) {
      /** @type {?} */
      var res = [];
      forEach(segment.children,
      /**
      * @param {?} child
      * @param {?} childOutlet
      * @return {?}
      */
      function (child, childOutlet) {
        if (childOutlet === PRIMARY_OUTLET) {
          res = res.concat(fn(child, childOutlet));
        }
      });
      forEach(segment.children,
      /**
      * @param {?} child
      * @param {?} childOutlet
      * @return {?}
      */
      function (child, childOutlet) {
        if (childOutlet !== PRIMARY_OUTLET) {
          res = res.concat(fn(child, childOutlet));
        }
      });
      return res;
    }
    /**
     * \@description
     *
     * Serializes and deserializes a URL string into a URL tree.
     *
     * The url serialization strategy is customizable. You can
     * make all URLs case insensitive by providing a custom UrlSerializer.
     *
     * See `DefaultUrlSerializer` for an example of a URL serializer.
     *
     * \@publicApi
     * @abstract
     */


    var UrlSerializer = function UrlSerializer() {
      _classCallCheck(this, UrlSerializer);
    };

    if (false) {}
    /**
     * \@description
     *
     * A default implementation of the `UrlSerializer`.
     *
     * Example URLs:
     *
     * ```
     * /inbox/33(popup:compose)
     * /inbox/33;open=true/messages/44
     * ```
     *
     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
     * specify route specific parameters.
     *
     * \@publicApi
     */


    var DefaultUrlSerializer = /*#__PURE__*/function () {
      function DefaultUrlSerializer() {
        _classCallCheck(this, DefaultUrlSerializer);
      }

      _createClass(DefaultUrlSerializer, [{
        key: "parse",

        /**
         * Parses a url into a `UrlTree`
         * @param {?} url
         * @return {?}
         */
        value: function parse(url) {
          /** @type {?} */
          var p = new UrlParser(url);
          return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
        }
        /**
         * Converts a `UrlTree` into a url
         * @param {?} tree
         * @return {?}
         */

      }, {
        key: "serialize",
        value: function serialize(tree) {
          /** @type {?} */
          var segment = "/".concat(serializeSegment(tree.root, true));
          /** @type {?} */

          var query = serializeQueryParams(tree.queryParams);
          /** @type {?} */

          var fragment = typeof tree.fragment === "string" ? "#".concat(encodeUriFragment(
          /** @type {?} */
          tree.fragment)) : '';
          return "".concat(segment).concat(query).concat(fragment);
        }
      }]);

      return DefaultUrlSerializer;
    }();
    /** @type {?} */


    var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
    /**
     * @param {?} segment
     * @return {?}
     */

    function serializePaths(segment) {
      return segment.segments.map(
      /**
      * @param {?} p
      * @return {?}
      */
      function (p) {
        return serializePath(p);
      }).join('/');
    }
    /**
     * @param {?} segment
     * @param {?} root
     * @return {?}
     */


    function serializeSegment(segment, root) {
      if (!segment.hasChildren()) {
        return serializePaths(segment);
      }

      if (root) {
        /** @type {?} */
        var primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';
        /** @type {?} */

        var children = [];
        forEach(segment.children,
        /**
        * @param {?} v
        * @param {?} k
        * @return {?}
        */
        function (v, k) {
          if (k !== PRIMARY_OUTLET) {
            children.push("".concat(k, ":").concat(serializeSegment(v, false)));
          }
        });
        return children.length > 0 ? "".concat(primary, "(").concat(children.join('//'), ")") : primary;
      } else {
        /** @type {?} */
        var _children = mapChildrenIntoArray(segment,
        /**
        * @param {?} v
        * @param {?} k
        * @return {?}
        */
        function (v, k) {
          if (k === PRIMARY_OUTLET) {
            return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
          }

          return ["".concat(k, ":").concat(serializeSegment(v, false))];
        });

        return "".concat(serializePaths(segment), "/(").concat(_children.join('//'), ")");
      }
    }
    /**
     * Encodes a URI string with the default encoding. This function will only ever be called from
     * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need
     * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't
     * have to be encoded per https://url.spec.whatwg.org.
     * @param {?} s
     * @return {?}
     */


    function encodeUriString(s) {
      return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');
    }
    /**
     * This function should be used to encode both keys and values in a query string key/value. In
     * the following URL, you need to call encodeUriQuery on "k" and "v":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     * @param {?} s
     * @return {?}
     */


    function encodeUriQuery(s) {
      return encodeUriString(s).replace(/%3B/gi, ';');
    }
    /**
     * This function should be used to encode a URL fragment. In the following URL, you need to call
     * encodeUriFragment on "f":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     * @param {?} s
     * @return {?}
     */


    function encodeUriFragment(s) {
      return encodeURI(s);
    }
    /**
     * This function should be run on any URI segment as well as the key and value in a key/value
     * pair for matrix params. In the following URL, you need to call encodeUriSegment on "html",
     * "mk", and "mv":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     * @param {?} s
     * @return {?}
     */


    function encodeUriSegment(s) {
      return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
    }
    /**
     * @param {?} s
     * @return {?}
     */


    function decode(s) {
      return decodeURIComponent(s);
    } // Query keys/values should have the "+" replaced first, as "+" in a query string is " ".
    // decodeURIComponent function will not decode "+" as a space.

    /**
     * @param {?} s
     * @return {?}
     */


    function decodeQuery(s) {
      return decode(s.replace(/\+/g, '%20'));
    }
    /**
     * @param {?} path
     * @return {?}
     */


    function serializePath(path) {
      return "".concat(encodeUriSegment(path.path)).concat(serializeMatrixParams(path.parameters));
    }
    /**
     * @param {?} params
     * @return {?}
     */


    function serializeMatrixParams(params) {
      return Object.keys(params).map(
      /**
      * @param {?} key
      * @return {?}
      */
      function (key) {
        return ";".concat(encodeUriSegment(key), "=").concat(encodeUriSegment(params[key]));
      }).join('');
    }
    /**
     * @param {?} params
     * @return {?}
     */


    function serializeQueryParams(params) {
      /** @type {?} */
      var strParams = Object.keys(params).map(
      /**
      * @param {?} name
      * @return {?}
      */
      function (name) {
        /** @type {?} */
        var value = params[name];
        return Array.isArray(value) ? value.map(
        /**
        * @param {?} v
        * @return {?}
        */
        function (v) {
          return "".concat(encodeUriQuery(name), "=").concat(encodeUriQuery(v));
        }).join('&') : "".concat(encodeUriQuery(name), "=").concat(encodeUriQuery(value));
      });
      return strParams.length ? "?".concat(strParams.join('&')) : '';
    }
    /** @type {?} */


    var SEGMENT_RE = /^[^\/()?;=#]+/;
    /**
     * @param {?} str
     * @return {?}
     */

    function matchSegments(str) {
      /** @type {?} */
      var match = str.match(SEGMENT_RE);
      return match ? match[0] : '';
    }
    /** @type {?} */


    var QUERY_PARAM_RE = /^[^=?&#]+/; // Return the name of the query param at the start of the string or an empty string

    /**
     * @param {?} str
     * @return {?}
     */

    function matchQueryParams(str) {
      /** @type {?} */
      var match = str.match(QUERY_PARAM_RE);
      return match ? match[0] : '';
    }
    /** @type {?} */


    var QUERY_PARAM_VALUE_RE = /^[^?&#]+/; // Return the value of the query param at the start of the string or an empty string

    /**
     * @param {?} str
     * @return {?}
     */

    function matchUrlQueryParamValue(str) {
      /** @type {?} */
      var match = str.match(QUERY_PARAM_VALUE_RE);
      return match ? match[0] : '';
    }

    var UrlParser = /*#__PURE__*/function () {
      /**
       * @param {?} url
       */
      function UrlParser(url) {
        _classCallCheck(this, UrlParser);

        this.url = url;
        this.remaining = url;
      }
      /**
       * @return {?}
       */


      _createClass(UrlParser, [{
        key: "parseRootSegment",
        value: function parseRootSegment() {
          this.consumeOptional('/');

          if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
            return new UrlSegmentGroup([], {});
          } // The root segment group never has segments


          return new UrlSegmentGroup([], this.parseChildren());
        }
        /**
         * @return {?}
         */

      }, {
        key: "parseQueryParams",
        value: function parseQueryParams() {
          /** @type {?} */
          var params = {};

          if (this.consumeOptional('?')) {
            do {
              this.parseQueryParam(params);
            } while (this.consumeOptional('&'));
          }

          return params;
        }
        /**
         * @return {?}
         */

      }, {
        key: "parseFragment",
        value: function parseFragment() {
          return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "parseChildren",
        value: function parseChildren() {
          if (this.remaining === '') {
            return {};
          }

          this.consumeOptional('/');
          /** @type {?} */

          var segments = [];

          if (!this.peekStartsWith('(')) {
            segments.push(this.parseSegment());
          }

          while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
            this.capture('/');
            segments.push(this.parseSegment());
          }
          /** @type {?} */


          var children = {};

          if (this.peekStartsWith('/(')) {
            this.capture('/');
            children = this.parseParens(true);
          }
          /** @type {?} */


          var res = {};

          if (this.peekStartsWith('(')) {
            res = this.parseParens(false);
          }

          if (segments.length > 0 || Object.keys(children).length > 0) {
            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
          }

          return res;
        } // parse a segment with its matrix parameters
        // ie `name;k1=v1;k2`

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "parseSegment",
        value: function parseSegment() {
          /** @type {?} */
          var path = matchSegments(this.remaining);

          if (path === '' && this.peekStartsWith(';')) {
            throw new Error("Empty path url segment cannot have parameters: '".concat(this.remaining, "'."));
          }

          this.capture(path);
          return new UrlSegment(decode(path), this.parseMatrixParams());
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "parseMatrixParams",
        value: function parseMatrixParams() {
          /** @type {?} */
          var params = {};

          while (this.consumeOptional(';')) {
            this.parseParam(params);
          }

          return params;
        }
        /**
         * @private
         * @param {?} params
         * @return {?}
         */

      }, {
        key: "parseParam",
        value: function parseParam(params) {
          /** @type {?} */
          var key = matchSegments(this.remaining);

          if (!key) {
            return;
          }

          this.capture(key);
          /** @type {?} */

          var value = '';

          if (this.consumeOptional('=')) {
            /** @type {?} */
            var valueMatch = matchSegments(this.remaining);

            if (valueMatch) {
              value = valueMatch;
              this.capture(value);
            }
          }

          params[decode(key)] = decode(value);
        } // Parse a single query parameter `name[=value]`

        /**
         * @private
         * @param {?} params
         * @return {?}
         */

      }, {
        key: "parseQueryParam",
        value: function parseQueryParam(params) {
          /** @type {?} */
          var key = matchQueryParams(this.remaining);

          if (!key) {
            return;
          }

          this.capture(key);
          /** @type {?} */

          var value = '';

          if (this.consumeOptional('=')) {
            /** @type {?} */
            var valueMatch = matchUrlQueryParamValue(this.remaining);

            if (valueMatch) {
              value = valueMatch;
              this.capture(value);
            }
          }
          /** @type {?} */


          var decodedKey = decodeQuery(key);
          /** @type {?} */

          var decodedVal = decodeQuery(value);

          if (params.hasOwnProperty(decodedKey)) {
            // Append to existing values

            /** @type {?} */
            var currentVal = params[decodedKey];

            if (!Array.isArray(currentVal)) {
              currentVal = [currentVal];
              params[decodedKey] = currentVal;
            }

            currentVal.push(decodedVal);
          } else {
            // Create a new value
            params[decodedKey] = decodedVal;
          }
        } // parse `(a/b//outlet_name:c/d)`

        /**
         * @private
         * @param {?} allowPrimary
         * @return {?}
         */

      }, {
        key: "parseParens",
        value: function parseParens(allowPrimary) {
          /** @type {?} */
          var segments = {};
          this.capture('(');

          while (!this.consumeOptional(')') && this.remaining.length > 0) {
            /** @type {?} */
            var path = matchSegments(this.remaining);
            /** @type {?} */

            var next = this.remaining[path.length]; // if is is not one of these characters, then the segment was unescaped
            // or the group was not closed

            if (next !== '/' && next !== ')' && next !== ';') {
              throw new Error("Cannot parse url '".concat(this.url, "'"));
            }
            /** @type {?} */


            var outletName =
            /** @type {?} */
            undefined;

            if (path.indexOf(':') > -1) {
              outletName = path.substr(0, path.indexOf(':'));
              this.capture(outletName);
              this.capture(':');
            } else if (allowPrimary) {
              outletName = PRIMARY_OUTLET;
            }
            /** @type {?} */


            var children = this.parseChildren();
            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
            this.consumeOptional('//');
          }

          return segments;
        }
        /**
         * @private
         * @param {?} str
         * @return {?}
         */

      }, {
        key: "peekStartsWith",
        value: function peekStartsWith(str) {
          return this.remaining.startsWith(str);
        } // Consumes the prefix when it is present and returns whether it has been consumed

        /**
         * @private
         * @param {?} str
         * @return {?}
         */

      }, {
        key: "consumeOptional",
        value: function consumeOptional(str) {
          if (this.peekStartsWith(str)) {
            this.remaining = this.remaining.substring(str.length);
            return true;
          }

          return false;
        }
        /**
         * @private
         * @param {?} str
         * @return {?}
         */

      }, {
        key: "capture",
        value: function capture(str) {
          if (!this.consumeOptional(str)) {
            throw new Error("Expected \"".concat(str, "\"."));
          }
        }
      }]);

      return UrlParser;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/utils/tree.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @template T
     */


    var Tree = /*#__PURE__*/function () {
      /**
       * @param {?} root
       */
      function Tree(root) {
        _classCallCheck(this, Tree);

        this._root = root;
      }
      /**
       * @return {?}
       */


      _createClass(Tree, [{
        key: "parent",

        /**
         * \@internal
         * @param {?} t
         * @return {?}
         */
        value: function parent(t) {
          /** @type {?} */
          var p = this.pathFromRoot(t);
          return p.length > 1 ? p[p.length - 2] : null;
        }
        /**
         * \@internal
         * @param {?} t
         * @return {?}
         */

      }, {
        key: "children",
        value: function children(t) {
          /** @type {?} */
          var n = findNode(t, this._root);
          return n ? n.children.map(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            return t.value;
          }) : [];
        }
        /**
         * \@internal
         * @param {?} t
         * @return {?}
         */

      }, {
        key: "firstChild",
        value: function firstChild(t) {
          /** @type {?} */
          var n = findNode(t, this._root);
          return n && n.children.length > 0 ? n.children[0].value : null;
        }
        /**
         * \@internal
         * @param {?} t
         * @return {?}
         */

      }, {
        key: "siblings",
        value: function siblings(t) {
          /** @type {?} */
          var p = findPath(t, this._root);
          if (p.length < 2) return [];
          /** @type {?} */

          var c = p[p.length - 2].children.map(
          /**
          * @param {?} c
          * @return {?}
          */
          function (c) {
            return c.value;
          });
          return c.filter(
          /**
          * @param {?} cc
          * @return {?}
          */
          function (cc) {
            return cc !== t;
          });
        }
        /**
         * \@internal
         * @param {?} t
         * @return {?}
         */

      }, {
        key: "pathFromRoot",
        value: function pathFromRoot(t) {
          return findPath(t, this._root).map(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return s.value;
          });
        }
      }, {
        key: "root",
        get: function get() {
          return this._root.value;
        }
      }]);

      return Tree;
    }();

    if (false) {} // DFS for the node matching the value

    /**
     * @template T
     * @param {?} value
     * @param {?} node
     * @return {?}
     */


    function findNode(value, node) {
      if (value === node.value) return node;

      var _iterator3 = _createForOfIteratorHelper(node.children),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var child = _step3.value;

          /** @type {?} */
          var _node = findNode(value, child);

          if (_node) return _node;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return null;
    } // Return the path to the node with the given value using DFS

    /**
     * @template T
     * @param {?} value
     * @param {?} node
     * @return {?}
     */


    function findPath(value, node) {
      if (value === node.value) return [node];

      var _iterator4 = _createForOfIteratorHelper(node.children),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var child = _step4.value;

          /** @type {?} */
          var path = findPath(value, child);

          if (path.length) {
            path.unshift(node);
            return path;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return [];
    }
    /**
     * @template T
     */


    var TreeNode = /*#__PURE__*/function () {
      /**
       * @param {?} value
       * @param {?} children
       */
      function TreeNode(value, children) {
        _classCallCheck(this, TreeNode);

        this.value = value;
        this.children = children;
      }
      /**
       * @return {?}
       */


      _createClass(TreeNode, [{
        key: "toString",
        value: function toString() {
          return "TreeNode(".concat(this.value, ")");
        }
      }]);

      return TreeNode;
    }();

    if (false) {} // Return the list of T indexed by outlet name

    /**
     * @template T
     * @param {?} node
     * @return {?}
     */


    function nodeChildrenAsMap(node) {
      /** @type {?} */
      var map = {};

      if (node) {
        node.children.forEach(
        /**
        * @param {?} child
        * @return {?}
        */
        function (child) {
          return map[child.value.outlet] = child;
        });
      }

      return map;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router_state.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Represents the state of the router as a tree of activated routes.
     *
     * \@usageNotes
     *
     * Every node in the route tree is an `ActivatedRoute` instance
     * that knows about the "consumed" URL segments, the extracted parameters,
     * and the resolved data.
     * Use the `ActivatedRoute` properties to traverse the tree from any node.
     *
     * ### Example
     *
     * ```
     * \@Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const state: RouterState = router.routerState;
     *     const root: ActivatedRoute = state.root;
     *     const child = root.firstChild;
     *     const id: Observable<string> = child.params.map(p => p.id);
     *     //...
     *   }
     * }
     * ```
     *
     * @see `ActivatedRoute`
     *
     * \@publicApi
     */


    var RouterState = /*#__PURE__*/function (_Tree) {
      _inherits(RouterState, _Tree);

      var _super17 = _createSuper(RouterState);

      /**
       * \@internal
       * @param {?} root
       * @param {?} snapshot
       */
      function RouterState(root, snapshot) {
        var _this70;

        _classCallCheck(this, RouterState);

        _this70 = _super17.call(this, root);
        _this70.snapshot = snapshot;
        setRouterState(
        /** @type {?} */
        _assertThisInitialized(_this70), root);
        return _this70;
      }
      /**
       * @return {?}
       */


      _createClass(RouterState, [{
        key: "toString",
        value: function toString() {
          return this.snapshot.toString();
        }
      }]);

      return RouterState;
    }(Tree);

    if (false) {}
    /**
     * @param {?} urlTree
     * @param {?} rootComponent
     * @return {?}
     */


    function createEmptyState(urlTree, rootComponent) {
      /** @type {?} */
      var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
      /** @type {?} */

      var emptyUrl = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]([new UrlSegment('', {})]);
      /** @type {?} */

      var emptyParams = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]({});
      /** @type {?} */

      var emptyData = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]({});
      /** @type {?} */

      var emptyQueryParams = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]({});
      /** @type {?} */

      var fragment = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]('');
      /** @type {?} */

      var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
      activated.snapshot = snapshot.root;
      return new RouterState(new TreeNode(activated, []), snapshot);
    }
    /**
     * @param {?} urlTree
     * @param {?} rootComponent
     * @return {?}
     */


    function createEmptyStateSnapshot(urlTree, rootComponent) {
      /** @type {?} */
      var emptyParams = {};
      /** @type {?} */

      var emptyData = {};
      /** @type {?} */

      var emptyQueryParams = {};
      /** @type {?} */

      var fragment = '';
      /** @type {?} */

      var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
      return new RouterStateSnapshot('', new TreeNode(activated, []));
    }
    /**
     * Provides access to information about a route associated with a component
     * that is loaded in an outlet.
     * Use to traverse the `RouterState` tree and extract information from nodes.
     *
     * {\@example router/activated-route/module.ts region="activated-route"
     *     header="activated-route.component.ts"}
     *
     * \@publicApi
     */


    var ActivatedRoute = /*#__PURE__*/function () {
      /**
       * \@internal
       * @param {?} url
       * @param {?} params
       * @param {?} queryParams
       * @param {?} fragment
       * @param {?} data
       * @param {?} outlet
       * @param {?} component
       * @param {?} futureSnapshot
       */
      function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
        _classCallCheck(this, ActivatedRoute);

        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this._futureSnapshot = futureSnapshot;
      }
      /**
       * The configuration used to match this route.
       * @return {?}
       */


      _createClass(ActivatedRoute, [{
        key: "toString",

        /**
         * @return {?}
         */
        value: function toString() {
          return this.snapshot ? this.snapshot.toString() : "Future(".concat(this._futureSnapshot, ")");
        }
      }, {
        key: "routeConfig",
        get: function get() {
          return this._futureSnapshot.routeConfig;
        }
        /**
         * The root of the router state.
         * @return {?}
         */

      }, {
        key: "root",
        get: function get() {
          return this._routerState.root;
        }
        /**
         * The parent of this route in the router state tree.
         * @return {?}
         */

      }, {
        key: "parent",
        get: function get() {
          return this._routerState.parent(this);
        }
        /**
         * The first child of this route in the router state tree.
         * @return {?}
         */

      }, {
        key: "firstChild",
        get: function get() {
          return this._routerState.firstChild(this);
        }
        /**
         * The children of this route in the router state tree.
         * @return {?}
         */

      }, {
        key: "children",
        get: function get() {
          return this._routerState.children(this);
        }
        /**
         * The path from the root of the router state tree to this route.
         * @return {?}
         */

      }, {
        key: "pathFromRoot",
        get: function get() {
          return this._routerState.pathFromRoot(this);
        }
        /**
         * An Observable that contains a map of the required and optional parameters
         * specific to the route.
         * The map supports retrieving single and multiple values from the same parameter.
         * @return {?}
         */

      }, {
        key: "paramMap",
        get: function get() {
          if (!this._paramMap) {
            this._paramMap = this.params.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} p
            * @return {?}
            */
            function (p) {
              return convertToParamMap(p);
            }));
          }

          return this._paramMap;
        }
        /**
         * An Observable that contains a map of the query parameters available to all routes.
         * The map supports retrieving single and multiple values from the query parameter.
         * @return {?}
         */

      }, {
        key: "queryParamMap",
        get: function get() {
          if (!this._queryParamMap) {
            this._queryParamMap = this.queryParams.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} p
            * @return {?}
            */
            function (p) {
              return convertToParamMap(p);
            }));
          }

          return this._queryParamMap;
        }
      }]);

      return ActivatedRoute;
    }();

    if (false) {}
    /**
     * Returns the inherited params, data, and resolve for a given route.
     * By default, this only inherits values up to the nearest path-less or component-less route.
     * \@internal
     * @param {?} route
     * @param {?=} paramsInheritanceStrategy
     * @return {?}
     */


    function inheritedParamsDataResolve(route) {
      var paramsInheritanceStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'emptyOnly';

      /** @type {?} */
      var pathFromRoot = route.pathFromRoot;
      /** @type {?} */

      var inheritingStartingFrom = 0;

      if (paramsInheritanceStrategy !== 'always') {
        inheritingStartingFrom = pathFromRoot.length - 1;

        while (inheritingStartingFrom >= 1) {
          /** @type {?} */
          var current = pathFromRoot[inheritingStartingFrom];
          /** @type {?} */

          var parent = pathFromRoot[inheritingStartingFrom - 1]; // current route is an empty path => inherits its parent's params and data

          if (current.routeConfig && current.routeConfig.path === '') {
            inheritingStartingFrom--; // parent is componentless => current route should inherit its params and data
          } else if (!parent.component) {
            inheritingStartingFrom--;
          } else {
            break;
          }
        }
      }

      return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
    }
    /**
     * \@internal
     * @param {?} pathFromRoot
     * @return {?}
     */


    function flattenInherited(pathFromRoot) {
      return pathFromRoot.reduce(
      /**
      * @param {?} res
      * @param {?} curr
      * @return {?}
      */
      function (res, curr) {
        /** @type {?} */
        var params = Object.assign(Object.assign({}, res.params), curr.params);
        /** @type {?} */

        var data = Object.assign(Object.assign({}, res.data), curr.data);
        /** @type {?} */

        var resolve = Object.assign(Object.assign({}, res.resolve), curr._resolvedData);
        return {
          params: params,
          data: data,
          resolve: resolve
        };
      },
      /** @type {?} */
      {
        params: {},
        data: {},
        resolve: {}
      });
    }
    /**
     * \@description
     *
     * Contains the information about a route associated with a component loaded in an
     * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to
     * traverse the router state tree.
     *
     * ```
     * \@Component({templateUrl:'./my-component.html'})
     * class MyComponent {
     *   constructor(route: ActivatedRoute) {
     *     const id: string = route.snapshot.params.id;
     *     const url: string = route.snapshot.url.join('');
     *     const user = route.snapshot.data.user;
     *   }
     * }
     * ```
     *
     * \@publicApi
     */


    var ActivatedRouteSnapshot = /*#__PURE__*/function () {
      /**
       * \@internal
       * @param {?} url
       * @param {?} params
       * @param {?} queryParams
       * @param {?} fragment
       * @param {?} data
       * @param {?} outlet
       * @param {?} component
       * @param {?} routeConfig
       * @param {?} urlSegment
       * @param {?} lastPathIndex
       * @param {?} resolve
       */
      function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {
        _classCallCheck(this, ActivatedRouteSnapshot);

        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this.routeConfig = routeConfig;
        this._urlSegment = urlSegment;
        this._lastPathIndex = lastPathIndex;
        this._resolve = resolve;
      }
      /**
       * The root of the router state
       * @return {?}
       */


      _createClass(ActivatedRouteSnapshot, [{
        key: "toString",

        /**
         * @return {?}
         */
        value: function toString() {
          /** @type {?} */
          var url = this.url.map(
          /**
          * @param {?} segment
          * @return {?}
          */
          function (segment) {
            return segment.toString();
          }).join('/');
          /** @type {?} */

          var matched = this.routeConfig ? this.routeConfig.path : '';
          return "Route(url:'".concat(url, "', path:'").concat(matched, "')");
        }
      }, {
        key: "root",
        get: function get() {
          return this._routerState.root;
        }
        /**
         * The parent of this route in the router state tree
         * @return {?}
         */

      }, {
        key: "parent",
        get: function get() {
          return this._routerState.parent(this);
        }
        /**
         * The first child of this route in the router state tree
         * @return {?}
         */

      }, {
        key: "firstChild",
        get: function get() {
          return this._routerState.firstChild(this);
        }
        /**
         * The children of this route in the router state tree
         * @return {?}
         */

      }, {
        key: "children",
        get: function get() {
          return this._routerState.children(this);
        }
        /**
         * The path from the root of the router state tree to this route
         * @return {?}
         */

      }, {
        key: "pathFromRoot",
        get: function get() {
          return this._routerState.pathFromRoot(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "paramMap",
        get: function get() {
          if (!this._paramMap) {
            this._paramMap = convertToParamMap(this.params);
          }

          return this._paramMap;
        }
        /**
         * @return {?}
         */

      }, {
        key: "queryParamMap",
        get: function get() {
          if (!this._queryParamMap) {
            this._queryParamMap = convertToParamMap(this.queryParams);
          }

          return this._queryParamMap;
        }
      }]);

      return ActivatedRouteSnapshot;
    }();

    if (false) {}
    /**
     * \@description
     *
     * Represents the state of the router at a moment in time.
     *
     * This is a tree of activated route snapshots. Every node in this tree knows about
     * the "consumed" URL segments, the extracted parameters, and the resolved data.
     *
     * \@usageNotes
     * ### Example
     *
     * ```
     * \@Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const state: RouterState = router.routerState;
     *     const snapshot: RouterStateSnapshot = state.snapshot;
     *     const root: ActivatedRouteSnapshot = snapshot.root;
     *     const child = root.firstChild;
     *     const id: Observable<string> = child.params.map(p => p.id);
     *     //...
     *   }
     * }
     * ```
     *
     * \@publicApi
     */


    var RouterStateSnapshot = /*#__PURE__*/function (_Tree2) {
      _inherits(RouterStateSnapshot, _Tree2);

      var _super18 = _createSuper(RouterStateSnapshot);

      /**
       * \@internal
       * @param {?} url
       * @param {?} root
       */
      function RouterStateSnapshot(url, root) {
        var _this71;

        _classCallCheck(this, RouterStateSnapshot);

        _this71 = _super18.call(this, root);
        _this71.url = url;
        setRouterState(
        /** @type {?} */
        _assertThisInitialized(_this71), root);
        return _this71;
      }
      /**
       * @return {?}
       */


      _createClass(RouterStateSnapshot, [{
        key: "toString",
        value: function toString() {
          return serializeNode(this._root);
        }
      }]);

      return RouterStateSnapshot;
    }(Tree);

    if (false) {}
    /**
     * @template U, T
     * @param {?} state
     * @param {?} node
     * @return {?}
     */


    function setRouterState(state, node) {
      node.value._routerState = state;
      node.children.forEach(
      /**
      * @param {?} c
      * @return {?}
      */
      function (c) {
        return setRouterState(state, c);
      });
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function serializeNode(node) {
      /** @type {?} */
      var c = node.children.length > 0 ? " { ".concat(node.children.map(serializeNode).join(', '), " } ") : '';
      return "".concat(node.value).concat(c);
    }
    /**
     * The expectation is that the activate route is created with the right set of parameters.
     * So we push new values into the observables only when they are not the initial values.
     * And we detect that by checking if the snapshot field is set.
     * @param {?} route
     * @return {?}
     */


    function advanceActivatedRoute(route) {
      if (route.snapshot) {
        /** @type {?} */
        var currentSnapshot = route.snapshot;
        /** @type {?} */

        var nextSnapshot = route._futureSnapshot;
        route.snapshot = nextSnapshot;

        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
          /** @type {?} */
          route.queryParams.next(nextSnapshot.queryParams);
        }

        if (currentSnapshot.fragment !== nextSnapshot.fragment) {
          /** @type {?} */
          route.fragment.next(nextSnapshot.fragment);
        }

        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
          /** @type {?} */
          route.params.next(nextSnapshot.params);
        }

        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
          /** @type {?} */
          route.url.next(nextSnapshot.url);
        }

        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
          /** @type {?} */
          route.data.next(nextSnapshot.data);
        }
      } else {
        route.snapshot = route._futureSnapshot; // this is for resolved data

        /** @type {?} */
        route.data.next(route._futureSnapshot.data);
      }
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function equalParamsAndUrlSegments(a, b) {
      /** @type {?} */
      var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
      /** @type {?} */

      var parentsMismatch = !a.parent !== !b.parent;
      return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent,
      /** @type {?} */
      b.parent));
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/create_router_state.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} routeReuseStrategy
     * @param {?} curr
     * @param {?} prevState
     * @return {?}
     */


    function createRouterState(routeReuseStrategy, curr, prevState) {
      /** @type {?} */
      var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
      return new RouterState(root, curr);
    }
    /**
     * @param {?} routeReuseStrategy
     * @param {?} curr
     * @param {?=} prevState
     * @return {?}
     */


    function createNode(routeReuseStrategy, curr, prevState) {
      // reuse an activated route that is currently displayed on the screen
      if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
        /** @type {?} */
        var value = prevState.value;
        value._futureSnapshot = curr.value;
        /** @type {?} */

        var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
        return new TreeNode(value, children); // retrieve an activated route that is used to be displayed, but is not currently displayed
      } else {
        /** @type {?} */
        var detachedRouteHandle =
        /** @type {?} */
        routeReuseStrategy.retrieve(curr.value);

        if (detachedRouteHandle) {
          /** @type {?} */
          var _tree = detachedRouteHandle.route;
          setFutureSnapshotsOfActivatedRoutes(curr, _tree);
          return _tree;
        } else {
          /** @type {?} */
          var _value2 = createActivatedRoute(curr.value);
          /** @type {?} */


          var _children2 = curr.children.map(
          /**
          * @param {?} c
          * @return {?}
          */
          function (c) {
            return createNode(routeReuseStrategy, c);
          });

          return new TreeNode(_value2, _children2);
        }
      }
    }
    /**
     * @param {?} curr
     * @param {?} result
     * @return {?}
     */


    function setFutureSnapshotsOfActivatedRoutes(curr, result) {
      if (curr.value.routeConfig !== result.value.routeConfig) {
        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
      }

      if (curr.children.length !== result.children.length) {
        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
      }

      result.value._futureSnapshot = curr.value;

      for (var i = 0; i < curr.children.length; ++i) {
        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
      }
    }
    /**
     * @param {?} routeReuseStrategy
     * @param {?} curr
     * @param {?} prevState
     * @return {?}
     */


    function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
      return curr.children.map(
      /**
      * @param {?} child
      * @return {?}
      */
      function (child) {
        var _iterator5 = _createForOfIteratorHelper(prevState.children),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var p = _step5.value;

            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
              return createNode(routeReuseStrategy, child, p);
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return createNode(routeReuseStrategy, child);
      });
    }
    /**
     * @param {?} c
     * @return {?}
     */


    function createActivatedRoute(c) {
      return new ActivatedRoute(new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](c.url), new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](c.params), new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](c.queryParams), new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](c.fragment), new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](c.data), c.outlet, c.component, c);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/create_url_tree.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} route
     * @param {?} urlTree
     * @param {?} commands
     * @param {?} queryParams
     * @param {?} fragment
     * @return {?}
     */


    function _createUrlTree(route, urlTree, commands, queryParams, fragment) {
      if (commands.length === 0) {
        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
      }
      /** @type {?} */


      var nav = computeNavigation(commands);

      if (nav.toRoot()) {
        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
      }
      /** @type {?} */


      var startingPosition = findStartingPosition(nav, urlTree, route);
      /** @type {?} */

      var segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
      return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
    }
    /**
     * @param {?} command
     * @return {?}
     */


    function isMatrixParams(command) {
      return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
    }
    /**
     * @param {?} oldSegmentGroup
     * @param {?} newSegmentGroup
     * @param {?} urlTree
     * @param {?} queryParams
     * @param {?} fragment
     * @return {?}
     */


    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
      /** @type {?} */
      var qp = {};

      if (queryParams) {
        forEach(queryParams,
        /**
        * @param {?} value
        * @param {?} name
        * @return {?}
        */
        function (value, name) {
          qp[name] = Array.isArray(value) ? value.map(
          /**
          * @param {?} v
          * @return {?}
          */
          function (v) {
            return "".concat(v);
          }) : "".concat(value);
        });
      }

      if (urlTree.root === oldSegmentGroup) {
        return new UrlTree(newSegmentGroup, qp, fragment);
      }

      return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
    }
    /**
     * @param {?} current
     * @param {?} oldSegment
     * @param {?} newSegment
     * @return {?}
     */


    function replaceSegment(current, oldSegment, newSegment) {
      /** @type {?} */
      var children = {};
      forEach(current.children,
      /**
      * @param {?} c
      * @param {?} outletName
      * @return {?}
      */
      function (c, outletName) {
        if (c === oldSegment) {
          children[outletName] = newSegment;
        } else {
          children[outletName] = replaceSegment(c, oldSegment, newSegment);
        }
      });
      return new UrlSegmentGroup(current.segments, children);
    }

    var Navigation = /*#__PURE__*/function () {
      /**
       * @param {?} isAbsolute
       * @param {?} numberOfDoubleDots
       * @param {?} commands
       */
      function Navigation(isAbsolute, numberOfDoubleDots, commands) {
        _classCallCheck(this, Navigation);

        this.isAbsolute = isAbsolute;
        this.numberOfDoubleDots = numberOfDoubleDots;
        this.commands = commands;

        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
          throw new Error('Root segment cannot have matrix parameters');
        }
        /** @type {?} */


        var cmdWithOutlet = commands.find(
        /**
        * @param {?} c
        * @return {?}
        */
        function (c) {
          return typeof c === 'object' && c != null && c.outlets;
        });

        if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {
          throw new Error('{outlets:{}} has to be the last command');
        }
      }
      /**
       * @return {?}
       */


      _createClass(Navigation, [{
        key: "toRoot",
        value: function toRoot() {
          return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
        }
      }]);

      return Navigation;
    }();

    if (false) {}
    /**
     * Transforms commands to a normalized `Navigation`
     * @param {?} commands
     * @return {?}
     */


    function computeNavigation(commands) {
      if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {
        return new Navigation(true, 0, commands);
      }
      /** @type {?} */


      var numberOfDoubleDots = 0;
      /** @type {?} */

      var isAbsolute = false;
      /** @type {?} */

      var res = commands.reduce(
      /**
      * @param {?} res
      * @param {?} cmd
      * @param {?} cmdIdx
      * @return {?}
      */
      function (res, cmd, cmdIdx) {
        if (typeof cmd === 'object' && cmd != null) {
          if (cmd.outlets) {
            /** @type {?} */
            var outlets = {};
            forEach(cmd.outlets,
            /**
            * @param {?} commands
            * @param {?} name
            * @return {?}
            */
            function (commands, name) {
              outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;
            });
            return [].concat(_toConsumableArray(res), [{
              outlets: outlets
            }]);
          }

          if (cmd.segmentPath) {
            return [].concat(_toConsumableArray(res), [cmd.segmentPath]);
          }
        }

        if (!(typeof cmd === 'string')) {
          return [].concat(_toConsumableArray(res), [cmd]);
        }

        if (cmdIdx === 0) {
          cmd.split('/').forEach(
          /**
          * @param {?} urlPart
          * @param {?} partIndex
          * @return {?}
          */
          function (urlPart, partIndex) {
            if (partIndex == 0 && urlPart === '.') {// skip './a'
            } else if (partIndex == 0 && urlPart === '') {
              //  '/a'
              isAbsolute = true;
            } else if (urlPart === '..') {
              //  '../a'
              numberOfDoubleDots++;
            } else if (urlPart != '') {
              res.push(urlPart);
            }
          });
          return res;
        }

        return [].concat(_toConsumableArray(res), [cmd]);
      }, []);
      return new Navigation(isAbsolute, numberOfDoubleDots, res);
    }

    var Position =
    /**
     * @param {?} segmentGroup
     * @param {?} processChildren
     * @param {?} index
     */
    function Position(segmentGroup, processChildren, index) {
      _classCallCheck(this, Position);

      this.segmentGroup = segmentGroup;
      this.processChildren = processChildren;
      this.index = index;
    };

    if (false) {}
    /**
     * @param {?} nav
     * @param {?} tree
     * @param {?} route
     * @return {?}
     */


    function findStartingPosition(nav, tree, route) {
      if (nav.isAbsolute) {
        return new Position(tree.root, true, 0);
      }

      if (route.snapshot._lastPathIndex === -1) {
        return new Position(route.snapshot._urlSegment, true, 0);
      }
      /** @type {?} */


      var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
      /** @type {?} */

      var index = route.snapshot._lastPathIndex + modifier;
      return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
    }
    /**
     * @param {?} group
     * @param {?} index
     * @param {?} numberOfDoubleDots
     * @return {?}
     */


    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
      /** @type {?} */
      var g = group;
      /** @type {?} */

      var ci = index;
      /** @type {?} */

      var dd = numberOfDoubleDots;

      while (dd > ci) {
        dd -= ci;
        g =
        /** @type {?} */
        g.parent;

        if (!g) {
          throw new Error('Invalid number of \'../\'');
        }

        ci = g.segments.length;
      }

      return new Position(g, false, ci - dd);
    }
    /**
     * @param {?} command
     * @return {?}
     */


    function getPath(command) {
      if (typeof command === 'object' && command != null && command.outlets) {
        return command.outlets[PRIMARY_OUTLET];
      }

      return "".concat(command);
    }
    /**
     * @param {?} commands
     * @return {?}
     */


    function getOutlets(commands) {
      if (!(typeof commands[0] === 'object')) return _defineProperty({}, PRIMARY_OUTLET, commands);
      if (commands[0].outlets === undefined) return _defineProperty({}, PRIMARY_OUTLET, commands);
      return commands[0].outlets;
    }
    /**
     * @param {?} segmentGroup
     * @param {?} startIndex
     * @param {?} commands
     * @return {?}
     */


    function updateSegmentGroup(segmentGroup, startIndex, commands) {
      if (!segmentGroup) {
        segmentGroup = new UrlSegmentGroup([], {});
      }

      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
      }
      /** @type {?} */


      var m = prefixedWith(segmentGroup, startIndex, commands);
      /** @type {?} */

      var slicedCommands = commands.slice(m.commandIndex);

      if (m.match && m.pathIndex < segmentGroup.segments.length) {
        /** @type {?} */
        var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
        g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
        return updateSegmentGroupChildren(g, 0, slicedCommands);
      } else if (m.match && slicedCommands.length === 0) {
        return new UrlSegmentGroup(segmentGroup.segments, {});
      } else if (m.match && !segmentGroup.hasChildren()) {
        return createNewSegmentGroup(segmentGroup, startIndex, commands);
      } else if (m.match) {
        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
      } else {
        return createNewSegmentGroup(segmentGroup, startIndex, commands);
      }
    }
    /**
     * @param {?} segmentGroup
     * @param {?} startIndex
     * @param {?} commands
     * @return {?}
     */


    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
      if (commands.length === 0) {
        return new UrlSegmentGroup(segmentGroup.segments, {});
      } else {
        /** @type {?} */
        var outlets = getOutlets(commands);
        /** @type {?} */

        var children = {};
        forEach(outlets,
        /**
        * @param {?} commands
        * @param {?} outlet
        * @return {?}
        */
        function (commands, outlet) {
          if (commands !== null) {
            children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
          }
        });
        forEach(segmentGroup.children,
        /**
        * @param {?} child
        * @param {?} childOutlet
        * @return {?}
        */
        function (child, childOutlet) {
          if (outlets[childOutlet] === undefined) {
            children[childOutlet] = child;
          }
        });
        return new UrlSegmentGroup(segmentGroup.segments, children);
      }
    }
    /**
     * @param {?} segmentGroup
     * @param {?} startIndex
     * @param {?} commands
     * @return {?}
     */


    function prefixedWith(segmentGroup, startIndex, commands) {
      /** @type {?} */
      var currentCommandIndex = 0;
      /** @type {?} */

      var currentPathIndex = startIndex;
      /** @type {?} */

      var noMatch = {
        match: false,
        pathIndex: 0,
        commandIndex: 0
      };

      while (currentPathIndex < segmentGroup.segments.length) {
        if (currentCommandIndex >= commands.length) return noMatch;
        /** @type {?} */

        var path = segmentGroup.segments[currentPathIndex];
        /** @type {?} */

        var curr = getPath(commands[currentCommandIndex]);
        /** @type {?} */

        var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
        if (currentPathIndex > 0 && curr === undefined) break;

        if (curr && next && typeof next === 'object' && next.outlets === undefined) {
          if (!compare(curr, next, path)) return noMatch;
          currentCommandIndex += 2;
        } else {
          if (!compare(curr, {}, path)) return noMatch;
          currentCommandIndex++;
        }

        currentPathIndex++;
      }

      return {
        match: true,
        pathIndex: currentPathIndex,
        commandIndex: currentCommandIndex
      };
    }
    /**
     * @param {?} segmentGroup
     * @param {?} startIndex
     * @param {?} commands
     * @return {?}
     */


    function createNewSegmentGroup(segmentGroup, startIndex, commands) {
      /** @type {?} */
      var paths = segmentGroup.segments.slice(0, startIndex);
      /** @type {?} */

      var i = 0;

      while (i < commands.length) {
        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
          /** @type {?} */
          var children = createNewSegmentChildren(commands[i].outlets);
          return new UrlSegmentGroup(paths, children);
        } // if we start with an object literal, we need to reuse the path part from the segment


        if (i === 0 && isMatrixParams(commands[0])) {
          /** @type {?} */
          var p = segmentGroup.segments[startIndex];
          paths.push(new UrlSegment(p.path, commands[0]));
          i++;
          continue;
        }
        /** @type {?} */


        var curr = getPath(commands[i]);
        /** @type {?} */

        var next = i < commands.length - 1 ? commands[i + 1] : null;

        if (curr && next && isMatrixParams(next)) {
          paths.push(new UrlSegment(curr, stringify(next)));
          i += 2;
        } else {
          paths.push(new UrlSegment(curr, {}));
          i++;
        }
      }

      return new UrlSegmentGroup(paths, {});
    }
    /**
     * @param {?} outlets
     * @return {?}
     */


    function createNewSegmentChildren(outlets) {
      /** @type {?} */
      var children = {};
      forEach(outlets,
      /**
      * @param {?} commands
      * @param {?} outlet
      * @return {?}
      */
      function (commands, outlet) {
        if (commands !== null) {
          children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
        }
      });
      return children;
    }
    /**
     * @param {?} params
     * @return {?}
     */


    function stringify(params) {
      /** @type {?} */
      var res = {};
      forEach(params,
      /**
      * @param {?} v
      * @param {?} k
      * @return {?}
      */
      function (v, k) {
        return res[k] = "".concat(v);
      });
      return res;
    }
    /**
     * @param {?} path
     * @param {?} params
     * @param {?} segment
     * @return {?}
     */


    function compare(path, params, segment) {
      return path == segment.path && shallowEqual(params, segment.parameters);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/activate_routes.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var activateRoutes =
    /**
    * @param {?} rootContexts
    * @param {?} routeReuseStrategy
    * @param {?} forwardEvent
    * @return {?}
    */
    function activateRoutes(rootContexts, routeReuseStrategy, forwardEvent) {
      return Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
      /**
      * @param {?} t
      * @return {?}
      */
      function (t) {
        new ActivateRoutes(routeReuseStrategy,
        /** @type {?} */
        t.targetRouterState, t.currentRouterState, forwardEvent).activate(rootContexts);
        return t;
      });
    };

    var ActivateRoutes = /*#__PURE__*/function () {
      /**
       * @param {?} routeReuseStrategy
       * @param {?} futureState
       * @param {?} currState
       * @param {?} forwardEvent
       */
      function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {
        _classCallCheck(this, ActivateRoutes);

        this.routeReuseStrategy = routeReuseStrategy;
        this.futureState = futureState;
        this.currState = currState;
        this.forwardEvent = forwardEvent;
      }
      /**
       * @param {?} parentContexts
       * @return {?}
       */


      _createClass(ActivateRoutes, [{
        key: "activate",
        value: function activate(parentContexts) {
          /** @type {?} */
          var futureRoot = this.futureState._root;
          /** @type {?} */

          var currRoot = this.currState ? this.currState._root : null;
          this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
          advanceActivatedRoute(this.futureState.root);
          this.activateChildRoutes(futureRoot, currRoot, parentContexts);
        } // De-activate the child route that are not re-used for the future state

        /**
         * @private
         * @param {?} futureNode
         * @param {?} currNode
         * @param {?} contexts
         * @return {?}
         */

      }, {
        key: "deactivateChildRoutes",
        value: function deactivateChildRoutes(futureNode, currNode, contexts) {
          var _this72 = this;

          /** @type {?} */
          var children = nodeChildrenAsMap(currNode); // Recurse on the routes active in the future state to de-activate deeper children

          futureNode.children.forEach(
          /**
          * @param {?} futureChild
          * @return {?}
          */
          function (futureChild) {
            /** @type {?} */
            var childOutletName = futureChild.value.outlet;

            _this72.deactivateRoutes(futureChild, children[childOutletName], contexts);

            delete children[childOutletName];
          }); // De-activate the routes that will not be re-used

          forEach(children,
          /**
          * @param {?} v
          * @param {?} childName
          * @return {?}
          */
          function (v, childName) {
            _this72.deactivateRouteAndItsChildren(v, contexts);
          });
        }
        /**
         * @private
         * @param {?} futureNode
         * @param {?} currNode
         * @param {?} parentContext
         * @return {?}
         */

      }, {
        key: "deactivateRoutes",
        value: function deactivateRoutes(futureNode, currNode, parentContext) {
          /** @type {?} */
          var future = futureNode.value;
          /** @type {?} */

          var curr = currNode ? currNode.value : null;

          if (future === curr) {
            // Reusing the node, check to see if the children need to be de-activated
            if (future.component) {
              // If we have a normal route, we need to go through an outlet.

              /** @type {?} */
              var context = parentContext.getContext(future.outlet);

              if (context) {
                this.deactivateChildRoutes(futureNode, currNode, context.children);
              }
            } else {
              // if we have a componentless route, we recurse but keep the same outlet map.
              this.deactivateChildRoutes(futureNode, currNode, parentContext);
            }
          } else {
            if (curr) {
              // Deactivate the current route which will not be re-used
              this.deactivateRouteAndItsChildren(currNode, parentContext);
            }
          }
        }
        /**
         * @private
         * @param {?} route
         * @param {?} parentContexts
         * @return {?}
         */

      }, {
        key: "deactivateRouteAndItsChildren",
        value: function deactivateRouteAndItsChildren(route, parentContexts) {
          if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
            this.detachAndStoreRouteSubtree(route, parentContexts);
          } else {
            this.deactivateRouteAndOutlet(route, parentContexts);
          }
        }
        /**
         * @private
         * @param {?} route
         * @param {?} parentContexts
         * @return {?}
         */

      }, {
        key: "detachAndStoreRouteSubtree",
        value: function detachAndStoreRouteSubtree(route, parentContexts) {
          /** @type {?} */
          var context = parentContexts.getContext(route.value.outlet);

          if (context && context.outlet) {
            /** @type {?} */
            var componentRef = context.outlet.detach();
            /** @type {?} */

            var contexts = context.children.onOutletDeactivated();
            this.routeReuseStrategy.store(route.value.snapshot, {
              componentRef: componentRef,
              route: route,
              contexts: contexts
            });
          }
        }
        /**
         * @private
         * @param {?} route
         * @param {?} parentContexts
         * @return {?}
         */

      }, {
        key: "deactivateRouteAndOutlet",
        value: function deactivateRouteAndOutlet(route, parentContexts) {
          var _this73 = this;

          /** @type {?} */
          var context = parentContexts.getContext(route.value.outlet);

          if (context) {
            /** @type {?} */
            var children = nodeChildrenAsMap(route);
            /** @type {?} */

            var contexts = route.value.component ? context.children : parentContexts;
            forEach(children,
            /**
            * @param {?} v
            * @param {?} k
            * @return {?}
            */
            function (v, k) {
              return _this73.deactivateRouteAndItsChildren(v, contexts);
            });

            if (context.outlet) {
              // Destroy the component
              context.outlet.deactivate(); // Destroy the contexts for all the outlets that were in the component

              context.children.onOutletDeactivated();
            }
          }
        }
        /**
         * @private
         * @param {?} futureNode
         * @param {?} currNode
         * @param {?} contexts
         * @return {?}
         */

      }, {
        key: "activateChildRoutes",
        value: function activateChildRoutes(futureNode, currNode, contexts) {
          var _this74 = this;

          /** @type {?} */
          var children = nodeChildrenAsMap(currNode);
          futureNode.children.forEach(
          /**
          * @param {?} c
          * @return {?}
          */
          function (c) {
            _this74.activateRoutes(c, children[c.value.outlet], contexts);

            _this74.forwardEvent(new ActivationEnd(c.value.snapshot));
          });

          if (futureNode.children.length) {
            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
          }
        }
        /**
         * @private
         * @param {?} futureNode
         * @param {?} currNode
         * @param {?} parentContexts
         * @return {?}
         */

      }, {
        key: "activateRoutes",
        value: function activateRoutes(futureNode, currNode, parentContexts) {
          /** @type {?} */
          var future = futureNode.value;
          /** @type {?} */

          var curr = currNode ? currNode.value : null;
          advanceActivatedRoute(future); // reusing the node

          if (future === curr) {
            if (future.component) {
              // If we have a normal route, we need to go through an outlet.

              /** @type {?} */
              var context = parentContexts.getOrCreateContext(future.outlet);
              this.activateChildRoutes(futureNode, currNode, context.children);
            } else {
              // if we have a componentless route, we recurse but keep the same outlet map.
              this.activateChildRoutes(futureNode, currNode, parentContexts);
            }
          } else {
            if (future.component) {
              // if we have a normal route, we need to place the component into the outlet and recurse.

              /** @type {?} */
              var _context3 = parentContexts.getOrCreateContext(future.outlet);

              if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                /** @type {?} */
                var stored =
                /** @type {?} */
                this.routeReuseStrategy.retrieve(future.snapshot);
                this.routeReuseStrategy.store(future.snapshot, null);

                _context3.children.onOutletReAttached(stored.contexts);

                _context3.attachRef = stored.componentRef;
                _context3.route = stored.route.value;

                if (_context3.outlet) {
                  // Attach right away when the outlet has already been instantiated
                  // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
                  _context3.outlet.attach(stored.componentRef, stored.route.value);
                }

                advanceActivatedRouteNodeAndItsChildren(stored.route);
              } else {
                /** @type {?} */
                var config = parentLoadedConfig(future.snapshot);
                /** @type {?} */

                var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
                _context3.attachRef = null;
                _context3.route = future;
                _context3.resolver = cmpFactoryResolver;

                if (_context3.outlet) {
                  // Activate the outlet when it has already been instantiated
                  // Otherwise it will get activated from its `ngOnInit` when instantiated
                  _context3.outlet.activateWith(future, cmpFactoryResolver);
                }

                this.activateChildRoutes(futureNode, null, _context3.children);
              }
            } else {
              // if we have a componentless route, we recurse but keep the same outlet map.
              this.activateChildRoutes(futureNode, null, parentContexts);
            }
          }
        }
      }]);

      return ActivateRoutes;
    }();

    if (false) {}
    /**
     * @param {?} node
     * @return {?}
     */


    function advanceActivatedRouteNodeAndItsChildren(node) {
      advanceActivatedRoute(node.value);
      node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
    }
    /**
     * @param {?} snapshot
     * @return {?}
     */


    function parentLoadedConfig(snapshot) {
      for (var s = snapshot.parent; s; s = s.parent) {
        /** @type {?} */
        var route = s.routeConfig;
        if (route && route._loadedConfig) return route._loadedConfig;
        if (route && route.component) return null;
      }

      return null;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/utils/type_guards.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Simple function check, but generic so type inference will flow. Example:
     *
     * function product(a: number, b: number) {
     *   return a * b;
     * }
     *
     * if (isFunction<product>(fn)) {
     *   return fn(1, 2);
     * } else {
     *   throw "Must provide the `product` function";
     * }
     * @template T
     * @param {?} v
     * @return {?}
     */


    function isFunction(v) {
      return typeof v === 'function';
    }
    /**
     * @param {?} v
     * @return {?}
     */


    function isBoolean(v) {
      return typeof v === 'boolean';
    }
    /**
     * @param {?} v
     * @return {?}
     */


    function isUrlTree(v) {
      return v instanceof UrlTree;
    }
    /**
     * @param {?} guard
     * @return {?}
     */


    function isCanLoad(guard) {
      return guard && isFunction(guard.canLoad);
    }
    /**
     * @param {?} guard
     * @return {?}
     */


    function isCanActivate(guard) {
      return guard && isFunction(guard.canActivate);
    }
    /**
     * @param {?} guard
     * @return {?}
     */


    function isCanActivateChild(guard) {
      return guard && isFunction(guard.canActivateChild);
    }
    /**
     * @template T
     * @param {?} guard
     * @return {?}
     */


    function isCanDeactivate(guard) {
      return guard && isFunction(guard.canDeactivate);
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/apply_redirects.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NoMatch =
    /**
     * @param {?=} segmentGroup
     */
    function NoMatch(segmentGroup) {
      _classCallCheck(this, NoMatch);

      this.segmentGroup = segmentGroup || null;
    };

    if (false) {}

    var AbsoluteRedirect =
    /**
     * @param {?} urlTree
     */
    function AbsoluteRedirect(urlTree) {
      _classCallCheck(this, AbsoluteRedirect);

      this.urlTree = urlTree;
    };

    if (false) {}
    /**
     * @param {?} segmentGroup
     * @return {?}
     */


    function noMatch(segmentGroup) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
      /**
      * @param {?} obs
      * @return {?}
      */
      function (obs) {
        return obs.error(new NoMatch(segmentGroup));
      });
    }
    /**
     * @param {?} newTree
     * @return {?}
     */


    function absoluteRedirect(newTree) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
      /**
      * @param {?} obs
      * @return {?}
      */
      function (obs) {
        return obs.error(new AbsoluteRedirect(newTree));
      });
    }
    /**
     * @param {?} redirectTo
     * @return {?}
     */


    function namedOutletsRedirect(redirectTo) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
      /**
      * @param {?} obs
      * @return {?}
      */
      function (obs) {
        return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '".concat(redirectTo, "'")));
      });
    }
    /**
     * @param {?} route
     * @return {?}
     */


    function canLoadFails(route) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
      /**
      * @param {?} obs
      * @return {?}
      */
      function (obs) {
        return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '".concat(route.path, "'\" returned false")));
      });
    }
    /**
     * Returns the `UrlTree` with the redirection applied.
     *
     * Lazy modules are loaded along the way.
     * @param {?} moduleInjector
     * @param {?} configLoader
     * @param {?} urlSerializer
     * @param {?} urlTree
     * @param {?} config
     * @return {?}
     */


    function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
      return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();
    }

    var ApplyRedirects = /*#__PURE__*/function () {
      /**
       * @param {?} moduleInjector
       * @param {?} configLoader
       * @param {?} urlSerializer
       * @param {?} urlTree
       * @param {?} config
       */
      function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
        _classCallCheck(this, ApplyRedirects);

        this.configLoader = configLoader;
        this.urlSerializer = urlSerializer;
        this.urlTree = urlTree;
        this.config = config;
        this.allowRedirects = true;
        this.ngModule = moduleInjector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"]);
      }
      /**
       * @return {?}
       */


      _createClass(ApplyRedirects, [{
        key: "apply",
        value: function apply() {
          var _this75 = this;

          /** @type {?} */
          var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);
          /** @type {?} */

          var urlTrees$ = expanded$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} rootSegmentGroup
          * @return {?}
          */
          function (rootSegmentGroup) {
            return _this75.createUrlTree(rootSegmentGroup, _this75.urlTree.queryParams,
            /** @type {?} */
            _this75.urlTree.fragment);
          }));
          return urlTrees$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            if (e instanceof AbsoluteRedirect) {
              // after an absolute redirect we do not apply any more redirects!
              _this75.allowRedirects = false; // we need to run matching, so we can fetch all lazy-loaded modules

              return _this75.match(e.urlTree);
            }

            if (e instanceof NoMatch) {
              throw _this75.noMatchError(e);
            }

            throw e;
          }));
        }
        /**
         * @private
         * @param {?} tree
         * @return {?}
         */

      }, {
        key: "match",
        value: function match(tree) {
          var _this76 = this;

          /** @type {?} */
          var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);
          /** @type {?} */

          var mapped$ = expanded$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} rootSegmentGroup
          * @return {?}
          */
          function (rootSegmentGroup) {
            return _this76.createUrlTree(rootSegmentGroup, tree.queryParams,
            /** @type {?} */
            tree.fragment);
          }));
          return mapped$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            if (e instanceof NoMatch) {
              throw _this76.noMatchError(e);
            }

            throw e;
          }));
        }
        /**
         * @private
         * @param {?} e
         * @return {?}
         */

      }, {
        key: "noMatchError",
        value: function noMatchError(e) {
          return new Error("Cannot match any routes. URL Segment: '".concat(e.segmentGroup, "'"));
        }
        /**
         * @private
         * @param {?} rootCandidate
         * @param {?} queryParams
         * @param {?} fragment
         * @return {?}
         */

      }, {
        key: "createUrlTree",
        value: function createUrlTree(rootCandidate, queryParams, fragment) {
          /** @type {?} */
          var root = rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], _defineProperty({}, PRIMARY_OUTLET, rootCandidate)) : rootCandidate;
          return new UrlTree(root, queryParams, fragment);
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} routes
         * @param {?} segmentGroup
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "expandSegmentGroup",
        value: function expandSegmentGroup(ngModule, routes, segmentGroup, outlet) {
          if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return this.expandChildren(ngModule, routes, segmentGroup).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} children
            * @return {?}
            */
            function (children) {
              return new UrlSegmentGroup([], children);
            }));
          }

          return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
        } // Recursively expand segment groups for all the child outlets

        /**
         * @private
         * @param {?} ngModule
         * @param {?} routes
         * @param {?} segmentGroup
         * @return {?}
         */

      }, {
        key: "expandChildren",
        value: function expandChildren(ngModule, routes, segmentGroup) {
          var _this77 = this;

          return waitForMap(segmentGroup.children,
          /**
          * @param {?} childOutlet
          * @param {?} child
          * @return {?}
          */
          function (childOutlet, child) {
            return _this77.expandSegmentGroup(ngModule, routes, child, childOutlet);
          });
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} segmentGroup
         * @param {?} routes
         * @param {?} segments
         * @param {?} outlet
         * @param {?} allowRedirects
         * @return {?}
         */

      }, {
        key: "expandSegment",
        value: function expandSegment(ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
          var _this78 = this;

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"]).apply(void 0, _toConsumableArray(routes)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} r
          * @return {?}
          */
          function (r) {
            /** @type {?} */
            var expanded$ = _this78.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);

            return expanded$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(
            /**
            * @param {?} e
            * @return {?}
            */
            function (e) {
              if (e instanceof NoMatch) {
                // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -
                // talk to Jason
                return (
                  /** @type {?} */
                  Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(null)
                );
              }

              throw e;
            }));
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatAll"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return !!s;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(
          /**
          * @param {?} e
          * @param {?} _
          * @return {?}
          */
          function (e, _) {
            if (e instanceof rxjs__WEBPACK_IMPORTED_MODULE_2__["EmptyError"] || e.name === 'EmptyError') {
              if (_this78.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(new UrlSegmentGroup([], {}));
              }

              throw new NoMatch(segmentGroup);
            }

            throw e;
          }));
        }
        /**
         * @private
         * @param {?} segmentGroup
         * @param {?} segments
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "noLeftoversInUrl",
        value: function noLeftoversInUrl(segmentGroup, segments, outlet) {
          return segments.length === 0 && !segmentGroup.children[outlet];
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} segmentGroup
         * @param {?} routes
         * @param {?} route
         * @param {?} paths
         * @param {?} outlet
         * @param {?} allowRedirects
         * @return {?}
         */

      }, {
        key: "expandSegmentAgainstRoute",
        value: function expandSegmentAgainstRoute(ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
          if (getOutlet(route) !== outlet) {
            return noMatch(segmentGroup);
          }

          if (route.redirectTo === undefined) {
            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);
          }

          if (allowRedirects && this.allowRedirects) {
            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
          }

          return noMatch(segmentGroup);
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} segmentGroup
         * @param {?} routes
         * @param {?} route
         * @param {?} segments
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "expandSegmentAgainstRouteUsingRedirect",
        value: function expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {
          if (route.path === '**') {
            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
          }

          return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} routes
         * @param {?} route
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "expandWildCardWithParamsAgainstRouteUsingRedirect",
        value: function expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet) {
          var _this79 = this;

          /** @type {?} */
          var newTree = this.applyRedirectCommands([],
          /** @type {?} */
          route.redirectTo, {});

          if (
          /** @type {?} */
          route.redirectTo.startsWith('/')) {
            return absoluteRedirect(newTree);
          }

          return this.lineralizeSegments(route, newTree).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
          /**
          * @param {?} newSegments
          * @return {?}
          */
          function (newSegments) {
            /** @type {?} */
            var group = new UrlSegmentGroup(newSegments, {});
            return _this79.expandSegment(ngModule, group, routes, newSegments, outlet, false);
          }));
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} segmentGroup
         * @param {?} routes
         * @param {?} route
         * @param {?} segments
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "expandRegularSegmentAgainstRouteUsingRedirect",
        value: function expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {
          var _this80 = this;

          var _match = match(segmentGroup, route, segments),
              matched = _match.matched,
              consumedSegments = _match.consumedSegments,
              lastChild = _match.lastChild,
              positionalParamSegments = _match.positionalParamSegments;

          if (!matched) return noMatch(segmentGroup);
          /** @type {?} */

          var newTree = this.applyRedirectCommands(consumedSegments,
          /** @type {?} */
          route.redirectTo,
          /** @type {?} */
          positionalParamSegments);

          if (
          /** @type {?} */
          route.redirectTo.startsWith('/')) {
            return absoluteRedirect(newTree);
          }

          return this.lineralizeSegments(route, newTree).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
          /**
          * @param {?} newSegments
          * @return {?}
          */
          function (newSegments) {
            return _this80.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
          }));
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} rawSegmentGroup
         * @param {?} route
         * @param {?} segments
         * @return {?}
         */

      }, {
        key: "matchSegmentAgainstRoute",
        value: function matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments) {
          var _this81 = this;

          if (route.path === '**') {
            if (route.loadChildren) {
              return this.configLoader.load(ngModule.injector, route).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
              /**
              * @param {?} cfg
              * @return {?}
              */
              function (cfg) {
                route._loadedConfig = cfg;
                return new UrlSegmentGroup(segments, {});
              }));
            }

            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(new UrlSegmentGroup(segments, {}));
          }

          var _match2 = match(rawSegmentGroup, route, segments),
              matched = _match2.matched,
              consumedSegments = _match2.consumedSegments,
              lastChild = _match2.lastChild;

          if (!matched) return noMatch(rawSegmentGroup);
          /** @type {?} */

          var rawSlicedSegments = segments.slice(lastChild);
          /** @type {?} */

          var childConfig$ = this.getChildConfig(ngModule, route, segments);
          return childConfig$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
          /**
          * @param {?} routerConfig
          * @return {?}
          */
          function (routerConfig) {
            /** @type {?} */
            var childModule = routerConfig.module;
            /** @type {?} */

            var childConfig = routerConfig.routes;

            var _split = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig),
                segmentGroup = _split.segmentGroup,
                slicedSegments = _split.slicedSegments;

            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
              /** @type {?} */
              var _expanded$ = _this81.expandChildren(childModule, childConfig, segmentGroup);

              return _expanded$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
              /**
              * @param {?} children
              * @return {?}
              */
              function (children) {
                return new UrlSegmentGroup(consumedSegments, children);
              }));
            }

            if (childConfig.length === 0 && slicedSegments.length === 0) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(new UrlSegmentGroup(consumedSegments, {}));
            }
            /** @type {?} */


            var expanded$ = _this81.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);

            return expanded$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} cs
            * @return {?}
            */
            function (cs) {
              return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);
            }));
          }));
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} route
         * @param {?} segments
         * @return {?}
         */

      }, {
        key: "getChildConfig",
        value: function getChildConfig(ngModule, route, segments) {
          var _this82 = this;

          if (route.children) {
            // The children belong to the same module
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(new LoadedRouterConfig(route.children, ngModule));
          }

          if (route.loadChildren) {
            // lazy children belong to the loaded module
            if (route._loadedConfig !== undefined) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(route._loadedConfig);
            }

            return runCanLoadGuard(ngModule.injector, route, segments).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
            /**
            * @param {?} shouldLoad
            * @return {?}
            */
            function (shouldLoad) {
              if (shouldLoad) {
                return _this82.configLoader.load(ngModule.injector, route).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
                /**
                * @param {?} cfg
                * @return {?}
                */
                function (cfg) {
                  route._loadedConfig = cfg;
                  return cfg;
                }));
              }

              return canLoadFails(route);
            }));
          }

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(new LoadedRouterConfig([], ngModule));
        }
        /**
         * @private
         * @param {?} route
         * @param {?} urlTree
         * @return {?}
         */

      }, {
        key: "lineralizeSegments",
        value: function lineralizeSegments(route, urlTree) {
          /** @type {?} */
          var res = [];
          /** @type {?} */

          var c = urlTree.root;

          while (true) {
            res = res.concat(c.segments);

            if (c.numberOfChildren === 0) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(res);
            }

            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
              return namedOutletsRedirect(
              /** @type {?} */
              route.redirectTo);
            }

            c = c.children[PRIMARY_OUTLET];
          }
        }
        /**
         * @private
         * @param {?} segments
         * @param {?} redirectTo
         * @param {?} posParams
         * @return {?}
         */

      }, {
        key: "applyRedirectCommands",
        value: function applyRedirectCommands(segments, redirectTo, posParams) {
          return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
        }
        /**
         * @private
         * @param {?} redirectTo
         * @param {?} urlTree
         * @param {?} segments
         * @param {?} posParams
         * @return {?}
         */

      }, {
        key: "applyRedirectCreatreUrlTree",
        value: function applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {
          /** @type {?} */
          var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
          return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
        }
        /**
         * @private
         * @param {?} redirectToParams
         * @param {?} actualParams
         * @return {?}
         */

      }, {
        key: "createQueryParams",
        value: function createQueryParams(redirectToParams, actualParams) {
          /** @type {?} */
          var res = {};
          forEach(redirectToParams,
          /**
          * @param {?} v
          * @param {?} k
          * @return {?}
          */
          function (v, k) {
            /** @type {?} */
            var copySourceValue = typeof v === 'string' && v.startsWith(':');

            if (copySourceValue) {
              /** @type {?} */
              var sourceName = v.substring(1);
              res[k] = actualParams[sourceName];
            } else {
              res[k] = v;
            }
          });
          return res;
        }
        /**
         * @private
         * @param {?} redirectTo
         * @param {?} group
         * @param {?} segments
         * @param {?} posParams
         * @return {?}
         */

      }, {
        key: "createSegmentGroup",
        value: function createSegmentGroup(redirectTo, group, segments, posParams) {
          var _this83 = this;

          /** @type {?} */
          var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
          /** @type {?} */

          var children = {};
          forEach(group.children,
          /**
          * @param {?} child
          * @param {?} name
          * @return {?}
          */
          function (child, name) {
            children[name] = _this83.createSegmentGroup(redirectTo, child, segments, posParams);
          });
          return new UrlSegmentGroup(updatedSegments, children);
        }
        /**
         * @private
         * @param {?} redirectTo
         * @param {?} redirectToSegments
         * @param {?} actualSegments
         * @param {?} posParams
         * @return {?}
         */

      }, {
        key: "createSegments",
        value: function createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
          var _this84 = this;

          return redirectToSegments.map(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return s.path.startsWith(':') ? _this84.findPosParam(redirectTo, s, posParams) : _this84.findOrReturn(s, actualSegments);
          });
        }
        /**
         * @private
         * @param {?} redirectTo
         * @param {?} redirectToUrlSegment
         * @param {?} posParams
         * @return {?}
         */

      }, {
        key: "findPosParam",
        value: function findPosParam(redirectTo, redirectToUrlSegment, posParams) {
          /** @type {?} */
          var pos = posParams[redirectToUrlSegment.path.substring(1)];
          if (!pos) throw new Error("Cannot redirect to '".concat(redirectTo, "'. Cannot find '").concat(redirectToUrlSegment.path, "'."));
          return pos;
        }
        /**
         * @private
         * @param {?} redirectToUrlSegment
         * @param {?} actualSegments
         * @return {?}
         */

      }, {
        key: "findOrReturn",
        value: function findOrReturn(redirectToUrlSegment, actualSegments) {
          /** @type {?} */
          var idx = 0;

          var _iterator6 = _createForOfIteratorHelper(actualSegments),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var s = _step6.value;

              if (s.path === redirectToUrlSegment.path) {
                actualSegments.splice(idx);
                return s;
              }

              idx++;
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return redirectToUrlSegment;
        }
      }]);

      return ApplyRedirects;
    }();

    if (false) {}
    /**
     * @param {?} moduleInjector
     * @param {?} route
     * @param {?} segments
     * @return {?}
     */


    function runCanLoadGuard(moduleInjector, route, segments) {
      /** @type {?} */
      var canLoad = route.canLoad;
      if (!canLoad || canLoad.length === 0) return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(true);
      /** @type {?} */

      var obs = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(canLoad).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
      /**
      * @param {?} injectionToken
      * @return {?}
      */
      function (injectionToken) {
        /** @type {?} */
        var guard = moduleInjector.get(injectionToken);
        /** @type {?} */

        var guardVal;

        if (isCanLoad(guard)) {
          guardVal = guard.canLoad(route, segments);
        } else if (isFunction(guard)) {
          guardVal = guard(route, segments);
        } else {
          throw new Error('Invalid CanLoad guard');
        }

        return wrapIntoObservable(guardVal);
      }));
      return obs.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatAll"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["every"])(
      /**
      * @param {?} result
      * @return {?}
      */
      function (result) {
        return result === true;
      }));
    }
    /**
     * @param {?} segmentGroup
     * @param {?} route
     * @param {?} segments
     * @return {?}
     */


    function match(segmentGroup, route, segments) {
      if (route.path === '') {
        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
          return {
            matched: false,
            consumedSegments: [],
            lastChild: 0,
            positionalParamSegments: {}
          };
        }

        return {
          matched: true,
          consumedSegments: [],
          lastChild: 0,
          positionalParamSegments: {}
        };
      }
      /** @type {?} */


      var matcher = route.matcher || defaultUrlMatcher;
      /** @type {?} */

      var res = matcher(segments, segmentGroup, route);

      if (!res) {
        return {
          matched: false,
          consumedSegments:
          /** @type {?} */
          [],
          lastChild: 0,
          positionalParamSegments: {}
        };
      }

      return {
        matched: true,
        consumedSegments:
        /** @type {?} */
        res.consumed,
        lastChild:
        /** @type {?} */
        res.consumed.length,
        positionalParamSegments:
        /** @type {?} */
        res.posParams
      };
    }
    /**
     * @param {?} segmentGroup
     * @param {?} consumedSegments
     * @param {?} slicedSegments
     * @param {?} config
     * @return {?}
     */


    function split(segmentGroup, consumedSegments, slicedSegments, config) {
      if (slicedSegments.length > 0 && containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
        /** @type {?} */
        var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
        return {
          segmentGroup: mergeTrivialChildren(s),
          slicedSegments: []
        };
      }

      if (slicedSegments.length === 0 && containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
        /** @type {?} */
        var _s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));

        return {
          segmentGroup: mergeTrivialChildren(_s2),
          slicedSegments: slicedSegments
        };
      }

      return {
        segmentGroup: segmentGroup,
        slicedSegments: slicedSegments
      };
    }
    /**
     * @param {?} s
     * @return {?}
     */


    function mergeTrivialChildren(s) {
      if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
        /** @type {?} */
        var c = s.children[PRIMARY_OUTLET];
        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
      }

      return s;
    }
    /**
     * @param {?} segmentGroup
     * @param {?} slicedSegments
     * @param {?} routes
     * @param {?} children
     * @return {?}
     */


    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
      /** @type {?} */
      var res = {};

      var _iterator7 = _createForOfIteratorHelper(routes),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var r = _step7.value;

          if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
            res[getOutlet(r)] = new UrlSegmentGroup([], {});
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      return Object.assign(Object.assign({}, children), res);
    }
    /**
     * @param {?} routes
     * @param {?} primarySegmentGroup
     * @return {?}
     */


    function createChildrenForEmptySegments(routes, primarySegmentGroup) {
      /** @type {?} */
      var res = {};
      res[PRIMARY_OUTLET] = primarySegmentGroup;

      var _iterator8 = _createForOfIteratorHelper(routes),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var r = _step8.value;

          if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
            res[getOutlet(r)] = new UrlSegmentGroup([], {});
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      return res;
    }
    /**
     * @param {?} segmentGroup
     * @param {?} segments
     * @param {?} routes
     * @return {?}
     */


    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {
      return routes.some(
      /**
      * @param {?} r
      * @return {?}
      */
      function (r) {
        return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET;
      });
    }
    /**
     * @param {?} segmentGroup
     * @param {?} segments
     * @param {?} routes
     * @return {?}
     */


    function containsEmptyPathRedirects(segmentGroup, segments, routes) {
      return routes.some(
      /**
      * @param {?} r
      * @return {?}
      */
      function (r) {
        return isEmptyPathRedirect(segmentGroup, segments, r);
      });
    }
    /**
     * @param {?} segmentGroup
     * @param {?} segments
     * @param {?} r
     * @return {?}
     */


    function isEmptyPathRedirect(segmentGroup, segments, r) {
      if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {
        return false;
      }

      return r.path === '' && r.redirectTo !== undefined;
    }
    /**
     * @param {?} route
     * @return {?}
     */


    function getOutlet(route) {
      return route.outlet || PRIMARY_OUTLET;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/apply_redirects.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} moduleInjector
     * @param {?} configLoader
     * @param {?} urlSerializer
     * @param {?} config
     * @return {?}
     */


    function applyRedirects$1(moduleInjector, configLoader, urlSerializer, config) {
      return (
        /**
        * @param {?} source
        * @return {?}
        */
        function (source) {
          return source.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            return applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} urlAfterRedirects
            * @return {?}
            */
            function (urlAfterRedirects) {
              return Object.assign(Object.assign({}, t), {
                urlAfterRedirects: urlAfterRedirects
              });
            }));
          }));
        }
      );
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/utils/preactivation.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var CanActivate =
    /**
     * @param {?} path
     */
    function CanActivate(path) {
      _classCallCheck(this, CanActivate);

      this.path = path;
      this.route = this.path[this.path.length - 1];
    };

    if (false) {}

    var CanDeactivate =
    /**
     * @param {?} component
     * @param {?} route
     */
    function CanDeactivate(component, route) {
      _classCallCheck(this, CanDeactivate);

      this.component = component;
      this.route = route;
    };

    if (false) {}
    /**
     * @param {?} future
     * @param {?} curr
     * @param {?} parentContexts
     * @return {?}
     */


    function getAllRouteGuards(future, curr, parentContexts) {
      /** @type {?} */
      var futureRoot = future._root;
      /** @type {?} */

      var currRoot = curr ? curr._root : null;
      return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
    }
    /**
     * @param {?} p
     * @return {?}
     */


    function getCanActivateChild(p) {
      /** @type {?} */
      var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
      if (!canActivateChild || canActivateChild.length === 0) return null;
      return {
        node: p,
        guards: canActivateChild
      };
    }
    /**
     * @param {?} token
     * @param {?} snapshot
     * @param {?} moduleInjector
     * @return {?}
     */


    function getToken(token, snapshot, moduleInjector) {
      /** @type {?} */
      var config = getClosestLoadedConfig(snapshot);
      /** @type {?} */

      var injector = config ? config.module.injector : moduleInjector;
      return injector.get(token);
    }
    /**
     * @param {?} snapshot
     * @return {?}
     */


    function getClosestLoadedConfig(snapshot) {
      if (!snapshot) return null;

      for (var s = snapshot.parent; s; s = s.parent) {
        /** @type {?} */
        var route = s.routeConfig;
        if (route && route._loadedConfig) return route._loadedConfig;
      }

      return null;
    }
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} contexts
     * @param {?} futurePath
     * @param {?=} checks
     * @return {?}
     */


    function getChildRouteGuards(futureNode, currNode, contexts, futurePath) {
      var checks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        canDeactivateChecks: [],
        canActivateChecks: []
      };

      /** @type {?} */
      var prevChildren = nodeChildrenAsMap(currNode); // Process the children of the future route

      futureNode.children.forEach(
      /**
      * @param {?} c
      * @return {?}
      */
      function (c) {
        getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
        delete prevChildren[c.value.outlet];
      }); // Process any children left from the current route (not active for the future route)

      forEach(prevChildren,
      /**
      * @param {?} v
      * @param {?} k
      * @return {?}
      */
      function (v, k) {
        return deactivateRouteAndItsChildren(v,
        /** @type {?} */
        contexts.getContext(k), checks);
      });
      return checks;
    }
    /**
     * @param {?} futureNode
     * @param {?} currNode
     * @param {?} parentContexts
     * @param {?} futurePath
     * @param {?=} checks
     * @return {?}
     */


    function getRouteGuards(futureNode, currNode, parentContexts, futurePath) {
      var checks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        canDeactivateChecks: [],
        canActivateChecks: []
      };

      /** @type {?} */
      var future = futureNode.value;
      /** @type {?} */

      var curr = currNode ? currNode.value : null;
      /** @type {?} */

      var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null; // reusing the node

      if (curr && future.routeConfig === curr.routeConfig) {
        /** @type {?} */
        var shouldRun = shouldRunGuardsAndResolvers(curr, future,
        /** @type {?} */
        future.routeConfig.runGuardsAndResolvers);

        if (shouldRun) {
          checks.canActivateChecks.push(new CanActivate(futurePath));
        } else {
          // we need to set the data
          future.data = curr.data;
          future._resolvedData = curr._resolvedData;
        } // If we have a component, we need to go through an outlet.


        if (future.component) {
          getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks); // if we have a componentless route, we recurse but keep the same outlet map.
        } else {
          getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
        }

        if (shouldRun) {
          /** @type {?} */
          var component = context && context.outlet && context.outlet.component || null;
          checks.canDeactivateChecks.push(new CanDeactivate(component, curr));
        }
      } else {
        if (curr) {
          deactivateRouteAndItsChildren(currNode, context, checks);
        }

        checks.canActivateChecks.push(new CanActivate(futurePath)); // If we have a component, we need to go through an outlet.

        if (future.component) {
          getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks); // if we have a componentless route, we recurse but keep the same outlet map.
        } else {
          getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
        }
      }

      return checks;
    }
    /**
     * @param {?} curr
     * @param {?} future
     * @param {?} mode
     * @return {?}
     */


    function shouldRunGuardsAndResolvers(curr, future, mode) {
      if (typeof mode === 'function') {
        return mode(curr, future);
      }

      switch (mode) {
        case 'pathParamsChange':
          return !equalPath(curr.url, future.url);

        case 'pathParamsOrQueryParamsChange':
          return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);

        case 'always':
          return true;

        case 'paramsOrQueryParamsChange':
          return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);

        case 'paramsChange':
        default:
          return !equalParamsAndUrlSegments(curr, future);
      }
    }
    /**
     * @param {?} route
     * @param {?} context
     * @param {?} checks
     * @return {?}
     */


    function deactivateRouteAndItsChildren(route, context, checks) {
      /** @type {?} */
      var children = nodeChildrenAsMap(route);
      /** @type {?} */

      var r = route.value;
      forEach(children,
      /**
      * @param {?} node
      * @param {?} childName
      * @return {?}
      */
      function (node, childName) {
        if (!r.component) {
          deactivateRouteAndItsChildren(node, context, checks);
        } else if (context) {
          deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
        } else {
          deactivateRouteAndItsChildren(node, null, checks);
        }
      });

      if (!r.component) {
        checks.canDeactivateChecks.push(new CanDeactivate(null, r));
      } else if (context && context.outlet && context.outlet.isActivated) {
        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
      } else {
        checks.canDeactivateChecks.push(new CanDeactivate(null, r));
      }
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/prioritized_guard_value.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var INITIAL_VALUE = Symbol('INITIAL_VALUE');
    /**
     * @return {?}
     */

    function prioritizedGuardValue() {
      return Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
      /**
      * @param {?} obs
      * @return {?}
      */
      function (obs) {
        return (
          /** @type {?} */
          Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["combineLatest"]).apply(void 0, _toConsumableArray(obs.map(
          /**
          * @param {?} o
          * @return {?}
          */
          function (o) {
            return o.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])(
            /** @type {?} */
            INITIAL_VALUE));
          }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["scan"])(
          /**
          * @param {?} acc
          * @param {?} list
          * @return {?}
          */
          function (acc, list) {
            /** @type {?} */
            var isPending = false;
            return list.reduce(
            /**
            * @param {?} innerAcc
            * @param {?} val
            * @param {?} i
            * @return {?}
            */
            function (innerAcc, val, i) {
              if (innerAcc !== INITIAL_VALUE) return innerAcc; // Toggle pending flag if any values haven't been set yet

              if (val === INITIAL_VALUE) isPending = true; // Any other return values are only valid if we haven't yet hit a pending
              // call. This guarantees that in the case of a guard at the bottom of the
              // tree that returns a redirect, we will wait for the higher priority
              // guard at the top to finish before performing the redirect.

              if (!isPending) {
                // Early return when we hit a `false` value as that should always
                // cancel navigation
                if (val === false) return val;

                if (i === list.length - 1 || isUrlTree(val)) {
                  return val;
                }
              }

              return innerAcc;
            }, acc);
          }, INITIAL_VALUE), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return item !== INITIAL_VALUE;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return isUrlTree(item) ? item : item === true;
          }), //
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["take"])(1))
        );
      });
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/check_guards.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} moduleInjector
     * @param {?=} forwardEvent
     * @return {?}
     */


    function checkGuards(moduleInjector, forwardEvent) {
      return (
        /**
        * @param {?} source
        * @return {?}
        */
        function (source) {
          return source.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            var targetSnapshot = t.targetSnapshot,
                currentSnapshot = t.currentSnapshot,
                _t$guards = t.guards,
                canActivateChecks = _t$guards.canActivateChecks,
                canDeactivateChecks = _t$guards.canDeactivateChecks;

            if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(Object.assign(Object.assign({}, t), {
                guardsResult: true
              }));
            }

            return runCanDeactivateChecks(canDeactivateChecks,
            /** @type {?} */
            targetSnapshot, currentSnapshot, moduleInjector).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
            /**
            * @param {?} canDeactivate
            * @return {?}
            */
            function (canDeactivate) {
              return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(
              /** @type {?} */
              targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(canDeactivate);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} guardsResult
            * @return {?}
            */
            function (guardsResult) {
              return Object.assign(Object.assign({}, t), {
                guardsResult: guardsResult
              });
            }));
          }));
        }
      );
    }
    /**
     * @param {?} checks
     * @param {?} futureRSS
     * @param {?} currRSS
     * @param {?} moduleInjector
     * @return {?}
     */


    function runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(checks).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
      /**
      * @param {?} check
      * @return {?}
      */
      function (check) {
        return runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector);
      }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])(
      /**
      * @param {?} result
      * @return {?}
      */
      function (result) {
        return result !== true;
      },
      /** @type {?} */
      true));
    }
    /**
     * @param {?} futureSnapshot
     * @param {?} checks
     * @param {?} moduleInjector
     * @param {?=} forwardEvent
     * @return {?}
     */


    function runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(checks).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatMap"])(
      /**
      * @param {?} check
      * @return {?}
      */
      function (check) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])([fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, moduleInjector), runCanActivate(futureSnapshot, check.route, moduleInjector)]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatAll"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])(
        /**
        * @param {?} result
        * @return {?}
        */
        function (result) {
          return result !== true;
        },
        /** @type {?} */
        true));
      }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])(
      /**
      * @param {?} result
      * @return {?}
      */
      function (result) {
        return result !== true;
      },
      /** @type {?} */
      true));
    }
    /**
     * This should fire off `ActivationStart` events for each route being activated at this
     * level.
     * In other words, if you're activating `a` and `b` below, `path` will contain the
     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always
     * return
     * `true` so checks continue to run.
     * @param {?} snapshot
     * @param {?=} forwardEvent
     * @return {?}
     */


    function fireActivationStart(snapshot, forwardEvent) {
      if (snapshot !== null && forwardEvent) {
        forwardEvent(new ActivationStart(snapshot));
      }

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(true);
    }
    /**
     * This should fire off `ChildActivationStart` events for each route being activated at this
     * level.
     * In other words, if you're activating `a` and `b` below, `path` will contain the
     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always
     * return
     * `true` so checks continue to run.
     * @param {?} snapshot
     * @param {?=} forwardEvent
     * @return {?}
     */


    function fireChildActivationStart(snapshot, forwardEvent) {
      if (snapshot !== null && forwardEvent) {
        forwardEvent(new ChildActivationStart(snapshot));
      }

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(true);
    }
    /**
     * @param {?} futureRSS
     * @param {?} futureARS
     * @param {?} moduleInjector
     * @return {?}
     */


    function runCanActivate(futureRSS, futureARS, moduleInjector) {
      /** @type {?} */
      var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
      if (!canActivate || canActivate.length === 0) return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(true);
      /** @type {?} */

      var canActivateObservables = canActivate.map(
      /**
      * @param {?} c
      * @return {?}
      */
      function (c) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["defer"])(
        /**
        * @return {?}
        */
        function () {
          /** @type {?} */
          var guard = getToken(c, futureARS, moduleInjector);
          /** @type {?} */

          var observable;

          if (isCanActivate(guard)) {
            observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));
          } else if (isFunction(guard)) {
            observable = wrapIntoObservable(guard(futureARS, futureRSS));
          } else {
            throw new Error('Invalid CanActivate guard');
          }

          return observable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])());
        });
      });
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(canActivateObservables).pipe(prioritizedGuardValue());
    }
    /**
     * @param {?} futureRSS
     * @param {?} path
     * @param {?} moduleInjector
     * @return {?}
     */


    function runCanActivateChild(futureRSS, path, moduleInjector) {
      /** @type {?} */
      var futureARS = path[path.length - 1];
      /** @type {?} */

      var canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(
      /**
      * @param {?} p
      * @return {?}
      */
      function (p) {
        return getCanActivateChild(p);
      }).filter(
      /**
      * @param {?} _
      * @return {?}
      */
      function (_) {
        return _ !== null;
      });
      /** @type {?} */

      var canActivateChildGuardsMapped = canActivateChildGuards.map(
      /**
      * @param {?} d
      * @return {?}
      */
      function (d) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["defer"])(
        /**
        * @return {?}
        */
        function () {
          /** @type {?} */
          var guardsMapped = d.guards.map(
          /**
          * @param {?} c
          * @return {?}
          */
          function (c) {
            /** @type {?} */
            var guard = getToken(c, d.node, moduleInjector);
            /** @type {?} */

            var observable;

            if (isCanActivateChild(guard)) {
              observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));
            } else if (isFunction(guard)) {
              observable = wrapIntoObservable(guard(futureARS, futureRSS));
            } else {
              throw new Error('Invalid CanActivateChild guard');
            }

            return observable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])());
          });
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(guardsMapped).pipe(prioritizedGuardValue());
        });
      });
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
    }
    /**
     * @param {?} component
     * @param {?} currARS
     * @param {?} currRSS
     * @param {?} futureRSS
     * @param {?} moduleInjector
     * @return {?}
     */


    function runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {
      /** @type {?} */
      var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
      if (!canDeactivate || canDeactivate.length === 0) return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(true);
      /** @type {?} */

      var canDeactivateObservables = canDeactivate.map(
      /**
      * @param {?} c
      * @return {?}
      */
      function (c) {
        /** @type {?} */
        var guard = getToken(c, currARS, moduleInjector);
        /** @type {?} */

        var observable;

        if (isCanDeactivate(guard)) {
          observable = wrapIntoObservable(guard.canDeactivate(
          /** @type {?} */
          component, currARS, currRSS, futureRSS));
        } else if (isFunction(guard)) {
          observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));
        } else {
          throw new Error('Invalid CanDeactivate guard');
        }

        return observable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["first"])());
      });
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(canDeactivateObservables).pipe(prioritizedGuardValue());
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/recognize.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NoMatch$1 = function NoMatch$1() {
      _classCallCheck(this, NoMatch$1);
    };
    /**
     * @param {?} rootComponentType
     * @param {?} config
     * @param {?} urlTree
     * @param {?} url
     * @param {?=} paramsInheritanceStrategy
     * @param {?=} relativeLinkResolution
     * @return {?}
     */


    function recognize(rootComponentType, config, urlTree, url) {
      var paramsInheritanceStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'emptyOnly';
      var relativeLinkResolution = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'legacy';
      return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution).recognize();
    }

    var Recognizer = /*#__PURE__*/function () {
      /**
       * @param {?} rootComponentType
       * @param {?} config
       * @param {?} urlTree
       * @param {?} url
       * @param {?} paramsInheritanceStrategy
       * @param {?} relativeLinkResolution
       */
      function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
        _classCallCheck(this, Recognizer);

        this.rootComponentType = rootComponentType;
        this.config = config;
        this.urlTree = urlTree;
        this.url = url;
        this.paramsInheritanceStrategy = paramsInheritanceStrategy;
        this.relativeLinkResolution = relativeLinkResolution;
      }
      /**
       * @return {?}
       */


      _createClass(Recognizer, [{
        key: "recognize",
        value: function recognize() {
          try {
            /** @type {?} */
            var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;
            /** @type {?} */

            var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
            /** @type {?} */

            var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)),
            /** @type {?} */
            this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
            /** @type {?} */

            var rootNode = new TreeNode(root, children);
            /** @type {?} */

            var routeState = new RouterStateSnapshot(this.url, rootNode);
            this.inheritParamsAndData(routeState._root);
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(routeState);
          } catch (e) {
            return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
            /**
            * @param {?} obs
            * @return {?}
            */
            function (obs) {
              return obs.error(e);
            });
          }
        }
        /**
         * @param {?} routeNode
         * @return {?}
         */

      }, {
        key: "inheritParamsAndData",
        value: function inheritParamsAndData(routeNode) {
          var _this85 = this;

          /** @type {?} */
          var route = routeNode.value;
          /** @type {?} */

          var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
          route.params = Object.freeze(i.params);
          route.data = Object.freeze(i.data);
          routeNode.children.forEach(
          /**
          * @param {?} n
          * @return {?}
          */
          function (n) {
            return _this85.inheritParamsAndData(n);
          });
        }
        /**
         * @param {?} config
         * @param {?} segmentGroup
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "processSegmentGroup",
        value: function processSegmentGroup(config, segmentGroup, outlet) {
          if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return this.processChildren(config, segmentGroup);
          }

          return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
        }
        /**
         * @param {?} config
         * @param {?} segmentGroup
         * @return {?}
         */

      }, {
        key: "processChildren",
        value: function processChildren(config, segmentGroup) {
          var _this86 = this;

          /** @type {?} */
          var children = mapChildrenIntoArray(segmentGroup,
          /**
          * @param {?} child
          * @param {?} childOutlet
          * @return {?}
          */
          function (child, childOutlet) {
            return _this86.processSegmentGroup(config, child, childOutlet);
          });
          checkOutletNameUniqueness(children);
          sortActivatedRouteSnapshots(children);
          return children;
        }
        /**
         * @param {?} config
         * @param {?} segmentGroup
         * @param {?} segments
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "processSegment",
        value: function processSegment(config, segmentGroup, segments, outlet) {
          var _iterator9 = _createForOfIteratorHelper(config),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var r = _step9.value;

              try {
                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
              } catch (e) {
                if (!(e instanceof NoMatch$1)) throw e;
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }

          if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
            return [];
          }

          throw new NoMatch$1();
        }
        /**
         * @private
         * @param {?} segmentGroup
         * @param {?} segments
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "noLeftoversInUrl",
        value: function noLeftoversInUrl(segmentGroup, segments, outlet) {
          return segments.length === 0 && !segmentGroup.children[outlet];
        }
        /**
         * @param {?} route
         * @param {?} rawSegment
         * @param {?} segments
         * @param {?} outlet
         * @return {?}
         */

      }, {
        key: "processSegmentAgainstRoute",
        value: function processSegmentAgainstRoute(route, rawSegment, segments, outlet) {
          if (route.redirectTo) throw new NoMatch$1();
          if ((route.outlet || PRIMARY_OUTLET) !== outlet) throw new NoMatch$1();
          /** @type {?} */

          var snapshot;
          /** @type {?} */

          var consumedSegments = [];
          /** @type {?} */

          var rawSlicedSegments = [];

          if (route.path === '**') {
            /** @type {?} */
            var params = segments.length > 0 ?
            /** @type {?} */
            last(segments).parameters : {};
            snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(Object.assign({}, this.urlTree.queryParams)),
            /** @type {?} */
            this.urlTree.fragment, getData(route), outlet,
            /** @type {?} */
            route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
          } else {
            /** @type {?} */
            var result = match$1(rawSegment, route, segments);
            consumedSegments = result.consumedSegments;
            rawSlicedSegments = segments.slice(result.lastChild);
            snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)),
            /** @type {?} */
            this.urlTree.fragment, getData(route), outlet,
            /** @type {?} */
            route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
          }
          /** @type {?} */


          var childConfig = getChildConfig(route);

          var _split$ = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution),
              segmentGroup = _split$.segmentGroup,
              slicedSegments = _split$.slicedSegments;

          if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
            /** @type {?} */
            var _children3 = this.processChildren(childConfig, segmentGroup);

            return [new TreeNode(snapshot, _children3)];
          }

          if (childConfig.length === 0 && slicedSegments.length === 0) {
            return [new TreeNode(snapshot, [])];
          }
          /** @type {?} */


          var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
          return [new TreeNode(snapshot, children)];
        }
      }]);

      return Recognizer;
    }();

    if (false) {}
    /**
     * @param {?} nodes
     * @return {?}
     */


    function sortActivatedRouteSnapshots(nodes) {
      nodes.sort(
      /**
      * @param {?} a
      * @param {?} b
      * @return {?}
      */
      function (a, b) {
        if (a.value.outlet === PRIMARY_OUTLET) return -1;
        if (b.value.outlet === PRIMARY_OUTLET) return 1;
        return a.value.outlet.localeCompare(b.value.outlet);
      });
    }
    /**
     * @param {?} route
     * @return {?}
     */


    function getChildConfig(route) {
      if (route.children) {
        return route.children;
      }

      if (route.loadChildren) {
        return (
          /** @type {?} */
          route._loadedConfig.routes
        );
      }

      return [];
    }
    /**
     * @record
     */


    function MatchResult() {}

    if (false) {}
    /**
     * @param {?} segmentGroup
     * @param {?} route
     * @param {?} segments
     * @return {?}
     */


    function match$1(segmentGroup, route, segments) {
      if (route.path === '') {
        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
          throw new NoMatch$1();
        }

        return {
          consumedSegments: [],
          lastChild: 0,
          parameters: {}
        };
      }
      /** @type {?} */


      var matcher = route.matcher || defaultUrlMatcher;
      /** @type {?} */

      var res = matcher(segments, segmentGroup, route);
      if (!res) throw new NoMatch$1();
      /** @type {?} */

      var posParams = {};
      forEach(
      /** @type {?} */
      res.posParams,
      /**
      * @param {?} v
      * @param {?} k
      * @return {?}
      */
      function (v, k) {
        posParams[k] = v.path;
      });
      /** @type {?} */

      var parameters = res.consumed.length > 0 ? Object.assign(Object.assign({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
      return {
        consumedSegments: res.consumed,
        lastChild: res.consumed.length,
        parameters: parameters
      };
    }
    /**
     * @param {?} nodes
     * @return {?}
     */


    function checkOutletNameUniqueness(nodes) {
      /** @type {?} */
      var names = {};
      nodes.forEach(
      /**
      * @param {?} n
      * @return {?}
      */
      function (n) {
        /** @type {?} */
        var routeWithSameOutletName = names[n.value.outlet];

        if (routeWithSameOutletName) {
          /** @type {?} */
          var p = routeWithSameOutletName.url.map(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return s.toString();
          }).join('/');
          /** @type {?} */

          var c = n.value.url.map(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return s.toString();
          }).join('/');
          throw new Error("Two segments cannot have the same outlet name: '".concat(p, "' and '").concat(c, "'."));
        }

        names[n.value.outlet] = n.value;
      });
    }
    /**
     * @param {?} segmentGroup
     * @return {?}
     */


    function getSourceSegmentGroup(segmentGroup) {
      /** @type {?} */
      var s = segmentGroup;

      while (s._sourceSegment) {
        s = s._sourceSegment;
      }

      return s;
    }
    /**
     * @param {?} segmentGroup
     * @return {?}
     */


    function getPathIndexShift(segmentGroup) {
      /** @type {?} */
      var s = segmentGroup;
      /** @type {?} */

      var res = s._segmentIndexShift ? s._segmentIndexShift : 0;

      while (s._sourceSegment) {
        s = s._sourceSegment;
        res += s._segmentIndexShift ? s._segmentIndexShift : 0;
      }

      return res - 1;
    }
    /**
     * @param {?} segmentGroup
     * @param {?} consumedSegments
     * @param {?} slicedSegments
     * @param {?} config
     * @param {?} relativeLinkResolution
     * @return {?}
     */


    function split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {
      if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
        /** @type {?} */
        var _s3 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));

        _s3._sourceSegment = segmentGroup;
        _s3._segmentIndexShift = consumedSegments.length;
        return {
          segmentGroup: _s3,
          slicedSegments: []
        };
      }

      if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
        /** @type {?} */
        var _s4 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));

        _s4._sourceSegment = segmentGroup;
        _s4._segmentIndexShift = consumedSegments.length;
        return {
          segmentGroup: _s4,
          slicedSegments: slicedSegments
        };
      }
      /** @type {?} */


      var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
      s._sourceSegment = segmentGroup;
      s._segmentIndexShift = consumedSegments.length;
      return {
        segmentGroup: s,
        slicedSegments: slicedSegments
      };
    }
    /**
     * @param {?} segmentGroup
     * @param {?} consumedSegments
     * @param {?} slicedSegments
     * @param {?} routes
     * @param {?} children
     * @param {?} relativeLinkResolution
     * @return {?}
     */


    function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {
      /** @type {?} */
      var res = {};

      var _iterator10 = _createForOfIteratorHelper(routes),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var r = _step10.value;

          if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
            /** @type {?} */
            var s = new UrlSegmentGroup([], {});
            s._sourceSegment = segmentGroup;

            if (relativeLinkResolution === 'legacy') {
              s._segmentIndexShift = segmentGroup.segments.length;
            } else {
              s._segmentIndexShift = consumedSegments.length;
            }

            res[getOutlet$1(r)] = s;
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      return Object.assign(Object.assign({}, children), res);
    }
    /**
     * @param {?} segmentGroup
     * @param {?} consumedSegments
     * @param {?} routes
     * @param {?} primarySegment
     * @return {?}
     */


    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
      /** @type {?} */
      var res = {};
      res[PRIMARY_OUTLET] = primarySegment;
      primarySegment._sourceSegment = segmentGroup;
      primarySegment._segmentIndexShift = consumedSegments.length;

      var _iterator11 = _createForOfIteratorHelper(routes),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var r = _step11.value;

          if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
            /** @type {?} */
            var s = new UrlSegmentGroup([], {});
            s._sourceSegment = segmentGroup;
            s._segmentIndexShift = consumedSegments.length;
            res[getOutlet$1(r)] = s;
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return res;
    }
    /**
     * @param {?} segmentGroup
     * @param {?} slicedSegments
     * @param {?} routes
     * @return {?}
     */


    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
      return routes.some(
      /**
      * @param {?} r
      * @return {?}
      */
      function (r) {
        return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET;
      });
    }
    /**
     * @param {?} segmentGroup
     * @param {?} slicedSegments
     * @param {?} routes
     * @return {?}
     */


    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
      return routes.some(
      /**
      * @param {?} r
      * @return {?}
      */
      function (r) {
        return emptyPathMatch(segmentGroup, slicedSegments, r);
      });
    }
    /**
     * @param {?} segmentGroup
     * @param {?} slicedSegments
     * @param {?} r
     * @return {?}
     */


    function emptyPathMatch(segmentGroup, slicedSegments, r) {
      if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
        return false;
      }

      return r.path === '' && r.redirectTo === undefined;
    }
    /**
     * @param {?} route
     * @return {?}
     */


    function getOutlet$1(route) {
      return route.outlet || PRIMARY_OUTLET;
    }
    /**
     * @param {?} route
     * @return {?}
     */


    function getData(route) {
      return route.data || {};
    }
    /**
     * @param {?} route
     * @return {?}
     */


    function getResolve(route) {
      return route.resolve || {};
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/recognize.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} rootComponentType
     * @param {?} config
     * @param {?} serializer
     * @param {?} paramsInheritanceStrategy
     * @param {?} relativeLinkResolution
     * @return {?}
     */


    function recognize$1(rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
      return (
        /**
        * @param {?} source
        * @return {?}
        */
        function (source) {
          return source.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            return recognize(rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} targetSnapshot
            * @return {?}
            */
            function (targetSnapshot) {
              return Object.assign(Object.assign({}, t), {
                targetSnapshot: targetSnapshot
              });
            }));
          }));
        }
      );
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/resolve_data.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} paramsInheritanceStrategy
     * @param {?} moduleInjector
     * @return {?}
     */


    function resolveData(paramsInheritanceStrategy, moduleInjector) {
      return (
        /**
        * @param {?} source
        * @return {?}
        */
        function (source) {
          return source.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            var targetSnapshot = t.targetSnapshot,
                canActivateChecks = t.guards.canActivateChecks;

            if (!canActivateChecks.length) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(t);
            }

            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(canActivateChecks).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatMap"])(
            /**
            * @param {?} check
            * @return {?}
            */
            function (check) {
              return runResolve(check.route,
              /** @type {?} */
              targetSnapshot, paramsInheritanceStrategy, moduleInjector);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["reduce"])(
            /**
            * @param {?} _
            * @param {?} __
            * @return {?}
            */
            function (_, __) {
              return _;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} _
            * @return {?}
            */
            function (_) {
              return t;
            }));
          }));
        }
      );
    }
    /**
     * @param {?} futureARS
     * @param {?} futureRSS
     * @param {?} paramsInheritanceStrategy
     * @param {?} moduleInjector
     * @return {?}
     */


    function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {
      /** @type {?} */
      var resolve = futureARS._resolve;
      return resolveNode(resolve, futureARS, futureRSS, moduleInjector).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
      /**
      * @param {?} resolvedData
      * @return {?}
      */
      function (resolvedData) {
        futureARS._resolvedData = resolvedData;
        futureARS.data = Object.assign(Object.assign({}, futureARS.data), inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);
        return null;
      }));
    }
    /**
     * @param {?} resolve
     * @param {?} futureARS
     * @param {?} futureRSS
     * @param {?} moduleInjector
     * @return {?}
     */


    function resolveNode(resolve, futureARS, futureRSS, moduleInjector) {
      /** @type {?} */
      var keys = Object.keys(resolve);

      if (keys.length === 0) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])({});
      }

      if (keys.length === 1) {
        /** @type {?} */
        var key = keys[0];
        return getResolver(resolve[key], futureARS, futureRSS, moduleInjector).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          return _defineProperty({}, key, value);
        }));
      }
      /** @type {?} */


      var data = {};
      /** @type {?} */

      var runningResolvers$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(keys).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
      /**
      * @param {?} key
      * @return {?}
      */
      function (key) {
        return getResolver(resolve[key], futureARS, futureRSS, moduleInjector).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          data[key] = value;
          return value;
        }));
      }));
      return runningResolvers$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["last"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
      /**
      * @return {?}
      */
      function () {
        return data;
      }));
    }
    /**
     * @param {?} injectionToken
     * @param {?} futureARS
     * @param {?} futureRSS
     * @param {?} moduleInjector
     * @return {?}
     */


    function getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {
      /** @type {?} */
      var resolver = getToken(injectionToken, futureARS, moduleInjector);
      return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) : wrapIntoObservable(resolver(futureARS, futureRSS));
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/operators/switch_tap.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Perform a side effect through a switchMap for every emission on the source Observable,
     * but return an Observable that is identical to the source. It's essentially the same as
     * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,
     * it will wait before continuing with the original value.
     * @template T
     * @param {?} next
     * @return {?}
     */


    function switchTap(next) {
      return (
        /**
        * @param {?} source
        * @return {?}
        */
        function (source) {
          return source.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
          /**
          * @param {?} v
          * @return {?}
          */
          function (v) {
            /** @type {?} */
            var nextResult = next(v);

            if (nextResult) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(nextResult).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
              /**
              * @return {?}
              */
              function () {
                return v;
              }));
            }

            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])([v]);
          }));
        }
      );
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/route_reuse_strategy.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * \@description
     *
     * Provides a way to customize when activated routes get reused.
     *
     * \@publicApi
     * @abstract
     */


    var RouteReuseStrategy = function RouteReuseStrategy() {
      _classCallCheck(this, RouteReuseStrategy);
    };

    if (false) {}
    /**
     * Does not detach any subtrees. Reuses routes as long as their route config is the same.
     */


    var DefaultRouteReuseStrategy = /*#__PURE__*/function () {
      function DefaultRouteReuseStrategy() {
        _classCallCheck(this, DefaultRouteReuseStrategy);
      }

      _createClass(DefaultRouteReuseStrategy, [{
        key: "shouldDetach",

        /**
         * @param {?} route
         * @return {?}
         */
        value: function shouldDetach(route) {
          return false;
        }
        /**
         * @param {?} route
         * @param {?} detachedTree
         * @return {?}
         */

      }, {
        key: "store",
        value: function store(route, detachedTree) {}
        /**
         * @param {?} route
         * @return {?}
         */

      }, {
        key: "shouldAttach",
        value: function shouldAttach(route) {
          return false;
        }
        /**
         * @param {?} route
         * @return {?}
         */

      }, {
        key: "retrieve",
        value: function retrieve(route) {
          return null;
        }
        /**
         * @param {?} future
         * @param {?} curr
         * @return {?}
         */

      }, {
        key: "shouldReuseRoute",
        value: function shouldReuseRoute(future, curr) {
          return future.routeConfig === curr.routeConfig;
        }
      }]);

      return DefaultRouteReuseStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router_config_loader.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The [DI token](guide/glossary/#di-token) for a router configuration.
     * @see `ROUTES`
     * \@publicApi
     * @type {?}
     */


    var ROUTES = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('ROUTES');

    var RouterConfigLoader = /*#__PURE__*/function () {
      /**
       * @param {?} loader
       * @param {?} compiler
       * @param {?=} onLoadStartListener
       * @param {?=} onLoadEndListener
       */
      function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {
        _classCallCheck(this, RouterConfigLoader);

        this.loader = loader;
        this.compiler = compiler;
        this.onLoadStartListener = onLoadStartListener;
        this.onLoadEndListener = onLoadEndListener;
      }
      /**
       * @param {?} parentInjector
       * @param {?} route
       * @return {?}
       */


      _createClass(RouterConfigLoader, [{
        key: "load",
        value: function load(parentInjector, route) {
          var _this87 = this;

          if (this.onLoadStartListener) {
            this.onLoadStartListener(route);
          }
          /** @type {?} */


          var moduleFactory$ = this.loadModuleFactory(
          /** @type {?} */
          route.loadChildren);
          return moduleFactory$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} factory
          * @return {?}
          */
          function (factory) {
            if (_this87.onLoadEndListener) {
              _this87.onLoadEndListener(route);
            }
            /** @type {?} */


            var module = factory.create(parentInjector);
            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);
          }));
        }
        /**
         * @private
         * @param {?} loadChildren
         * @return {?}
         */

      }, {
        key: "loadModuleFactory",
        value: function loadModuleFactory(loadChildren) {
          var _this88 = this;

          if (typeof loadChildren === 'string') {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(this.loader.load(loadChildren));
          } else {
            return wrapIntoObservable(loadChildren()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
            /**
            * @param {?} t
            * @return {?}
            */
            function (t) {
              if (t instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactory"]) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(t);
              } else {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(_this88.compiler.compileModuleAsync(t));
              }
            }));
          }
        }
      }]);

      return RouterConfigLoader;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/url_handling_strategy.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * \@description
     *
     * Provides a way to migrate AngularJS applications to Angular.
     *
     * \@publicApi
     * @abstract
     */


    var UrlHandlingStrategy = function UrlHandlingStrategy() {
      _classCallCheck(this, UrlHandlingStrategy);
    };

    if (false) {}
    /**
     * \@publicApi
     */


    var DefaultUrlHandlingStrategy = /*#__PURE__*/function () {
      function DefaultUrlHandlingStrategy() {
        _classCallCheck(this, DefaultUrlHandlingStrategy);
      }

      _createClass(DefaultUrlHandlingStrategy, [{
        key: "shouldProcessUrl",

        /**
         * @param {?} url
         * @return {?}
         */
        value: function shouldProcessUrl(url) {
          return true;
        }
        /**
         * @param {?} url
         * @return {?}
         */

      }, {
        key: "extract",
        value: function extract(url) {
          return url;
        }
        /**
         * @param {?} newUrlPart
         * @param {?} wholeUrl
         * @return {?}
         */

      }, {
        key: "merge",
        value: function merge(newUrlPart, wholeUrl) {
          return newUrlPart;
        }
      }]);

      return DefaultUrlHandlingStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@description
     *
     * Options that modify the navigation strategy.
     *
     * \@publicApi
     * @record
     */


    function NavigationExtras() {}

    if (false) {}
    /**
     * @param {?} error
     * @return {?}
     */


    function defaultErrorHandler(error) {
      throw error;
    }
    /**
     * @param {?} error
     * @param {?} urlSerializer
     * @param {?} url
     * @return {?}
     */


    function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
      return urlSerializer.parse('/');
    }
    /**
     * \@internal
     * @param {?} snapshot
     * @param {?} runExtras
     * @return {?}
     */


    function defaultRouterHook(snapshot, runExtras) {
      return (
        /** @type {?} */
        Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(null)
      );
    }
    /**
     * \@description
     *
     * A service that provides navigation and URL manipulation capabilities.
     *
     * @see `Route`.
     * @see [Routing and Navigation Guide](guide/router).
     *
     * \@ngModule RouterModule
     *
     * \@publicApi
     */


    var Router = /*#__PURE__*/function () {
      /**
       * Creates the router service.
       * @param {?} rootComponentType
       * @param {?} urlSerializer
       * @param {?} rootContexts
       * @param {?} location
       * @param {?} injector
       * @param {?} loader
       * @param {?} compiler
       * @param {?} config
       */
      // TODO: vsavkin make internal after the final is out.
      function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
        var _this89 = this;

        _classCallCheck(this, Router);

        this.rootComponentType = rootComponentType;
        this.urlSerializer = urlSerializer;
        this.rootContexts = rootContexts;
        this.location = location;
        this.config = config;
        this.lastSuccessfulNavigation = null;
        this.currentNavigation = null;
        this.navigationId = 0;
        this.isNgZoneEnabled = false;
        /**
         * An event stream for routing events in this NgModule.
         */

        this.events = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * A handler for navigation errors in this NgModule.
         */

        this.errorHandler = defaultErrorHandler;
        /**
         * A handler for errors thrown by `Router.parseUrl(url)`
         * when `url` contains an invalid character.
         * The most common case is a `%` sign
         * that's not encoded and is not part of a percent encoded sequence.
         */

        this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
        /**
         * True if at least one navigation event has occurred,
         * false otherwise.
         */

        this.navigated = false;
        this.lastSuccessfulId = -1;
        /**
         * Hooks that enable you to pause navigation,
         * either before or after the preactivation phase.
         * Used by `RouterModule`.
         *
         * \@internal
         */

        this.hooks = {
          beforePreactivation: defaultRouterHook,
          afterPreactivation: defaultRouterHook
        };
        /**
         * A strategy for extracting and merging URLs.
         * Used for AngularJS to Angular migrations.
         */

        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
        /**
         * A strategy for re-using routes.
         */

        this.routeReuseStrategy = new DefaultRouteReuseStrategy();
        /**
         * How to handle a navigation request to the current URL. One of:
         * - `'ignore'` :  The router ignores the request.
         * - `'reload'` : The router reloads the URL. Use to implement a "refresh" feature.
         */

        this.onSameUrlNavigation = 'ignore';
        /**
         * How to merge parameters, data, and resolved data from parent to child
         * routes. One of:
         *
         * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data
         * for path-less or component-less routes.
         * - `'always'` : Inherit parent parameters, data, and resolved data
         * for all child routes.
         */

        this.paramsInheritanceStrategy = 'emptyOnly';
        /**
         * Determines when the router updates the browser URL.
         * By default (`"deferred"`), updates the browser URL after navigation has finished.
         * Set to `'eager'` to update the browser URL at the beginning of navigation.
         * You can choose to update early so that, if navigation fails,
         * you can show an error message with the URL that failed.
         */

        this.urlUpdateStrategy = 'deferred';
        /**
         * Enables a bug fix that corrects relative link resolution in components with empty paths.
         * @see `RouterModule`
         */

        this.relativeLinkResolution = 'legacy';
        /** @type {?} */

        var onLoadStart =
        /**
        * @param {?} r
        * @return {?}
        */
        function onLoadStart(r) {
          return _this89.triggerEvent(new RouteConfigLoadStart(r));
        };
        /** @type {?} */


        var onLoadEnd =
        /**
        * @param {?} r
        * @return {?}
        */
        function onLoadEnd(r) {
          return _this89.triggerEvent(new RouteConfigLoadEnd(r));
        };

        this.ngModule = injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"]);
        this.console = injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵConsole"]);
        /** @type {?} */

        var ngZone = injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]);
        this.isNgZoneEnabled = ngZone instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"];
        this.resetConfig(config);
        this.currentUrlTree = createEmptyUrlTree();
        this.rawUrlTree = this.currentUrlTree;
        this.browserUrlTree = this.currentUrlTree;
        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
        this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
        this.transitions = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]({
          id: 0,
          currentUrlTree: this.currentUrlTree,
          currentRawUrl: this.currentUrlTree,
          extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
          urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
          rawUrl: this.currentUrlTree,
          extras: {},
          resolve: null,
          reject: null,
          promise: Promise.resolve(true),
          source: 'imperative',
          restoredState: null,
          currentSnapshot: this.routerState.snapshot,
          targetSnapshot: null,
          currentRouterState: this.routerState,
          targetRouterState: null,
          guards: {
            canActivateChecks: [],
            canDeactivateChecks: []
          },
          guardsResult: null
        });
        this.navigations = this.setupNavigations(this.transitions);
        this.processNavigations();
      }
      /**
       * @private
       * @param {?} transitions
       * @return {?}
       */


      _createClass(Router, [{
        key: "setupNavigations",
        value: function setupNavigations(transitions) {
          var _this90 = this;

          /** @type {?} */
          var eventsSubject =
          /** @type {?} */
          this.events;
          return (
            /** @type {?} */

            /** @type {?} */
            transitions.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(
            /**
            * @param {?} t
            * @return {?}
            */
            function (t) {
              return t.id !== 0;
            }), // Extract URL
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
            /**
            * @param {?} t
            * @return {?}
            */
            function (t) {
              return (
                /** @type {?} */
                Object.assign(Object.assign({}, t), {
                  extractedUrl: _this90.urlHandlingStrategy.extract(t.rawUrl)
                })
              );
            }), // Using switchMap so we cancel executing navigations when a new one comes in
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
            /**
            * @param {?} t
            * @return {?}
            */
            function (t) {
              /** @type {?} */
              var completed = false;
              /** @type {?} */

              var errored = false;
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(t).pipe( // Store the Navigation object
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                _this90.currentNavigation = {
                  id: t.id,
                  initialUrl: t.currentRawUrl,
                  extractedUrl: t.extractedUrl,
                  trigger: t.source,
                  extras: t.extras,
                  previousNavigation: _this90.lastSuccessfulNavigation ? Object.assign(Object.assign({}, _this90.lastSuccessfulNavigation), {
                    previousNavigation: null
                  }) : null
                };
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                /** @type {?} */
                var urlTransition = !_this90.navigated || t.extractedUrl.toString() !== _this90.browserUrlTree.toString();
                /** @type {?} */


                var processCurrentUrl = (_this90.onSameUrlNavigation === 'reload' ? true : urlTransition) && _this90.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);

                if (processCurrentUrl) {
                  return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(t).pipe( // Fire NavigationStart event
                  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    /** @type {?} */
                    var transition = _this90.transitions.getValue();

                    eventsSubject.next(new NavigationStart(t.id, _this90.serializeUrl(t.extractedUrl), t.source, t.restoredState));

                    if (transition !== _this90.transitions.getValue()) {
                      return rxjs__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
                    }

                    return [t];
                  }), // This delay is required to match old behavior that forced navigation
                  // to always be async
                  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    return Promise.resolve(t);
                  }), // ApplyRedirects
                  applyRedirects$1(_this90.ngModule.injector, _this90.configLoader, _this90.urlSerializer, _this90.config), // Update the currentNavigation
                  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    _this90.currentNavigation = Object.assign(Object.assign({},
                    /** @type {?} */
                    _this90.currentNavigation), {
                      finalUrl: t.urlAfterRedirects
                    });
                  }), // Recognize
                  recognize$1(_this90.rootComponentType, _this90.config,
                  /**
                  * @param {?} url
                  * @return {?}
                  */
                  function (url) {
                    return _this90.serializeUrl(url);
                  }, _this90.paramsInheritanceStrategy, _this90.relativeLinkResolution), // Update URL if in `eager` update mode
                  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    if (_this90.urlUpdateStrategy === 'eager') {
                      if (!t.extras.skipLocationChange) {
                        _this90.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state);
                      }

                      _this90.browserUrlTree = t.urlAfterRedirects;
                    }
                  }), // Fire RoutesRecognized
                  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    /** @type {?} */
                    var routesRecognized = new RoutesRecognized(t.id, _this90.serializeUrl(t.extractedUrl), _this90.serializeUrl(t.urlAfterRedirects),
                    /** @type {?} */
                    t.targetSnapshot);
                    eventsSubject.next(routesRecognized);
                  }));
                } else {
                  /** @type {?} */
                  var processPreviousUrl = urlTransition && _this90.rawUrlTree && _this90.urlHandlingStrategy.shouldProcessUrl(_this90.rawUrlTree);
                  /* When the current URL shouldn't be processed, but the previous one was,
                   * we handle this "error condition" by navigating to the previously
                   * successful URL, but leaving the URL intact.*/


                  if (processPreviousUrl) {
                    var id = t.id,
                        extractedUrl = t.extractedUrl,
                        source = t.source,
                        restoredState = t.restoredState,
                        extras = t.extras;
                    /** @type {?} */

                    var navStart = new NavigationStart(id, _this90.serializeUrl(extractedUrl), source, restoredState);
                    eventsSubject.next(navStart);
                    /** @type {?} */

                    var targetSnapshot = createEmptyState(extractedUrl, _this90.rootComponentType).snapshot;
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(Object.assign(Object.assign({}, t), {
                      targetSnapshot: targetSnapshot,
                      urlAfterRedirects: extractedUrl,
                      extras: Object.assign(Object.assign({}, extras), {
                        skipLocationChange: false,
                        replaceUrl: false
                      })
                    }));
                  } else {
                    /* When neither the current or previous URL can be processed, do nothing
                     * other than update router's internal reference to the current "settled"
                     * URL. This way the next navigation will be coming from the current URL
                     * in the browser.
                     */
                    _this90.rawUrlTree = t.rawUrl;
                    _this90.browserUrlTree = t.urlAfterRedirects;
                    t.resolve(null);
                    return rxjs__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
                  }
                }
              }), // Before Preactivation
              switchTap(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                var targetSnapshot = t.targetSnapshot,
                    navigationId = t.id,
                    appliedUrlTree = t.extractedUrl,
                    rawUrlTree = t.rawUrl,
                    _t$extras = t.extras,
                    skipLocationChange = _t$extras.skipLocationChange,
                    replaceUrl = _t$extras.replaceUrl;
                return _this90.hooks.beforePreactivation(
                /** @type {?} */
                targetSnapshot, {
                  navigationId: navigationId,
                  appliedUrlTree: appliedUrlTree,
                  rawUrlTree: rawUrlTree,
                  skipLocationChange: !!skipLocationChange,
                  replaceUrl: !!replaceUrl
                });
              }), // --- GUARDS ---
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                /** @type {?} */
                var guardsStart = new GuardsCheckStart(t.id, _this90.serializeUrl(t.extractedUrl), _this90.serializeUrl(t.urlAfterRedirects),
                /** @type {?} */
                t.targetSnapshot);

                _this90.triggerEvent(guardsStart);
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                return Object.assign(Object.assign({}, t), {
                  guards: getAllRouteGuards(
                  /** @type {?} */
                  t.targetSnapshot, t.currentSnapshot, _this90.rootContexts)
                });
              }), checkGuards(_this90.ngModule.injector,
              /**
              * @param {?} evt
              * @return {?}
              */
              function (evt) {
                return _this90.triggerEvent(evt);
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                if (isUrlTree(t.guardsResult)) {
                  /** @type {?} */
                  var error = navigationCancelingError("Redirecting to \"".concat(_this90.serializeUrl(t.guardsResult), "\""));
                  error.url = t.guardsResult;
                  throw error;
                }
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                /** @type {?} */
                var guardsEnd = new GuardsCheckEnd(t.id, _this90.serializeUrl(t.extractedUrl), _this90.serializeUrl(t.urlAfterRedirects),
                /** @type {?} */
                t.targetSnapshot, !!t.guardsResult);

                _this90.triggerEvent(guardsEnd);
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                if (!t.guardsResult) {
                  _this90.resetUrlToCurrentUrlTree();
                  /** @type {?} */


                  var navCancel = new NavigationCancel(t.id, _this90.serializeUrl(t.extractedUrl), '');
                  eventsSubject.next(navCancel);
                  t.resolve(false);
                  return false;
                }

                return true;
              }), // --- RESOLVE ---
              switchTap(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                if (t.guards.canActivateChecks.length) {
                  return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(t).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    /** @type {?} */
                    var resolveStart = new ResolveStart(t.id, _this90.serializeUrl(t.extractedUrl), _this90.serializeUrl(t.urlAfterRedirects),
                    /** @type {?} */
                    t.targetSnapshot);

                    _this90.triggerEvent(resolveStart);
                  }), resolveData(_this90.paramsInheritanceStrategy, _this90.ngModule.injector), //
                  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
                  /**
                  * @param {?} t
                  * @return {?}
                  */
                  function (t) {
                    /** @type {?} */
                    var resolveEnd = new ResolveEnd(t.id, _this90.serializeUrl(t.extractedUrl), _this90.serializeUrl(t.urlAfterRedirects),
                    /** @type {?} */
                    t.targetSnapshot);

                    _this90.triggerEvent(resolveEnd);
                  }));
                }

                return undefined;
              }), // --- AFTER PREACTIVATION ---
              switchTap(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                var targetSnapshot = t.targetSnapshot,
                    navigationId = t.id,
                    appliedUrlTree = t.extractedUrl,
                    rawUrlTree = t.rawUrl,
                    _t$extras2 = t.extras,
                    skipLocationChange = _t$extras2.skipLocationChange,
                    replaceUrl = _t$extras2.replaceUrl;
                return _this90.hooks.afterPreactivation(
                /** @type {?} */
                targetSnapshot, {
                  navigationId: navigationId,
                  appliedUrlTree: appliedUrlTree,
                  rawUrlTree: rawUrlTree,
                  skipLocationChange: !!skipLocationChange,
                  replaceUrl: !!replaceUrl
                });
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                /** @type {?} */
                var targetRouterState = createRouterState(_this90.routeReuseStrategy,
                /** @type {?} */
                t.targetSnapshot, t.currentRouterState);
                return Object.assign(Object.assign({}, t), {
                  targetRouterState: targetRouterState
                });
              }),
              /* Once here, we are about to activate syncronously. The assumption is this
                 will succeed, and user code may read from the Router service. Therefore
                 before activation, we need to update router properties storing the current
                 URL and the RouterState, as well as updated the browser URL. All this should
                 happen *before* activating. */
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(
              /**
              * @param {?} t
              * @return {?}
              */
              function (t) {
                _this90.currentUrlTree = t.urlAfterRedirects;
                _this90.rawUrlTree = _this90.urlHandlingStrategy.merge(_this90.currentUrlTree, t.rawUrl);

                /** @type {?} */
                _this90.routerState =
                /** @type {?} */
                t.targetRouterState;

                if (_this90.urlUpdateStrategy === 'deferred') {
                  if (!t.extras.skipLocationChange) {
                    _this90.setBrowserUrl(_this90.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);
                  }

                  _this90.browserUrlTree = t.urlAfterRedirects;
                }
              }), activateRoutes(_this90.rootContexts, _this90.routeReuseStrategy,
              /**
              * @param {?} evt
              * @return {?}
              */
              function (evt) {
                return _this90.triggerEvent(evt);
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])({
                /**
                 * @return {?}
                 */
                next: function next() {
                  completed = true;
                },

                /**
                 * @return {?}
                 */
                complete: function complete() {
                  completed = true;
                }
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["finalize"])(
              /**
              * @return {?}
              */
              function () {
                /* When the navigation stream finishes either through error or success, we
                 * set the `completed` or `errored` flag. However, there are some situations
                 * where we could get here without either of those being set. For instance, a
                 * redirect during NavigationStart. Therefore, this is a catch-all to make
                 * sure the NavigationCancel
                 * event is fired when a navigation gets cancelled but not caught by other
                 * means. */
                if (!completed && !errored) {
                  // Must reset to current URL tree here to ensure history.state is set. On a
                  // fresh page load, if a new navigation comes in before a successful
                  // navigation completes, there will be nothing in
                  // history.state.navigationId. This can cause sync problems with AngularJS
                  // sync code which looks for a value here in order to determine whether or
                  // not to handle a given popstate event or to leave it to the Angualr
                  // router.
                  _this90.resetUrlToCurrentUrlTree();
                  /** @type {?} */


                  var navCancel = new NavigationCancel(t.id, _this90.serializeUrl(t.extractedUrl), "Navigation ID ".concat(t.id, " is not equal to the current navigation id ").concat(_this90.navigationId));
                  eventsSubject.next(navCancel);
                  t.resolve(false);
                } // currentNavigation should always be reset to null here. If navigation was
                // successful, lastSuccessfulTransition will have already been set. Therefore
                // we can safely set currentNavigation to null here.


                _this90.currentNavigation = null;
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(
              /**
              * @param {?} e
              * @return {?}
              */
              function (e) {
                errored = true;
                /* This error type is issued during Redirect, and is handled as a
                 * cancellation rather than an error. */

                if (isNavigationCancelingError(e)) {
                  /** @type {?} */
                  var redirecting = isUrlTree(e.url);

                  if (!redirecting) {
                    // Set property only if we're not redirecting. If we landed on a page and
                    // redirect to `/` route, the new navigation is going to see the `/`
                    // isn't a change from the default currentUrlTree and won't navigate.
                    // This is only applicable with initial navigation, so setting
                    // `navigated` only when not redirecting resolves this scenario.
                    _this90.navigated = true;

                    _this90.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                  }
                  /** @type {?} */


                  var navCancel = new NavigationCancel(t.id, _this90.serializeUrl(t.extractedUrl), e.message);
                  eventsSubject.next(navCancel); // When redirecting, we need to delay resolving the navigation
                  // promise and push it to the redirect navigation

                  if (!redirecting) {
                    t.resolve(false);
                  } else {
                    // setTimeout is required so this navigation finishes with
                    // the return EMPTY below. If it isn't allowed to finish
                    // processing, there can be multiple navigations to the same
                    // URL.
                    setTimeout(
                    /**
                    * @return {?}
                    */
                    function () {
                      /** @type {?} */
                      var mergedTree = _this90.urlHandlingStrategy.merge(e.url, _this90.rawUrlTree);
                      /** @type {?} */


                      var extras = {
                        skipLocationChange: t.extras.skipLocationChange,
                        replaceUrl: _this90.urlUpdateStrategy === 'eager'
                      };
                      return _this90.scheduleNavigation(mergedTree, 'imperative', null, extras, {
                        resolve: t.resolve,
                        reject: t.reject,
                        promise: t.promise
                      });
                    }, 0);
                  }
                  /* All other errors should reset to the router's internal URL reference to
                   * the pre-error state. */

                } else {
                  _this90.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                  /** @type {?} */


                  var navError = new NavigationError(t.id, _this90.serializeUrl(t.extractedUrl), e);
                  eventsSubject.next(navError);

                  try {
                    t.resolve(_this90.errorHandler(e));
                  } catch (ee) {
                    t.reject(ee);
                  }
                }

                return rxjs__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
              })); // TODO(jasonaden): remove cast once g3 is on updated TypeScript
            }))
          );
        }
        /**
         * \@internal
         * TODO: this should be removed once the constructor of the router made internal
         * @param {?} rootComponentType
         * @return {?}
         */

      }, {
        key: "resetRootComponentType",
        value: function resetRootComponentType(rootComponentType) {
          this.rootComponentType = rootComponentType; // TODO: vsavkin router 4.0 should make the root component set to null
          // this will simplify the lifecycle of the router.

          this.routerState.root.component = this.rootComponentType;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getTransition",
        value: function getTransition() {
          /** @type {?} */
          var transition = this.transitions.value; // This value needs to be set. Other values such as extractedUrl are set on initial navigation
          // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not
          // processing the previous URL.

          transition.urlAfterRedirects = this.browserUrlTree;
          return transition;
        }
        /**
         * @private
         * @param {?} t
         * @return {?}
         */

      }, {
        key: "setTransition",
        value: function setTransition(t) {
          this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t));
        }
        /**
         * Sets up the location change listener and performs the initial navigation.
         * @return {?}
         */

      }, {
        key: "initialNavigation",
        value: function initialNavigation() {
          this.setUpLocationChangeListener();

          if (this.navigationId === 0) {
            this.navigateByUrl(this.location.path(true), {
              replaceUrl: true
            });
          }
        }
        /**
         * Sets up the location change listener.
         * @return {?}
         */

      }, {
        key: "setUpLocationChangeListener",
        value: function setUpLocationChangeListener() {
          var _this91 = this;

          // Don't need to use Zone.wrap any more, because zone.js
          // already patch onPopState, so location change callback will
          // run into ngZone
          if (!this.locationSubscription) {
            this.locationSubscription =
            /** @type {?} */
            this.location.subscribe(
            /**
            * @param {?} change
            * @return {?}
            */
            function (change) {
              /** @type {?} */
              var rawUrlTree = _this91.parseUrl(change['url']);
              /** @type {?} */


              var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange'; // Navigations coming from Angular router have a navigationId state property. When this
              // exists, restore the state.

              /** @type {?} */

              var state = change.state && change.state.navigationId ? change.state : null;
              setTimeout(
              /**
              * @return {?}
              */
              function () {
                _this91.scheduleNavigation(rawUrlTree, source, state, {
                  replaceUrl: true
                });
              }, 0);
            });
          }
        }
        /**
         * The current URL.
         * @return {?}
         */

      }, {
        key: "getCurrentNavigation",

        /**
         * The current Navigation object if one exists
         * @return {?}
         */
        value: function getCurrentNavigation() {
          return this.currentNavigation;
        }
        /**
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "triggerEvent",
        value: function triggerEvent(event) {
          /** @type {?} */
          this.events.next(event);
        }
        /**
         * Resets the configuration used for navigation and generating links.
         *
         * \@usageNotes
         *
         * ```
         * router.resetConfig([
         *  { path: 'team/:id', component: TeamCmp, children: [
         *    { path: 'simple', component: SimpleCmp },
         *    { path: 'user/:name', component: UserCmp }
         *  ]}
         * ]);
         * ```
         * @param {?} config The route array for the new configuration.
         *
         * @return {?}
         */

      }, {
        key: "resetConfig",
        value: function resetConfig(config) {
          validateConfig(config);
          this.config = config.map(standardizeConfig);
          this.navigated = false;
          this.lastSuccessfulId = -1;
        }
        /**
         * \@docsNotRequired
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.dispose();
        }
        /**
         * Disposes of the router.
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          if (this.locationSubscription) {
            this.locationSubscription.unsubscribe();
            this.locationSubscription =
            /** @type {?} */
            null;
          }
        }
        /**
         * Applies an array of commands to the current URL tree and creates a new URL tree.
         *
         * When given an activated route, applies the given commands starting from the route.
         * Otherwise, applies the given command starting from the root.
         *
         * \@usageNotes
         *
         * ```
         * // create /team/33/user/11
         * router.createUrlTree(['/team', 33, 'user', 11]);
         *
         * // create /team/33;expand=true/user/11
         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
         *
         * // you can collapse static segments like this (this works only with the first passed-in value):
         * router.createUrlTree(['/team/33/user', userId]);
         *
         * // If the first segment can contain slashes, and you do not want the router to split it,
         * // you can do the following:
         * router.createUrlTree([{segmentPath: '/one/two'}]);
         *
         * // create /team/33/(user/11//right:chat)
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
         *
         * // remove the right secondary node
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
         *
         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
         *
         * // navigate to /team/33/user/11/details
         * router.createUrlTree(['details'], {relativeTo: route});
         *
         * // navigate to /team/33/user/22
         * router.createUrlTree(['../22'], {relativeTo: route});
         *
         * // navigate to /team/44/user/22
         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
         * ```
         * @param {?} commands An array of commands to apply.
         * @param {?=} navigationExtras Options that control the navigation strategy. This function
         * only utilizes properties in `NavigationExtras` that would change the provided URL.
         * @return {?} The new URL tree.
         *
         */

      }, {
        key: "createUrlTree",
        value: function createUrlTree(commands) {
          var navigationExtras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var relativeTo = navigationExtras.relativeTo,
              queryParams = navigationExtras.queryParams,
              fragment = navigationExtras.fragment,
              preserveQueryParams = navigationExtras.preserveQueryParams,
              queryParamsHandling = navigationExtras.queryParamsHandling,
              preserveFragment = navigationExtras.preserveFragment;

          if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && preserveQueryParams &&
          /** @type {?} */
          console &&
          /** @type {?} */
          console.warn) {
            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
          }
          /** @type {?} */


          var a = relativeTo || this.routerState.root;
          /** @type {?} */

          var f = preserveFragment ? this.currentUrlTree.fragment : fragment;
          /** @type {?} */

          var q = null;

          if (queryParamsHandling) {
            switch (queryParamsHandling) {
              case 'merge':
                q = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), queryParams);
                break;

              case 'preserve':
                q = this.currentUrlTree.queryParams;
                break;

              default:
                q = queryParams || null;
            }
          } else {
            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
          }

          if (q !== null) {
            q = this.removeEmptyProps(q);
          }

          return _createUrlTree(a, this.currentUrlTree, commands,
          /** @type {?} */
          q,
          /** @type {?} */
          f);
        }
        /**
         * Navigate based on the provided URL, which must be absolute.
         *
         * \@usageNotes
         *
         * ```
         * router.navigateByUrl("/team/33/user/11");
         *
         * // Navigate without updating the URL
         * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
         * ```
         *
         * @param {?} url An absolute URL. The function does not apply any delta to the current URL.
         * @param {?=} extras An object containing properties that modify the navigation strategy.
         * The function ignores any properties in the `NavigationExtras` that would change the
         * provided URL.
         *
         * @return {?} A Promise that resolves to 'true' when navigation succeeds,
         * to 'false' when navigation fails, or is rejected on error.
         *
         */

      }, {
        key: "navigateByUrl",
        value: function navigateByUrl(url) {
          var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            skipLocationChange: false
          };

          if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && this.isNgZoneEnabled && !_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"].isInAngularZone()) {
            this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");
          }
          /** @type {?} */


          var urlTree = isUrlTree(url) ? url : this.parseUrl(url);
          /** @type {?} */

          var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
          return this.scheduleNavigation(mergedTree, 'imperative', null, extras);
        }
        /**
         * Navigate based on the provided array of commands and a starting point.
         * If no starting route is provided, the navigation is absolute.
         *
         * Returns a promise that:
         * - resolves to 'true' when navigation succeeds,
         * - resolves to 'false' when navigation fails,
         * - is rejected when an error happens.
         *
         * \@usageNotes
         *
         * ```
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
         *
         * // Navigate without updating the URL
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
         * ```
         *
         * The first parameter of `navigate()` is a delta to be applied to the current URL
         * or the one provided in the `relativeTo` property of the second parameter (the
         * `NavigationExtras`).
         *
         * In order to affect this browser's `history.state` entry, the `state`
         * parameter can be passed. This must be an object because the router
         * will add the `navigationId` property to this object before creating
         * the new history item.
         * @param {?} commands
         * @param {?=} extras
         * @return {?}
         */

      }, {
        key: "navigate",
        value: function navigate(commands) {
          var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            skipLocationChange: false
          };
          validateCommands(commands);
          return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
        }
        /**
         * Serializes a `UrlTree` into a string
         * @param {?} url
         * @return {?}
         */

      }, {
        key: "serializeUrl",
        value: function serializeUrl(url) {
          return this.urlSerializer.serialize(url);
        }
        /**
         * Parses a string into a `UrlTree`
         * @param {?} url
         * @return {?}
         */

      }, {
        key: "parseUrl",
        value: function parseUrl(url) {
          /** @type {?} */
          var urlTree;

          try {
            urlTree = this.urlSerializer.parse(url);
          } catch (e) {
            urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
          }

          return urlTree;
        }
        /**
         * Returns whether the url is activated
         * @param {?} url
         * @param {?} exact
         * @return {?}
         */

      }, {
        key: "isActive",
        value: function isActive(url, exact) {
          if (isUrlTree(url)) {
            return containsTree(this.currentUrlTree, url, exact);
          }
          /** @type {?} */


          var urlTree = this.parseUrl(url);
          return containsTree(this.currentUrlTree, urlTree, exact);
        }
        /**
         * @private
         * @param {?} params
         * @return {?}
         */

      }, {
        key: "removeEmptyProps",
        value: function removeEmptyProps(params) {
          return Object.keys(params).reduce(
          /**
          * @param {?} result
          * @param {?} key
          * @return {?}
          */
          function (result, key) {
            /** @type {?} */
            var value = params[key];

            if (value !== null && value !== undefined) {
              result[key] = value;
            }

            return result;
          }, {});
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "processNavigations",
        value: function processNavigations() {
          var _this92 = this;

          this.navigations.subscribe(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            _this92.navigated = true;
            _this92.lastSuccessfulId = t.id;

            /** @type {?} */
            _this92.events.next(new NavigationEnd(t.id, _this92.serializeUrl(t.extractedUrl), _this92.serializeUrl(_this92.currentUrlTree)));

            _this92.lastSuccessfulNavigation = _this92.currentNavigation;
            _this92.currentNavigation = null;
            t.resolve(true);
          },
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            _this92.console.warn("Unhandled Navigation Error: ");
          });
        }
        /**
         * @private
         * @param {?} rawUrl
         * @param {?} source
         * @param {?} restoredState
         * @param {?} extras
         * @param {?=} priorPromise
         * @return {?}
         */

      }, {
        key: "scheduleNavigation",
        value: function scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
          /** @type {?} */
          var lastNavigation = this.getTransition(); // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
          // and that navigation results in 'replaceState' that leads to the same URL,
          // we should skip those.

          if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
          } // Because of a bug in IE and Edge, the location class fires two events (popstate and
          // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
          // flicker. Handles the case when a popstate was emitted first.


          if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
          } // Because of a bug in IE and Edge, the location class fires two events (popstate and
          // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
          // flicker. Handles the case when a hashchange was emitted first.


          if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
          }
          /** @type {?} */


          var resolve;
          /** @type {?} */

          var reject;
          /** @type {?} */

          var promise;

          if (priorPromise) {
            resolve = priorPromise.resolve;
            reject = priorPromise.reject;
            promise = priorPromise.promise;
          } else {
            promise = new Promise(
            /**
            * @param {?} res
            * @param {?} rej
            * @return {?}
            */
            function (res, rej) {
              resolve = res;
              reject = rej;
            });
          }
          /** @type {?} */


          var id = ++this.navigationId;
          this.setTransition({
            id: id,
            source: source,
            restoredState: restoredState,
            currentUrlTree: this.currentUrlTree,
            currentRawUrl: this.rawUrlTree,
            rawUrl: rawUrl,
            extras: extras,
            resolve: resolve,
            reject: reject,
            promise: promise,
            currentSnapshot: this.routerState.snapshot,
            currentRouterState: this.routerState
          }); // Make sure that the error is propagated even though `processNavigations` catch
          // handler does not rethrow

          return promise["catch"](
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            return Promise.reject(e);
          });
        }
        /**
         * @private
         * @param {?} url
         * @param {?} replaceUrl
         * @param {?} id
         * @param {?=} state
         * @return {?}
         */

      }, {
        key: "setBrowserUrl",
        value: function setBrowserUrl(url, replaceUrl, id, state) {
          /** @type {?} */
          var path = this.urlSerializer.serialize(url);
          state = state || {};

          if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {
            // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.
            this.location.replaceState(path, '', Object.assign(Object.assign({}, state), {
              navigationId: id
            }));
          } else {
            this.location.go(path, '', Object.assign(Object.assign({}, state), {
              navigationId: id
            }));
          }
        }
        /**
         * @private
         * @param {?} storedState
         * @param {?} storedUrl
         * @param {?} rawUrl
         * @return {?}
         */

      }, {
        key: "resetStateAndUrl",
        value: function resetStateAndUrl(storedState, storedUrl, rawUrl) {
          /** @type {?} */
          this.routerState = storedState;
          this.currentUrlTree = storedUrl;
          this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);
          this.resetUrlToCurrentUrlTree();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "resetUrlToCurrentUrlTree",
        value: function resetUrlToCurrentUrlTree() {
          this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', {
            navigationId: this.lastSuccessfulId
          });
        }
      }, {
        key: "url",
        get: function get() {
          return this.serializeUrl(this.currentUrlTree);
        }
      }]);

      return Router;
    }();

    Router.ɵfac = function Router_Factory(t) {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinvalidFactory"]();
    };

    Router.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: Router
    });

    if (false) {}
    /**
     * @param {?} commands
     * @return {?}
     */


    function validateCommands(commands) {
      for (var i = 0; i < commands.length; i++) {
        /** @type {?} */
        var cmd = commands[i];

        if (cmd == null) {
          throw new Error("The requested path contains ".concat(cmd, " segment at index ").concat(i));
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/directives/router_link.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@description
     *
     * Lets you link to specific routes in your app.
     *
     * Consider the following route configuration:
     * `[{ path: 'user/:name', component: UserCmp }]`.
     * When linking to this `user/:name` route, you use the `RouterLink` directive.
     *
     * If the link is static, you can use the directive as follows:
     * `<a routerLink="/user/bob">link to user component</a>`
     *
     * If you use dynamic values to generate the link, you can pass an array of path
     * segments, followed by the params for each segment.
     *
     * For instance `['/team', teamId, 'user', userName, {details: true}]`
     * means that we want to generate a link to `/team/11/user/bob;details=true`.
     *
     * Multiple static segments can be merged into one
     * (e.g., `['/team/11/user', userName, {details: true}]`).
     *
     * The first segment name can be prepended with `/`, `./`, or `../`:
     * * If the first segment begins with `/`, the router will look up the route from the root of the
     *   app.
     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
     *   instead look in the children of the current activated route.
     * * And if the first segment begins with `../`, the router will go up one level.
     *
     * You can set query params and fragment as follows:
     *
     * ```
     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
     *   link to user component
     * </a>
     * ```
     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
     *
     * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the
     * directive to preserve the current query params and fragment:
     *
     * ```
     * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
     *   link to user component
     * </a>
     * ```
     *
     * You can tell the directive how to handle queryParams. Available options are:
     *  - `'merge'`: merge the queryParams into the current queryParams
     *  - `'preserve'`: preserve the current queryParams
     *  - default/`''`: use the queryParams only
     *
     * Same options for {\@link NavigationExtras#queryParamsHandling
     * NavigationExtras#queryParamsHandling}.
     *
     * ```
     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
     *   link to user component
     * </a>
     * ```
     *
     * You can provide a `state` value to be persisted to the browser's History.state
     * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's
     * used as follows:
     *
     * ```
     * <a [routerLink]="['/user/bob']" [state]="{tracingId: 123}">
     *   link to user component
     * </a>
     * ```
     *
     * And later the value can be read from the router through `router.getCurrentNavigation`.
     * For example, to capture the `tracingId` above during the `NavigationStart` event:
     *
     * ```
     * // Get NavigationStart events
     * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {
     *   const navigation = router.getCurrentNavigation();
     *   tracingService.trace({id: navigation.extras.state.tracingId});
     * });
     * ```
     *
     * The router link directive always treats the provided input as a delta to the current url.
     *
     * For instance, if the current url is `/user/(box//aux:team)`.
     *
     * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
     * `/user/(jim//aux:team)`.
     *
     * See {\@link Router#createUrlTree createUrlTree} for more information.
     *
     * \@ngModule RouterModule
     *
     * \@publicApi
     */


    var RouterLink = /*#__PURE__*/function () {
      /**
       * @param {?} router
       * @param {?} route
       * @param {?} tabIndex
       * @param {?} renderer
       * @param {?} el
       */
      function RouterLink(router, route, tabIndex, renderer, el) {
        _classCallCheck(this, RouterLink);

        this.router = router;
        this.route = route;
        this.commands = [];

        if (tabIndex == null) {
          renderer.setAttribute(el.nativeElement, 'tabindex', '0');
        }
      }
      /**
       * @see {\@link Router#createUrlTree Router#createUrlTree}
       * @param {?} commands An array of commands to pass to {\@link Router#createUrlTree
       *     Router#createUrlTree}.
       *   - **array**: commands to pass to {\@link Router#createUrlTree Router#createUrlTree}.
       *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
       *   - **null|undefined**: shorthand for an empty array of commands, i.e. `[]`
       * @return {?}
       */


      _createClass(RouterLink, [{
        key: "onClick",

        /**
         * @return {?}
         */
        value: function onClick() {
          /** @type {?} */
          var extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
            state: this.state
          };
          this.router.navigateByUrl(this.urlTree, extras);
          return true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "routerLink",
        set: function set(commands) {
          if (commands != null) {
            this.commands = Array.isArray(commands) ? commands : [commands];
          } else {
            this.commands = [];
          }
        }
        /**
         * @deprecated As of Angular v4.0 use `queryParamsHandling` instead.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "preserveQueryParams",
        set: function set(value) {
          if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() &&
          /** @type {?} */
          console &&
          /** @type {?} */
          console.warn) {
            console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');
          }

          this.preserve = value;
        }
      }, {
        key: "urlTree",
        get: function get() {
          return this.router.createUrlTree(this.commands, {
            relativeTo: this.route,
            queryParams: this.queryParams,
            fragment: this.fragment,
            preserveQueryParams: attrBoolValue(this.preserve),
            queryParamsHandling: this.queryParamsHandling,
            preserveFragment: attrBoolValue(this.preserveFragment)
          });
        }
      }]);

      return RouterLink;
    }();

    RouterLink.ɵfac = function RouterLink_Factory(t) {
      return new (t || RouterLink)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](Router), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ActivatedRoute), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinjectAttribute"]('tabindex'), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]));
    };

    RouterLink.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: RouterLink,
      selectors: [["", "routerLink", "", 5, "a", 5, "area"]],
      hostBindings: function RouterLink_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("click", function RouterLink_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
      },
      inputs: {
        routerLink: "routerLink",
        preserveQueryParams: "preserveQueryParams",
        queryParams: "queryParams",
        fragment: "fragment",
        queryParamsHandling: "queryParamsHandling",
        preserveFragment: "preserveFragment",
        skipLocationChange: "skipLocationChange",
        replaceUrl: "replaceUrl",
        state: "state"
      }
    });
    /** @nocollapse */

    RouterLink.ctorParameters = function () {
      return [{
        type: Router
      }, {
        type: ActivatedRoute
      }, {
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"],
          args: ['tabindex']
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    RouterLink.propDecorators = {
      queryParams: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      fragment: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      queryParamsHandling: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      preserveFragment: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      skipLocationChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      replaceUrl: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      state: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      routerLink: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      preserveQueryParams: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterLink, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
        args: [{
          selector: ':not(a):not(area)[routerLink]'
        }]
      }], function () {
        return [{
          type: Router
        }, {
          type: ActivatedRoute
        }, {
          type: String,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"],
            args: ['tabindex']
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
        }];
      }, {
        routerLink: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        preserveQueryParams: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        onClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
          args: ['click']
        }],
        queryParams: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        fragment: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        queryParamsHandling: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        preserveFragment: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        skipLocationChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        replaceUrl: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        state: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }]
      });
    })();

    if (false) {}
    /**
     * \@description
     *
     * Lets you link to specific routes in your app.
     *
     * See `RouterLink` for more information.
     *
     * \@ngModule RouterModule
     *
     * \@publicApi
     */


    var RouterLinkWithHref = /*#__PURE__*/function () {
      /**
       * @param {?} router
       * @param {?} route
       * @param {?} locationStrategy
       */
      function RouterLinkWithHref(router, route, locationStrategy) {
        var _this93 = this;

        _classCallCheck(this, RouterLinkWithHref);

        this.router = router;
        this.route = route;
        this.locationStrategy = locationStrategy;
        this.commands = [];
        this.subscription = router.events.subscribe(
        /**
        * @param {?} s
        * @return {?}
        */
        function (s) {
          if (s instanceof NavigationEnd) {
            _this93.updateTargetUrlAndHref();
          }
        });
      }
      /**
       * @see {\@link Router#createUrlTree Router#createUrlTree}
       * @param {?} commands An array of commands to pass to {\@link Router#createUrlTree
       *     Router#createUrlTree}.
       *   - **array**: commands to pass to {\@link Router#createUrlTree Router#createUrlTree}.
       *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
       *   - **null|undefined**: shorthand for an empty array of commands, i.e. `[]`
       * @return {?}
       */


      _createClass(RouterLinkWithHref, [{
        key: "ngOnChanges",

        /**
         * @param {?} changes
         * @return {?}
         */
        value: function ngOnChanges(changes) {
          this.updateTargetUrlAndHref();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subscription.unsubscribe();
        }
        /**
         * @param {?} button
         * @param {?} ctrlKey
         * @param {?} metaKey
         * @param {?} shiftKey
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick(button, ctrlKey, metaKey, shiftKey) {
          if (button !== 0 || ctrlKey || metaKey || shiftKey) {
            return true;
          }

          if (typeof this.target === 'string' && this.target != '_self') {
            return true;
          }
          /** @type {?} */


          var extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
            state: this.state
          };
          this.router.navigateByUrl(this.urlTree, extras);
          return false;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateTargetUrlAndHref",
        value: function updateTargetUrlAndHref() {
          this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
        }
        /**
         * @return {?}
         */

      }, {
        key: "routerLink",
        set: function set(commands) {
          if (commands != null) {
            this.commands = Array.isArray(commands) ? commands : [commands];
          } else {
            this.commands = [];
          }
        }
        /**
         * @deprecated As of Angular v4.0 use `queryParamsHandling` instead.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "preserveQueryParams",
        set: function set(value) {
          if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() &&
          /** @type {?} */
          console &&
          /** @type {?} */
          console.warn) {
            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
          }

          this.preserve = value;
        }
      }, {
        key: "urlTree",
        get: function get() {
          return this.router.createUrlTree(this.commands, {
            relativeTo: this.route,
            queryParams: this.queryParams,
            fragment: this.fragment,
            preserveQueryParams: attrBoolValue(this.preserve),
            queryParamsHandling: this.queryParamsHandling,
            preserveFragment: attrBoolValue(this.preserveFragment)
          });
        }
      }]);

      return RouterLinkWithHref;
    }();

    RouterLinkWithHref.ɵfac = function RouterLinkWithHref_Factory(t) {
      return new (t || RouterLinkWithHref)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](Router), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ActivatedRoute), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__["LocationStrategy"]));
    };

    RouterLinkWithHref.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: RouterLinkWithHref,
      selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]],
      hostVars: 2,
      hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("click", function RouterLinkWithHref_click_HostBindingHandler($event) {
            return ctx.onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey);
          });
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵhostProperty"]("href", ctx.href, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsanitizeUrl"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("target", ctx.target);
        }
      },
      inputs: {
        routerLink: "routerLink",
        preserveQueryParams: "preserveQueryParams",
        target: "target",
        queryParams: "queryParams",
        fragment: "fragment",
        queryParamsHandling: "queryParamsHandling",
        preserveFragment: "preserveFragment",
        skipLocationChange: "skipLocationChange",
        replaceUrl: "replaceUrl",
        state: "state"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
    });
    /** @nocollapse */

    RouterLinkWithHref.ctorParameters = function () {
      return [{
        type: Router
      }, {
        type: ActivatedRoute
      }, {
        type: _angular_common__WEBPACK_IMPORTED_MODULE_0__["LocationStrategy"]
      }];
    };

    RouterLinkWithHref.propDecorators = {
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.target']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      queryParams: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      fragment: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      queryParamsHandling: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      preserveFragment: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      skipLocationChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      replaceUrl: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      state: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      href: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"]
      }],
      routerLink: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      preserveQueryParams: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterLinkWithHref, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
        args: [{
          selector: 'a[routerLink],area[routerLink]'
        }]
      }], function () {
        return [{
          type: Router
        }, {
          type: ActivatedRoute
        }, {
          type: _angular_common__WEBPACK_IMPORTED_MODULE_0__["LocationStrategy"]
        }];
      }, {
        routerLink: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        preserveQueryParams: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        onClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
          args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']]
        }],
        href: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"]
        }],
        target: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['attr.target']
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        queryParams: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        fragment: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        queryParamsHandling: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        preserveFragment: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        skipLocationChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        replaceUrl: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        state: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }]
      });
    })();

    if (false) {}
    /**
     * @param {?} s
     * @return {?}
     */


    function attrBoolValue(s) {
      return s === '' || !!s;
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/directives/router_link_active.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     *
     * \@description
     *
     * Lets you add a CSS class to an element when the link's route becomes active.
     *
     * This directive lets you add a CSS class to an element when the link's route
     * becomes active.
     *
     * Consider the following example:
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
     * ```
     *
     * When the url is either '/user' or '/user/bob', the active-link class will
     * be added to the `a` tag. If the url changes, the class will be removed.
     *
     * You can set more than one class, as follows:
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
     * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
     * ```
     *
     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
     * only when the url matches the link exactly.
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
     * true}">Bob</a>
     * ```
     *
     * You can assign the RouterLinkActive instance to a template variable and directly check
     * the `isActive` status.
     * ```
     * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
     *   Bob {{ rla.isActive ? '(already open)' : ''}}
     * </a>
     * ```
     *
     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
     *
     * ```
     * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
     *   <a routerLink="/user/jim">Jim</a>
     *   <a routerLink="/user/bob">Bob</a>
     * </div>
     * ```
     *
     * This will set the active-link class on the div tag if the url is either '/user/jim' or
     * '/user/bob'.
     *
     * \@ngModule RouterModule
     *
     * \@publicApi
     */


    var RouterLinkActive = /*#__PURE__*/function () {
      /**
       * @param {?} router
       * @param {?} element
       * @param {?} renderer
       * @param {?=} link
       * @param {?=} linkWithHref
       */
      function RouterLinkActive(router, element, renderer, link, linkWithHref) {
        var _this94 = this;

        _classCallCheck(this, RouterLinkActive);

        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.link = link;
        this.linkWithHref = linkWithHref;
        this.classes = [];
        this.isActive = false;
        this.routerLinkActiveOptions = {
          exact: false
        };
        this.subscription = router.events.subscribe(
        /**
        * @param {?} s
        * @return {?}
        */
        function (s) {
          if (s instanceof NavigationEnd) {
            _this94.update();
          }
        });
      }
      /**
       * @return {?}
       */


      _createClass(RouterLinkActive, [{
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this95 = this;

          this.links.changes.subscribe(
          /**
          * @param {?} _
          * @return {?}
          */
          function (_) {
            return _this95.update();
          });
          this.linksWithHrefs.changes.subscribe(
          /**
          * @param {?} _
          * @return {?}
          */
          function (_) {
            return _this95.update();
          });
          this.update();
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "ngOnChanges",

        /**
         * @param {?} changes
         * @return {?}
         */
        value: function ngOnChanges(changes) {
          this.update();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subscription.unsubscribe();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "update",
        value: function update() {
          var _this96 = this;

          if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;
          Promise.resolve().then(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var hasActiveLinks = _this96.hasActiveLinks();

            if (_this96.isActive !== hasActiveLinks) {
              /** @type {?} */
              _this96.isActive = hasActiveLinks;

              _this96.classes.forEach(
              /**
              * @param {?} c
              * @return {?}
              */
              function (c) {
                if (hasActiveLinks) {
                  _this96.renderer.addClass(_this96.element.nativeElement, c);
                } else {
                  _this96.renderer.removeClass(_this96.element.nativeElement, c);
                }
              });
            }
          });
        }
        /**
         * @private
         * @param {?} router
         * @return {?}
         */

      }, {
        key: "isLinkActive",
        value: function isLinkActive(router) {
          var _this97 = this;

          return (
            /**
            * @param {?} link
            * @return {?}
            */
            function (link) {
              return router.isActive(link.urlTree, _this97.routerLinkActiveOptions.exact);
            }
          );
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "hasActiveLinks",
        value: function hasActiveLinks() {
          /** @type {?} */
          var isActiveCheckFn = this.isLinkActive(this.router);
          return this.link && isActiveCheckFn(this.link) || this.linkWithHref && isActiveCheckFn(this.linkWithHref) || this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
        }
      }, {
        key: "routerLinkActive",
        set: function set(data) {
          /** @type {?} */
          var classes = Array.isArray(data) ? data : data.split(' ');
          this.classes = classes.filter(
          /**
          * @param {?} c
          * @return {?}
          */
          function (c) {
            return !!c;
          });
        }
      }]);

      return RouterLinkActive;
    }();

    RouterLinkActive.ɵfac = function RouterLinkActive_Factory(t) {
      return new (t || RouterLinkActive)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](Router), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](RouterLink, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](RouterLinkWithHref, 8));
    };

    RouterLinkActive.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: RouterLinkActive,
      selectors: [["", "routerLinkActive", ""]],
      contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵcontentQuery"](dirIndex, RouterLink, true);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵcontentQuery"](dirIndex, RouterLinkWithHref, true);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵloadQuery"]()) && (ctx.links = _t);
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵloadQuery"]()) && (ctx.linksWithHrefs = _t);
        }
      },
      inputs: {
        routerLinkActiveOptions: "routerLinkActiveOptions",
        routerLinkActive: "routerLinkActive"
      },
      exportAs: ["routerLinkActive"],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]]
    });
    /** @nocollapse */

    RouterLinkActive.ctorParameters = function () {
      return [{
        type: Router
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: RouterLink,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: RouterLinkWithHref,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    RouterLinkActive.propDecorators = {
      links: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [RouterLink, {
          descendants: true
        }]
      }],
      linksWithHrefs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [RouterLinkWithHref, {
          descendants: true
        }]
      }],
      routerLinkActiveOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      routerLinkActive: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterLinkActive, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
        args: [{
          selector: '[routerLinkActive]',
          exportAs: 'routerLinkActive'
        }]
      }], function () {
        return [{
          type: Router
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
        }, {
          type: RouterLink,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
          }]
        }, {
          type: RouterLinkWithHref,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
          }]
        }];
      }, {
        routerLinkActiveOptions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        routerLinkActive: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        links: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
          args: [RouterLink, {
            descendants: true
          }]
        }],
        linksWithHrefs: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
          args: [RouterLinkWithHref, {
            descendants: true
          }]
        }]
      });
    })();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router_outlet_context.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Store contextual information about a `RouterOutlet`
     *
     * \@publicApi
     */


    var OutletContext = function OutletContext() {
      _classCallCheck(this, OutletContext);

      this.outlet = null;
      this.route = null;
      this.resolver = null;
      this.children = new ChildrenOutletContexts();
      this.attachRef = null;
    };

    if (false) {}
    /**
     * Store contextual information about the children (= nested) `RouterOutlet`
     *
     * \@publicApi
     */


    var ChildrenOutletContexts = /*#__PURE__*/function () {
      function ChildrenOutletContexts() {
        _classCallCheck(this, ChildrenOutletContexts);

        // contexts for child outlets, by name.
        this.contexts = new Map();
      }
      /**
       * Called when a `RouterOutlet` directive is instantiated
       * @param {?} childName
       * @param {?} outlet
       * @return {?}
       */


      _createClass(ChildrenOutletContexts, [{
        key: "onChildOutletCreated",
        value: function onChildOutletCreated(childName, outlet) {
          /** @type {?} */
          var context = this.getOrCreateContext(childName);
          context.outlet = outlet;
          this.contexts.set(childName, context);
        }
        /**
         * Called when a `RouterOutlet` directive is destroyed.
         * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
         * re-created later.
         * @param {?} childName
         * @return {?}
         */

      }, {
        key: "onChildOutletDestroyed",
        value: function onChildOutletDestroyed(childName) {
          /** @type {?} */
          var context = this.getContext(childName);

          if (context) {
            context.outlet = null;
          }
        }
        /**
         * Called when the corresponding route is deactivated during navigation.
         * Because the component get destroyed, all children outlet are destroyed.
         * @return {?}
         */

      }, {
        key: "onOutletDeactivated",
        value: function onOutletDeactivated() {
          /** @type {?} */
          var contexts = this.contexts;
          this.contexts = new Map();
          return contexts;
        }
        /**
         * @param {?} contexts
         * @return {?}
         */

      }, {
        key: "onOutletReAttached",
        value: function onOutletReAttached(contexts) {
          this.contexts = contexts;
        }
        /**
         * @param {?} childName
         * @return {?}
         */

      }, {
        key: "getOrCreateContext",
        value: function getOrCreateContext(childName) {
          /** @type {?} */
          var context = this.getContext(childName);

          if (!context) {
            context = new OutletContext();
            this.contexts.set(childName, context);
          }

          return context;
        }
        /**
         * @param {?} childName
         * @return {?}
         */

      }, {
        key: "getContext",
        value: function getContext(childName) {
          return this.contexts.get(childName) || null;
        }
      }]);

      return ChildrenOutletContexts;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/directives/router_outlet.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@description
     *
     * Acts as a placeholder that Angular dynamically fills based on the current router state.
     *
     * Each outlet can have a unique name, determined by the optional `name` attribute.
     * The name cannot be set or changed dynamically. If not set, default value is "primary".
     *
     * ```
     * <router-outlet></router-outlet>
     * <router-outlet name='left'></router-outlet>
     * <router-outlet name='right'></router-outlet>
     * ```
     *
     * A router outlet emits an activate event when a new component is instantiated,
     * and a deactivate event when a component is destroyed.
     *
     * ```
     * <router-outlet
     *   (activate)='onActivate($event)'
     *   (deactivate)='onDeactivate($event)'></router-outlet>
     * ```
     * \@ngModule RouterModule
     *
     * \@publicApi
     */


    var RouterOutlet = /*#__PURE__*/function () {
      /**
       * @param {?} parentContexts
       * @param {?} location
       * @param {?} resolver
       * @param {?} name
       * @param {?} changeDetector
       */
      function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {
        _classCallCheck(this, RouterOutlet);

        this.parentContexts = parentContexts;
        this.location = location;
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.activated = null;
        this._activatedRoute = null;
        this.activateEvents = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.deactivateEvents = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.name = name || PRIMARY_OUTLET;
        parentContexts.onChildOutletCreated(this.name, this);
      }
      /**
       * @return {?}
       */


      _createClass(RouterOutlet, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.parentContexts.onChildOutletDestroyed(this.name);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          if (!this.activated) {
            // If the outlet was not instantiated at the time the route got activated we need to populate
            // the outlet when it is initialized (ie inside a NgIf)

            /** @type {?} */
            var context = this.parentContexts.getContext(this.name);

            if (context && context.route) {
              if (context.attachRef) {
                // `attachRef` is populated when there is an existing component to mount
                this.attach(context.attachRef, context.route);
              } else {
                // otherwise the component defined in the configuration is created
                this.activateWith(context.route, context.resolver || null);
              }
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "detach",

        /**
         * Called when the `RouteReuseStrategy` instructs to detach the subtree
         * @return {?}
         */
        value: function detach() {
          if (!this.activated) throw new Error('Outlet is not activated');
          this.location.detach();
          /** @type {?} */

          var cmp = this.activated;
          this.activated = null;
          this._activatedRoute = null;
          return cmp;
        }
        /**
         * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
         * @param {?} ref
         * @param {?} activatedRoute
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach(ref, activatedRoute) {
          this.activated = ref;
          this._activatedRoute = activatedRoute;
          this.location.insert(ref.hostView);
        }
        /**
         * @return {?}
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          if (this.activated) {
            /** @type {?} */
            var c = this.component;
            this.activated.destroy();
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
          }
        }
        /**
         * @param {?} activatedRoute
         * @param {?} resolver
         * @return {?}
         */

      }, {
        key: "activateWith",
        value: function activateWith(activatedRoute, resolver) {
          if (this.isActivated) {
            throw new Error('Cannot activate an already activated outlet');
          }

          this._activatedRoute = activatedRoute;
          /** @type {?} */

          var snapshot = activatedRoute._futureSnapshot;
          /** @type {?} */

          var component =
          /** @type {?} */

          /** @type {?} */
          snapshot.routeConfig.component;
          resolver = resolver || this.resolver;
          /** @type {?} */

          var factory = resolver.resolveComponentFactory(component);
          /** @type {?} */

          var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
          /** @type {?} */

          var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
          this.activated = this.location.createComponent(factory, this.location.length, injector); // Calling `markForCheck` to make sure we will run the change detection when the
          // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.

          this.changeDetector.markForCheck();
          this.activateEvents.emit(this.activated.instance);
        }
      }, {
        key: "isActivated",
        get: function get() {
          return !!this.activated;
        }
        /**
         * @return {?}
         */

      }, {
        key: "component",
        get: function get() {
          if (!this.activated) throw new Error('Outlet is not activated');
          return this.activated.instance;
        }
        /**
         * @return {?}
         */

      }, {
        key: "activatedRoute",
        get: function get() {
          if (!this.activated) throw new Error('Outlet is not activated');
          return (
            /** @type {?} */
            this._activatedRoute
          );
        }
        /**
         * @return {?}
         */

      }, {
        key: "activatedRouteData",
        get: function get() {
          if (this._activatedRoute) {
            return this._activatedRoute.snapshot.data;
          }

          return {};
        }
      }]);

      return RouterOutlet;
    }();

    RouterOutlet.ɵfac = function RouterOutlet_Factory(t) {
      return new (t || RouterOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ChildrenOutletContexts), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinjectAttribute"]('name'), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]));
    };

    RouterOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: RouterOutlet,
      selectors: [["router-outlet"]],
      outputs: {
        activateEvents: "activate",
        deactivateEvents: "deactivate"
      },
      exportAs: ["outlet"]
    });
    /** @nocollapse */

    RouterOutlet.ctorParameters = function () {
      return [{
        type: ChildrenOutletContexts
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"],
          args: ['name']
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    RouterOutlet.propDecorators = {
      activateEvents: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
        args: ['activate']
      }],
      deactivateEvents: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
        args: ['deactivate']
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterOutlet, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
        args: [{
          selector: 'router-outlet',
          exportAs: 'outlet'
        }]
      }], function () {
        return [{
          type: ChildrenOutletContexts
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
        }, {
          type: String,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"],
            args: ['name']
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
        }];
      }, {
        activateEvents: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['activate']
        }],
        deactivateEvents: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['deactivate']
        }]
      });
    })();

    if (false) {}

    var OutletInjector = /*#__PURE__*/function () {
      /**
       * @param {?} route
       * @param {?} childContexts
       * @param {?} parent
       */
      function OutletInjector(route, childContexts, parent) {
        _classCallCheck(this, OutletInjector);

        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */


      _createClass(OutletInjector, [{
        key: "get",
        value: function get(token, notFoundValue) {
          if (token === ActivatedRoute) {
            return this.route;
          }

          if (token === ChildrenOutletContexts) {
            return this.childContexts;
          }

          return this.parent.get(token, notFoundValue);
        }
      }]);

      return OutletInjector;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router_preloader.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@description
     *
     * Provides a preloading strategy.
     *
     * \@publicApi
     * @abstract
     */


    var PreloadingStrategy = function PreloadingStrategy() {
      _classCallCheck(this, PreloadingStrategy);
    };

    if (false) {}
    /**
     * \@description
     *
     * Provides a preloading strategy that preloads all modules as quickly as possible.
     *
     * ```
     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
     * ```
     *
     * \@publicApi
     */


    var PreloadAllModules = /*#__PURE__*/function () {
      function PreloadAllModules() {
        _classCallCheck(this, PreloadAllModules);
      }

      _createClass(PreloadAllModules, [{
        key: "preload",

        /**
         * @param {?} route
         * @param {?} fn
         * @return {?}
         */
        value: function preload(route, fn) {
          return fn().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(
          /**
          * @return {?}
          */
          function () {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(null);
          }));
        }
      }]);

      return PreloadAllModules;
    }();
    /**
     * \@description
     *
     * Provides a preloading strategy that does not preload any modules.
     *
     * This strategy is enabled by default.
     *
     * \@publicApi
     */


    var NoPreloading = /*#__PURE__*/function () {
      function NoPreloading() {
        _classCallCheck(this, NoPreloading);
      }

      _createClass(NoPreloading, [{
        key: "preload",

        /**
         * @param {?} route
         * @param {?} fn
         * @return {?}
         */
        value: function preload(route, fn) {
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(null);
        }
      }]);

      return NoPreloading;
    }();
    /**
     * The preloader optimistically loads all router configurations to
     * make navigations into lazily-loaded sections of the application faster.
     *
     * The preloader runs in the background. When the router bootstraps, the preloader
     * starts listening to all navigation events. After every such event, the preloader
     * will check if any configurations can be loaded lazily.
     *
     * If a route is protected by `canLoad` guards, the preloaded will not load it.
     *
     * \@publicApi
     */


    var RouterPreloader = /*#__PURE__*/function () {
      /**
       * @param {?} router
       * @param {?} moduleLoader
       * @param {?} compiler
       * @param {?} injector
       * @param {?} preloadingStrategy
       */
      function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
        _classCallCheck(this, RouterPreloader);

        this.router = router;
        this.injector = injector;
        this.preloadingStrategy = preloadingStrategy;
        /** @type {?} */

        var onStartLoad =
        /**
        * @param {?} r
        * @return {?}
        */
        function onStartLoad(r) {
          return router.triggerEvent(new RouteConfigLoadStart(r));
        };
        /** @type {?} */


        var onEndLoad =
        /**
        * @param {?} r
        * @return {?}
        */
        function onEndLoad(r) {
          return router.triggerEvent(new RouteConfigLoadEnd(r));
        };

        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
      }
      /**
       * @return {?}
       */


      _createClass(RouterPreloader, [{
        key: "setUpPreloading",
        value: function setUpPreloading() {
          var _this98 = this;

          this.subscription = this.router.events.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            return e instanceof NavigationEnd;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["concatMap"])(
          /**
          * @return {?}
          */
          function () {
            return _this98.preload();
          })).subscribe(
          /**
          * @return {?}
          */
          function () {});
        }
        /**
         * @return {?}
         */

      }, {
        key: "preload",
        value: function preload() {
          /** @type {?} */
          var ngModule = this.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"]);
          return this.processRoutes(ngModule, this.router.config);
        } // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If
        // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This
        // should be refactored.

        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subscription.unsubscribe();
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} routes
         * @return {?}
         */

      }, {
        key: "processRoutes",
        value: function processRoutes(ngModule, routes) {
          /** @type {?} */
          var res = [];

          var _iterator12 = _createForOfIteratorHelper(routes),
              _step12;

          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var route = _step12.value;

              // we already have the config loaded, just recurse
              if (route.loadChildren && !route.canLoad && route._loadedConfig) {
                /** @type {?} */
                var childConfig = route._loadedConfig;
                res.push(this.processRoutes(childConfig.module, childConfig.routes)); // no config loaded, fetch the config
              } else if (route.loadChildren && !route.canLoad) {
                res.push(this.preloadConfig(ngModule, route)); // recurse into children
              } else if (route.children) {
                res.push(this.processRoutes(ngModule, route.children));
              }
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(res).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeAll"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} _
          * @return {?}
          */
          function (_) {
            return void 0;
          }));
        }
        /**
         * @private
         * @param {?} ngModule
         * @param {?} route
         * @return {?}
         */

      }, {
        key: "preloadConfig",
        value: function preloadConfig(ngModule, route) {
          var _this99 = this;

          return this.preloadingStrategy.preload(route,
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var loaded$ = _this99.loader.load(ngModule.injector, route);

            return loaded$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["mergeMap"])(
            /**
            * @param {?} config
            * @return {?}
            */
            function (config) {
              route._loadedConfig = config;
              return _this99.processRoutes(config.module, config.routes);
            }));
          });
        }
      }]);

      return RouterPreloader;
    }();

    RouterPreloader.ɵfac = function RouterPreloader_Factory(t) {
      return new (t || RouterPreloader)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](Router), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactoryLoader"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](PreloadingStrategy));
    };

    RouterPreloader.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
      token: RouterPreloader,
      factory: RouterPreloader.ɵfac
    });
    /** @nocollapse */

    RouterPreloader.ctorParameters = function () {
      return [{
        type: Router
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactoryLoader"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
      }, {
        type: PreloadingStrategy
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterPreloader, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
      }], function () {
        return [{
          type: Router
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactoryLoader"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
        }, {
          type: PreloadingStrategy
        }];
      }, null);
    })();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router_scroller.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var RouterScroller = /*#__PURE__*/function () {
      /**
       * @param {?} router
       * @param {?} viewportScroller
       * @param {?=} options
       */
      function RouterScroller(router, viewportScroller) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, RouterScroller);

        this.router = router;
        this.viewportScroller = viewportScroller;
        this.options = options;
        this.lastId = 0;
        this.lastSource = 'imperative';
        this.restoredId = 0;
        this.store = {}; // Default both options to 'disabled'

        options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';
        options.anchorScrolling = options.anchorScrolling || 'disabled';
      }
      /**
       * @return {?}
       */


      _createClass(RouterScroller, [{
        key: "init",
        value: function init() {
          // we want to disable the automatic scrolling because having two places
          // responsible for scrolling results race conditions, especially given
          // that browser don't implement this behavior consistently
          if (this.options.scrollPositionRestoration !== 'disabled') {
            this.viewportScroller.setHistoryScrollRestoration('manual');
          }

          this.routerEventsSubscription = this.createScrollEvents();
          this.scrollEventsSubscription = this.consumeScrollEvents();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "createScrollEvents",
        value: function createScrollEvents() {
          var _this100 = this;

          return this.router.events.subscribe(
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            if (e instanceof NavigationStart) {
              // store the scroll position of the current stable navigations.
              _this100.store[_this100.lastId] = _this100.viewportScroller.getScrollPosition();
              _this100.lastSource = e.navigationTrigger;
              _this100.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
            } else if (e instanceof NavigationEnd) {
              _this100.lastId = e.id;

              _this100.scheduleScrollEvent(e, _this100.router.parseUrl(e.urlAfterRedirects).fragment);
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "consumeScrollEvents",
        value: function consumeScrollEvents() {
          var _this101 = this;

          return this.router.events.subscribe(
          /**
          * @param {?} e
          * @return {?}
          */
          function (e) {
            if (!(e instanceof Scroll)) return; // a popstate event. The pop state event will always ignore anchor scrolling.

            if (e.position) {
              if (_this101.options.scrollPositionRestoration === 'top') {
                _this101.viewportScroller.scrollToPosition([0, 0]);
              } else if (_this101.options.scrollPositionRestoration === 'enabled') {
                _this101.viewportScroller.scrollToPosition(e.position);
              } // imperative navigation "forward"

            } else {
              if (e.anchor && _this101.options.anchorScrolling === 'enabled') {
                _this101.viewportScroller.scrollToAnchor(e.anchor);
              } else if (_this101.options.scrollPositionRestoration !== 'disabled') {
                _this101.viewportScroller.scrollToPosition([0, 0]);
              }
            }
          });
        }
        /**
         * @private
         * @param {?} routerEvent
         * @param {?} anchor
         * @return {?}
         */

      }, {
        key: "scheduleScrollEvent",
        value: function scheduleScrollEvent(routerEvent, anchor) {
          this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.routerEventsSubscription) {
            this.routerEventsSubscription.unsubscribe();
          }

          if (this.scrollEventsSubscription) {
            this.scrollEventsSubscription.unsubscribe();
          }
        }
      }]);

      return RouterScroller;
    }();

    RouterScroller.ɵfac = function RouterScroller_Factory(t) {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinvalidFactory"]();
    };

    RouterScroller.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: RouterScroller
    });

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/router_module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The directives defined in the `RouterModule`.
     * @type {?}
     */


    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent];
    /**
     * A [DI token](guide/glossary/#di-token) for the router service.
     *
     * \@publicApi
     * @type {?}
     */

    var ROUTER_CONFIGURATION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('ROUTER_CONFIGURATION');
    /**
     * \@docsNotRequired
     * @type {?}
     */

    var ROUTER_FORROOT_GUARD = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('ROUTER_FORROOT_GUARD');
    var ɵ0 = {
      enableTracing: false
    };
    /** @type {?} */

    var ROUTER_PROVIDERS = [_angular_common__WEBPACK_IMPORTED_MODULE_0__["Location"], {
      provide: UrlSerializer,
      useClass: DefaultUrlSerializer
    }, {
      provide: Router,
      useFactory: setupRouter,
      deps: [UrlSerializer, ChildrenOutletContexts, _angular_common__WEBPACK_IMPORTED_MODULE_0__["Location"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactoryLoader"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"], ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]()], [RouteReuseStrategy, new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]()]]
    }, ChildrenOutletContexts, {
      provide: ActivatedRoute,
      useFactory: rootRoute,
      deps: [Router]
    }, {
      provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactoryLoader"],
      useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SystemJsNgModuleLoader"]
    }, RouterPreloader, NoPreloading, PreloadAllModules, {
      provide: ROUTER_CONFIGURATION,
      useValue: ɵ0
    }];
    /**
     * @return {?}
     */

    function routerNgProbeToken() {
      return new _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgProbeToken"]('Router', Router);
    }
    /**
     * \@usageNotes
     *
     * RouterModule can be imported multiple times: once per lazily-loaded bundle.
     * Since the router deals with a global shared resource--location, we cannot have
     * more than one router service active.
     *
     * That is why there are two ways to create the module: `RouterModule.forRoot` and
     * `RouterModule.forChild`.
     *
     * * `forRoot` creates a module that contains all the directives, the given routes, and the router
     *   service itself.
     * * `forChild` creates a module that contains all the directives and the given routes, but does not
     *   include the router service.
     *
     * When registered at the root, the module should be used as follows
     *
     * ```
     * \@NgModule({
     *   imports: [RouterModule.forRoot(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * For submodules and lazy loaded submodules the module should be used as follows:
     *
     * ```
     * \@NgModule({
     *   imports: [RouterModule.forChild(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * \@description
     *
     * Adds router directives and providers.
     *
     * Managing state transitions is one of the hardest parts of building applications. This is
     * especially true on the web, where you also need to ensure that the state is reflected in the URL.
     * In addition, we often want to split applications into multiple bundles and load them on demand.
     * Doing this transparently is not trivial.
     *
     * The Angular router service solves these problems. Using the router, you can declaratively specify
     * application states, manage state transitions while taking care of the URL, and load bundles on
     * demand.
     *
     * @see [Routing and Navigation](guide/router.html) for an
     * overview of how the router service should be used.
     *
     * \@publicApi
     */


    var RouterModule = /*#__PURE__*/function () {
      // Note: We are injecting the Router so it gets created eagerly...

      /**
       * @param {?} guard
       * @param {?} router
       */
      function RouterModule(guard, router) {
        _classCallCheck(this, RouterModule);
      }
      /**
       * Creates and configures a module with all the router providers and directives.
       * Optionally sets up an application listener to perform an initial navigation.
       *
       * @param {?} routes An array of `Route` objects that define the navigation paths for the application.
       * @param {?=} config An `ExtraOptions` configuration object that controls how navigation is performed.
       * @return {?} The new router module.
       */


      _createClass(RouterModule, null, [{
        key: "forRoot",
        value: function forRoot(routes, config) {
          return {
            ngModule: RouterModule,
            providers: [ROUTER_PROVIDERS, provideRoutes(routes), {
              provide: ROUTER_FORROOT_GUARD,
              useFactory: provideForRootGuard,
              deps: [[Router, new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"]()]]
            }, {
              provide: ROUTER_CONFIGURATION,
              useValue: config ? config : {}
            }, {
              provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__["LocationStrategy"],
              useFactory: provideLocationStrategy,
              deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["PlatformLocation"], [new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__["APP_BASE_HREF"]), new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]()], ROUTER_CONFIGURATION]
            }, {
              provide: RouterScroller,
              useFactory: createRouterScroller,
              deps: [Router, _angular_common__WEBPACK_IMPORTED_MODULE_0__["ViewportScroller"], ROUTER_CONFIGURATION]
            }, {
              provide: PreloadingStrategy,
              useExisting: config && config.preloadingStrategy ? config.preloadingStrategy : NoPreloading
            }, {
              provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgProbeToken"],
              multi: true,
              useFactory: routerNgProbeToken
            }, provideRouterInitializer()]
          };
        }
        /**
         * Creates a module with all the router directives and a provider registering routes.
         * @param {?} routes
         * @return {?}
         */

      }, {
        key: "forChild",
        value: function forChild(routes) {
          return {
            ngModule: RouterModule,
            providers: [provideRoutes(routes)]
          };
        }
      }]);

      return RouterModule;
    }();

    RouterModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
      type: RouterModule
    });
    RouterModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
      factory: function RouterModule_Factory(t) {
        return new (t || RouterModule)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](ROUTER_FORROOT_GUARD, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](Router, 8));
      }
    });
    /** @nocollapse */

    RouterModule.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [ROUTER_FORROOT_GUARD]
        }]
      }, {
        type: Router,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](RouterModule, {
        declarations: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent],
        exports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
        args: [{
          declarations: ROUTER_DIRECTIVES,
          exports: ROUTER_DIRECTIVES,
          entryComponents: [ɵEmptyOutletComponent]
        }]
      }], function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
            args: [ROUTER_FORROOT_GUARD]
          }]
        }, {
          type: Router,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
          }]
        }];
      }, null);
    })();
    /**
     * @param {?} router
     * @param {?} viewportScroller
     * @param {?} config
     * @return {?}
     */


    function createRouterScroller(router, viewportScroller, config) {
      if (config.scrollOffset) {
        viewportScroller.setOffset(config.scrollOffset);
      }

      return new RouterScroller(router, viewportScroller, config);
    }
    /**
     * @param {?} platformLocationStrategy
     * @param {?} baseHref
     * @param {?=} options
     * @return {?}
     */


    function provideLocationStrategy(platformLocationStrategy, baseHref) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return options.useHash ? new _angular_common__WEBPACK_IMPORTED_MODULE_0__["HashLocationStrategy"](platformLocationStrategy, baseHref) : new _angular_common__WEBPACK_IMPORTED_MODULE_0__["PathLocationStrategy"](platformLocationStrategy, baseHref);
    }
    /**
     * @param {?} router
     * @return {?}
     */


    function provideForRootGuard(router) {
      if (router) {
        throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
      }

      return 'guarded';
    }
    /**
     * Registers a [DI provider](guide/glossary#provider) for a set of routes.
     * \@usageNotes
     *
     * ```
     * \@NgModule({
     *   imports: [RouterModule.forChild(ROUTES)],
     *   providers: [provideRoutes(EXTRA_ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * \@publicApi
     * @param {?} routes The route configuration to provide.
     *
     * @return {?}
     */


    function provideRoutes(routes) {
      return [{
        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ANALYZE_FOR_ENTRY_COMPONENTS"],
        multi: true,
        useValue: routes
      }, {
        provide: ROUTES,
        multi: true,
        useValue: routes
      }];
    }
    /**
     * A set of configuration options for a router module, provided in the
     * `forRoot()` method.
     *
     * \@publicApi
     * @record
     */


    function ExtraOptions() {}

    if (false) {}
    /**
     * @param {?} urlSerializer
     * @param {?} contexts
     * @param {?} location
     * @param {?} injector
     * @param {?} loader
     * @param {?} compiler
     * @param {?} config
     * @param {?=} opts
     * @param {?=} urlHandlingStrategy
     * @param {?=} routeReuseStrategy
     * @return {?}
     */


    function setupRouter(urlSerializer, contexts, location, injector, loader, compiler, config) {
      var opts = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
      var urlHandlingStrategy = arguments.length > 8 ? arguments[8] : undefined;
      var routeReuseStrategy = arguments.length > 9 ? arguments[9] : undefined;

      /** @type {?} */
      var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));

      if (urlHandlingStrategy) {
        router.urlHandlingStrategy = urlHandlingStrategy;
      }

      if (routeReuseStrategy) {
        router.routeReuseStrategy = routeReuseStrategy;
      }

      if (opts.errorHandler) {
        router.errorHandler = opts.errorHandler;
      }

      if (opts.malformedUriErrorHandler) {
        router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
      }

      if (opts.enableTracing) {
        /** @type {?} */
        var dom = Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])();
        router.events.subscribe(
        /**
        * @param {?} e
        * @return {?}
        */
        function (e) {
          dom.logGroup("Router Event: ".concat(
          /** @type {?} */
          e.constructor.name));
          dom.log(e.toString());
          dom.log(e);
          dom.logGroupEnd();
        });
      }

      if (opts.onSameUrlNavigation) {
        router.onSameUrlNavigation = opts.onSameUrlNavigation;
      }

      if (opts.paramsInheritanceStrategy) {
        router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
      }

      if (opts.urlUpdateStrategy) {
        router.urlUpdateStrategy = opts.urlUpdateStrategy;
      }

      if (opts.relativeLinkResolution) {
        router.relativeLinkResolution = opts.relativeLinkResolution;
      }

      return router;
    }
    /**
     * @param {?} router
     * @return {?}
     */


    function rootRoute(router) {
      return router.routerState.root;
    }
    /**
     * Router initialization requires two steps:
     *
     * First, we start the navigation in a `APP_INITIALIZER` to block the bootstrap if
     * a resolver or a guard executes asynchronously.
     *
     * Next, we actually run activation in a `BOOTSTRAP_LISTENER`, using the
     * `afterPreactivation` hook provided by the router.
     * The router navigation starts, reaches the point when preactivation is done, and then
     * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
     */


    var RouterInitializer = /*#__PURE__*/function () {
      /**
       * @param {?} injector
       */
      function RouterInitializer(injector) {
        _classCallCheck(this, RouterInitializer);

        this.injector = injector;
        this.initNavigation = false;
        this.resultOfPreactivationDone = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
      }
      /**
       * @return {?}
       */


      _createClass(RouterInitializer, [{
        key: "appInitializer",
        value: function appInitializer() {
          var _this102 = this;

          /** @type {?} */
          var p = this.injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_0__["LOCATION_INITIALIZED"], Promise.resolve(null));
          return p.then(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var resolve =
            /** @type {?} */
            null;
            /** @type {?} */

            var res = new Promise(
            /**
            * @param {?} r
            * @return {?}
            */
            function (r) {
              return resolve = r;
            });
            /** @type {?} */

            var router = _this102.injector.get(Router);
            /** @type {?} */


            var opts = _this102.injector.get(ROUTER_CONFIGURATION);

            if (_this102.isLegacyDisabled(opts) || _this102.isLegacyEnabled(opts)) {
              resolve(true);
            } else if (opts.initialNavigation === 'disabled') {
              router.setUpLocationChangeListener();
              resolve(true);
            } else if (opts.initialNavigation === 'enabled') {
              router.hooks.afterPreactivation =
              /**
              * @return {?}
              */
              function () {
                // only the initial navigation should be delayed
                if (!_this102.initNavigation) {
                  _this102.initNavigation = true;
                  resolve(true);
                  return _this102.resultOfPreactivationDone; // subsequent navigations should not be delayed
                } else {
                  return (
                    /** @type {?} */
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(null)
                  );
                }
              };

              router.initialNavigation();
            } else {
              throw new Error("Invalid initialNavigation options: '".concat(opts.initialNavigation, "'"));
            }

            return res;
          });
        }
        /**
         * @param {?} bootstrappedComponentRef
         * @return {?}
         */

      }, {
        key: "bootstrapListener",
        value: function bootstrapListener(bootstrappedComponentRef) {
          /** @type {?} */
          var opts = this.injector.get(ROUTER_CONFIGURATION);
          /** @type {?} */

          var preloader = this.injector.get(RouterPreloader);
          /** @type {?} */

          var routerScroller = this.injector.get(RouterScroller);
          /** @type {?} */

          var router = this.injector.get(Router);
          /** @type {?} */

          var ref = this.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ApplicationRef"]);

          if (bootstrappedComponentRef !== ref.components[0]) {
            return;
          }

          if (this.isLegacyEnabled(opts)) {
            router.initialNavigation();
          } else if (this.isLegacyDisabled(opts)) {
            router.setUpLocationChangeListener();
          }

          preloader.setUpPreloading();
          routerScroller.init();
          router.resetRootComponentType(ref.componentTypes[0]);
          this.resultOfPreactivationDone.next(
          /** @type {?} */
          null);
          this.resultOfPreactivationDone.complete();
        }
        /**
         * @private
         * @param {?} opts
         * @return {?}
         */

      }, {
        key: "isLegacyEnabled",
        value: function isLegacyEnabled(opts) {
          return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true || opts.initialNavigation === undefined;
        }
        /**
         * @private
         * @param {?} opts
         * @return {?}
         */

      }, {
        key: "isLegacyDisabled",
        value: function isLegacyDisabled(opts) {
          return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
        }
      }]);

      return RouterInitializer;
    }();

    RouterInitializer.ɵfac = function RouterInitializer_Factory(t) {
      return new (t || RouterInitializer)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]));
    };

    RouterInitializer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
      token: RouterInitializer,
      factory: RouterInitializer.ɵfac
    });
    /** @nocollapse */

    RouterInitializer.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](RouterInitializer, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
        }];
      }, null);
    })();

    if (false) {}
    /**
     * @param {?} r
     * @return {?}
     */


    function getAppInitializer(r) {
      return r.appInitializer.bind(r);
    }
    /**
     * @param {?} r
     * @return {?}
     */


    function getBootstrapListener(r) {
      return r.bootstrapListener.bind(r);
    }
    /**
     * A [DI token](guide/glossary/#di-token) for the router initializer that
     * is called after the app is bootstrapped.
     *
     * \@publicApi
     * @type {?}
     */


    var ROUTER_INITIALIZER = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('Router Initializer');
    /**
     * @return {?}
     */

    function provideRouterInitializer() {
      return [RouterInitializer, {
        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["APP_INITIALIZER"],
        multi: true,
        useFactory: getAppInitializer,
        deps: [RouterInitializer]
      }, {
        provide: ROUTER_INITIALIZER,
        useFactory: getBootstrapListener,
        deps: [RouterInitializer]
      }, {
        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["APP_BOOTSTRAP_LISTENER"],
        multi: true,
        useExisting: ROUTER_INITIALIZER
      }];
    }
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/version.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@publicApi
     * @type {?}
     */


    var VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Version"]('9.1.11');
    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/private_export.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/src/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: packages/router/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=router.js.map

    /***/
  },

  /***/
  "../../node_modules/@juristr/ngx-lazy-el/__ivy_ngcc__/fesm2015/juristr-ngx-lazy-el.js":
  /*!*****************************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/@juristr/ngx-lazy-el/__ivy_ngcc__/fesm2015/juristr-ngx-lazy-el.js ***!
    \*****************************************************************************************************************************/

  /*! exports provided: ComponentLoaderService, NgxLazyElModule, ɵa, ɵb */

  /***/
  function node_modulesJuristrNgxLazyEl__ivy_ngcc__Fesm2015JuristrNgxLazyElJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ComponentLoaderService", function () {
      return ComponentLoaderService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgxLazyElModule", function () {
      return NgxLazyElModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return LAZY_CMPS_PATH_TOKEN;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return LazyLoadDirective;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "@angular/common");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var _angular_elements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/elements */
    "@angular/elements");
    /* harmony import */


    var _angular_elements__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_elements__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! rxjs */
    "rxjs");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_3__);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Injection token to provide the element path modules.
     * @type {?}
     */


    var LAZY_CMPS_PATH_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('ngx-lazy-cmp-registry');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var ComponentLoaderService = /*#__PURE__*/function () {
      /**
       * @param {?} injector
       * @param {?} elementModulePaths
       * @param {?} compiler
       */
      function ComponentLoaderService(injector, elementModulePaths, compiler) {
        _classCallCheck(this, ComponentLoaderService);

        this.injector = injector;
        this.compiler = compiler;
        this.loadedCmps = new Map();
        this.elementsLoading = new Map();
        /** @type {?} */

        var ELEMENT_MODULE_PATHS = new Map();
        elementModulePaths.forEach(
        /**
        * @param {?} route
        * @return {?}
        */
        function (route) {
          ELEMENT_MODULE_PATHS.set(route.selector, route);
        });
        this.componentsToLoad = ELEMENT_MODULE_PATHS;
      }
      /**
       * @return {?}
       */


      _createClass(ComponentLoaderService, [{
        key: "getComponentsToLoad",
        value: function getComponentsToLoad() {
          return this.componentsToLoad.keys();
        }
        /**
         * Heavily inspired by the Angular elements loader on the official repo
         * @param {?} tags
         * @return {?}
         */
        // loadContainedCustomElements(
        //   element: HTMLElement
        // ): Observable<LazyCmpLoadedEvent[]> {
        //   const unregisteredSelectors = Array.from(
        //     this.componentsToLoad.keys()
        //   ).filter(s => element.querySelector(s));
        //   // already registered elements
        //   const alreadyRegistered = Array.from(this.loadedCmps.keys()).filter(s =>
        //     element.querySelector(s)
        //   );
        //   // add the already registered in...elements won't be recreated
        //   // the "loadComponent(...)"
        //   unregisteredSelectors.push(...alreadyRegistered);
        //   // Returns observable that completes when all discovered elements have been registered.
        //   const allRegistered = Promise.all(
        //     unregisteredSelectors.map(async s => {
        //       // element.querySelector(s).remove();
        //       const result = await this.loadComponent(s, true);
        //       return result;
        //     })
        //   );
        //   return from(allRegistered);
        // }

      }, {
        key: "loadContainedCustomElements",
        value: function loadContainedCustomElements(tags) {
          var _this103 = this;

          /** @type {?} */
          var unregisteredSelectors = Array.from(this.componentsToLoad.keys()).filter(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return tags.find(
            /**
            * @param {?} x
            * @return {?}
            */
            function (x) {
              return x.toLowerCase() === s.toLowerCase();
            });
          }); // already registered elements

          /** @type {?} */

          var alreadyRegistered = Array.from(this.loadedCmps.keys()).filter(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return tags.find(
            /**
            * @param {?} x
            * @return {?}
            */
            function (x) {
              return x.toLowerCase() === s.toLowerCase();
            });
          }); // add the already registered in...elements won't be recreated
          // the "loadComponent(...)"

          unregisteredSelectors.push.apply(unregisteredSelectors, _toConsumableArray(alreadyRegistered)); // Returns observable that completes when all discovered elements have been registered.

          /** @type {?} */

          var allRegistered = Promise.all(unregisteredSelectors.map(
          /**
          * @param {?} s
          * @return {?}
          */
          function (s) {
            return _this103.loadComponent(s, false);
          }));
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["from"])(allRegistered);
        }
        /**
         * Allows to lazy load a component given it's selector (i.e. tagname).
         * If the component selector has been registered, it's according module
         * will be fetched lazily
         * @param {?} componentTag selector of the component to load
         * @param {?=} createInstance if true, creates an element and returns it in the promise
         * @return {?}
         */

      }, {
        key: "loadComponent",
        value: function loadComponent(componentTag) {
          var _this104 = this;

          var createInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (this.elementsLoading.has(componentTag)) {
            return this.elementsLoading.get(componentTag);
          }

          if (this.componentsToLoad.has(componentTag)) {
            /** @type {?} */
            var cmpRegistryEntry = this.componentsToLoad.get(componentTag);
            /** @type {?} */

            var path = cmpRegistryEntry.loadChildren;
            /** @type {?} */

            var loadPromise = new Promise(
            /**
            * @param {?} resolve
            * @param {?} reject
            * @return {?}
            */
            function (resolve, reject) {
              /** @type {?} */
              path(). // this.loader
              //   .load(path)
              then(
              /**
              * @param {?} elementModuleOrFactory
              * @return {?}
              */
              function (elementModuleOrFactory) {
                /**
                 * With View Engine, the NgModule factory is created and provided when loaded.
                 * With Ivy, only the NgModule class is provided loaded and must be compiled.
                 * This uses the same mechanism as the deprecated `SystemJsNgModuleLoader` in
                 * in `packages/core/src/linker/system_js_ng_module_factory_loader.ts`
                 * to pass on the NgModuleFactory, or compile the NgModule and return its NgModuleFactory.
                 */
                if (elementModuleOrFactory instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleFactory"]) {
                  return elementModuleOrFactory;
                } else {
                  try {
                    return _this104.compiler.compileModuleAsync(elementModuleOrFactory);
                  } catch (err) {
                    // return the error
                    reject(err); // break the promise chain

                    throw err;
                  }
                }
              }).then(
              /**
              * @param {?} moduleFactory
              * @return {?}
              */
              function (moduleFactory) {
                try {
                  /** @type {?} */
                  var elementModuleRef = moduleFactory.create(_this104.injector);
                  /** @type {?} */

                  var injector = elementModuleRef.injector;
                  /** @type {?} */

                  var customElementComponent;

                  if (typeof elementModuleRef.instance.customElementComponent === 'object') {
                    customElementComponent = elementModuleRef.instance.customElementComponent[componentTag];

                    if (!customElementComponent) {
                      throw "You specified multiple component elements in module ".concat(elementModuleRef, " but there was no match for tag ").concat(componentTag, " in ").concat(JSON.stringify(elementModuleRef.instance.customElementComponent), ". Make sure the selector in the module is aligned with the one specified in the lazy module definition.");
                    }
                  } else {
                    customElementComponent = elementModuleRef.instance.customElementComponent;
                  }
                  /** @type {?} */


                  var CustomElement = Object(_angular_elements__WEBPACK_IMPORTED_MODULE_2__["createCustomElement"])(customElementComponent, {
                    injector: injector
                  }); // define the Angular Element

                  /** @type {?} */
                  customElements.define(componentTag, CustomElement);
                  customElements.whenDefined(componentTag).then(
                  /**
                  * @return {?}
                  */
                  function () {
                    // remember for next time
                    _this104.loadedCmps.set(componentTag, elementModuleRef); // instantiate the component

                    /** @type {?} */


                    var componentInstance = createInstance ? document.createElement(componentTag) : null; // const componentInstance = null;

                    resolve({
                      selector: componentTag,
                      componentInstance: componentInstance
                    });
                  }).then(
                  /**
                  * @return {?}
                  */
                  function () {
                    _this104.elementsLoading["delete"](componentTag);

                    _this104.componentsToLoad["delete"](componentTag);
                  })["catch"](
                  /**
                  * @param {?} err
                  * @return {?}
                  */
                  function (err) {
                    _this104.elementsLoading["delete"](componentTag);

                    return Promise.reject(err);
                  });
                } catch (err) {
                  reject(err);
                  throw err;
                }
              })["catch"](
              /**
              * @param {?} err
              * @return {?}
              */
              function (err) {
                _this104.elementsLoading["delete"](componentTag);

                return Promise.reject(err);
              });
            });
            this.elementsLoading.set(componentTag, loadPromise);
            return loadPromise;
          } else if (this.loadedCmps.has(componentTag)) {
            // component already loaded
            return new Promise(
            /**
            * @param {?} resolve
            * @return {?}
            */
            function (resolve) {
              resolve({
                selector: componentTag,
                componentInstance: createInstance ? document.createElement(componentTag) : null
              });
            });
          } else {
            throw new Error("Unrecognized component \"".concat(componentTag, "\". Make sure it is registered in the component registry"));
          }
        }
      }]);

      return ComponentLoaderService;
    }();

    ComponentLoaderService.ɵfac = function ComponentLoaderService_Factory(t) {
      return new (t || ComponentLoaderService)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](LAZY_CMPS_PATH_TOKEN), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]));
    };

    ComponentLoaderService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
      token: ComponentLoaderService,
      factory: ComponentLoaderService.ɵfac,
      providedIn: 'root'
    });
    /** @nocollapse */

    ComponentLoaderService.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
      }, {
        type: Array,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [LAZY_CMPS_PATH_TOKEN]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]
      }];
    };
    /** @nocollapse */


    ComponentLoaderService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function ComponentLoaderService_Factory() {
        return new ComponentLoaderService(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(LAZY_CMPS_PATH_TOKEN), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]));
      },
      token: ComponentLoaderService,
      providedIn: "root"
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](ComponentLoaderService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
        args: [{
          providedIn: 'root'
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
        }, {
          type: Array,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
            args: [LAZY_CMPS_PATH_TOKEN]
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Compiler"]
        }];
      }, null);
    })();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var LazyLoadDirective = /*#__PURE__*/function () {
      /**
       * @param {?} elementRef
       * @param {?} componentLoader
       * @param {?} cd
       * @param {?} vcr
       * @param {?} template
       */
      function LazyLoadDirective(elementRef, componentLoader, cd, vcr, template) {
        _classCallCheck(this, LazyLoadDirective);

        this.elementRef = elementRef;
        this.componentLoader = componentLoader;
        this.cd = cd;
        this.vcr = vcr;
        this.template = template; // @Input() ngxLazyEl: string[] | string | null;

        this.loaded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @return {?}
       */


      _createClass(LazyLoadDirective, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this105 = this;

          /** @type {?} */
          var nodeTags;

          if (!nodeTags) {
            // try to automatically infer the elemements

            /** @type {?} */
            var template = this.template.createEmbeddedView({});

            if (template.rootNodes[0].children.length > 0) {
              // we probably have a container with elements in it, so try to load all of them
              // lazily
              nodeTags = _toConsumableArray(template.rootNodes[0].children).map(
              /**
              * @param {?} x
              * @return {?}
              */
              function (x) {
                return x.tagName.toLowerCase();
              });
            } else {
              nodeTags = [template.rootNodes[0].tagName.toLowerCase()];
            }
          }

          if (!nodeTags) {
            throw new Error("Unable to automatically determine the dynamic element selectors. Alternatively you can pass them in via the *ngxLazyEl=\"['my-lazy-el']\"");
          }

          this.componentLoader // .loadContainedCustomElements(this.elementRef.nativeElement)
          .loadContainedCustomElements(nodeTags).subscribe(
          /**
          * @param {?} elements
          * @return {?}
          */
          function (elements) {
            _this105.vcr.clear();

            _this105.vcr.createEmbeddedView(_this105.template); // try to get the element DOM

            /** @type {?} */


            var domInstance = null;

            if (_this105.elementRef.nativeElement.parentElement) {
              domInstance = _this105.elementRef.nativeElement.parentElement.querySelector(elements[0].selector);
            }

            _this105.notifyComponentLoaded({
              selector: nodeTags[0],
              componentInstance: domInstance
            });
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isIvyMode",
        value: function isIvyMode() {
          return (
            /** @type {?} */
            this.template._declarationTContainer
          );
        }
        /**
         * @private
         * @param {?} lazyCmpEv
         * @return {?}
         */

      }, {
        key: "notifyComponentLoaded",
        value: function notifyComponentLoaded(lazyCmpEv) {
          this.loaded.emit({
            selector: lazyCmpEv.selector,
            componentInstance: lazyCmpEv.componentInstance
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          console.log('lazy load destroyed');
        }
      }]);

      return LazyLoadDirective;
    }();

    LazyLoadDirective.ɵfac = function LazyLoadDirective_Factory(t) {
      return new (t || LazyLoadDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](ComponentLoaderService), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]));
    };

    LazyLoadDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: LazyLoadDirective,
      selectors: [["", "ngxLazyEl", ""]],
      outputs: {
        loaded: "loaded"
      }
    });
    /** @nocollapse */

    LazyLoadDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: ComponentLoaderService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    LazyLoadDirective.propDecorators = {
      loaded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](LazyLoadDirective, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
        args: [{
          selector: '[ngxLazyEl]'
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
        }, {
          type: ComponentLoaderService
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
        }];
      }, {
        loaded: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }]
      });
    })();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NgxLazyElModule = /*#__PURE__*/function () {
      function NgxLazyElModule() {
        _classCallCheck(this, NgxLazyElModule);
      }

      _createClass(NgxLazyElModule, null, [{
        key: "forRoot",

        /**
         * @param {?} modulePaths
         * @return {?}
         */
        value: function forRoot(modulePaths) {
          return {
            ngModule: NgxLazyElModule,
            providers: [// { provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader },
            {
              provide: LAZY_CMPS_PATH_TOKEN,
              useValue: modulePaths
            }]
          };
        }
      }]);

      return NgxLazyElModule;
    }();

    NgxLazyElModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
      type: NgxLazyElModule
    });
    NgxLazyElModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
      factory: function NgxLazyElModule_Factory(t) {
        return new (t || NgxLazyElModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](NgxLazyElModule, {
        declarations: function declarations() {
          return [LazyLoadDirective];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]];
        },
        exports: function exports() {
          return [LazyLoadDirective];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](NgxLazyElModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]],
          declarations: [LazyLoadDirective],
          exports: [LazyLoadDirective]
        }]
      }], null, null);
    })(); //# sourceMappingURL=juristr-ngx-lazy-el.js.map

    /***/

  },

  /***/
  "../../node_modules/hammerjs/hammer.js":
  /*!******************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/hammerjs/hammer.js ***!
    \******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesHammerjsHammerJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    /*! Hammer.JS - v2.0.7 - 2016-04-22
    * http://hammerjs.github.io/
    *
    * Copyright (c) 2016 Jorik Tangelder;
    * Licensed under the MIT license */


    (function (window, document, exportName, undefined) {
      'use strict';

      var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
      var TEST_ELEMENT = document.createElement('div');
      var TYPE_FUNCTION = 'function';
      var round = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      /**
       * set a timeout with a given scope
       * @param {Function} fn
       * @param {Number} timeout
       * @param {Object} context
       * @returns {number}
       */

      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      /**
       * if the argument is an array, we want to execute the fn on each entry
       * if it aint an array we don't want to do a thing.
       * this is used by all the methods that accept a single and array argument.
       * @param {*|Array} arg
       * @param {String} fn
       * @param {Object} [context]
       * @returns {Boolean}
       */


      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }

        return false;
      }
      /**
       * walk objects and arrays
       * @param {Object} obj
       * @param {Function} iterator
       * @param {Object} context
       */


      function each(obj, iterator, context) {
        var i;

        if (!obj) {
          return;
        }

        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
          i = 0;

          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      /**
       * wrap a method with a deprecation warning and stack trace
       * @param {Function} method
       * @param {String} name
       * @param {String} message
       * @returns {Function} A new function wrapping the supplied method.
       */


      function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function () {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
          var log = window.console && (window.console.warn || window.console.log);

          if (log) {
            log.call(window.console, deprecationMessage, stack);
          }

          return method.apply(this, arguments);
        };
      }
      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} target
       * @param {...Object} objects_to_assign
       * @returns {Object} target
       */


      var assign;

      if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
          if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);

          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];

            if (source !== undefined && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }

          return output;
        };
      } else {
        assign = Object.assign;
      }
      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} dest
       * @param {Object} src
       * @param {Boolean} [merge=false]
       * @returns {Object} dest
       */


      var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;

        while (i < keys.length) {
          if (!merge || merge && dest[keys[i]] === undefined) {
            dest[keys[i]] = src[keys[i]];
          }

          i++;
        }

        return dest;
      }, 'extend', 'Use `assign`.');
      /**
       * merge the values from src in the dest.
       * means that properties that exist in dest will not be overwritten by src
       * @param {Object} dest
       * @param {Object} src
       * @returns {Object} dest
       */

      var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
      }, 'merge', 'Use `assign`.');
      /**
       * simple class inheritance
       * @param {Function} child
       * @param {Function} base
       * @param {Object} [properties]
       */

      function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
          assign(childP, properties);
        }
      }
      /**
       * simple function bind
       * @param {Function} fn
       * @param {Object} context
       * @returns {Function}
       */


      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      /**
       * let a boolean value also be a function that must return a boolean
       * this first item in args will be used as the context
       * @param {Boolean|Function} val
       * @param {Array} [args]
       * @returns {Boolean}
       */


      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined : undefined, args);
        }

        return val;
      }
      /**
       * use the val2 when val1 is undefined
       * @param {*} val1
       * @param {*} val2
       * @returns {*}
       */


      function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
      }
      /**
       * addEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */


      function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.addEventListener(type, handler, false);
        });
      }
      /**
       * removeEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */


      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.removeEventListener(type, handler, false);
        });
      }
      /**
       * find if a node is in the given parent
       * @method hasParent
       * @param {HTMLElement} node
       * @param {HTMLElement} parent
       * @return {Boolean} found
       */


      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }

          node = node.parentNode;
        }

        return false;
      }
      /**
       * small indexOf wrapper
       * @param {String} str
       * @param {String} find
       * @returns {Boolean} found
       */


      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      /**
       * split string on whitespace
       * @param {String} str
       * @returns {Array} words
       */


      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      /**
       * find if a array contains the object using indexOf or a simple polyFill
       * @param {Array} src
       * @param {String} find
       * @param {String} [findByKey]
       * @return {Boolean|Number} false when not found, or the index
       */


      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;

          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }

            i++;
          }

          return -1;
        }
      }
      /**
       * convert array-like objects to real arrays
       * @param {Object} obj
       * @returns {Array}
       */


      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      /**
       * unique array with objects based on a key (like 'id') or just by the array's value
       * @param {Array} src [{id:1},{id:2},{id:1}]
       * @param {String} [key]
       * @param {Boolean} [sort=False]
       * @returns {Array} [{id:1},{id:2}]
       */


      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
          var val = key ? src[i][key] : src[i];

          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }

          values[i] = val;
          i++;
        }

        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }

        return results;
      }
      /**
       * get the prefixed property
       * @param {Object} obj
       * @param {String} property
       * @returns {String|Undefined} prefixed
       */


      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;

        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;

          if (prop in obj) {
            return prop;
          }

          i++;
        }

        return undefined;
      }
      /**
       * get a unique id
       * @returns {number} uniqueId
       */


      var _uniqueId = 1;

      function uniqueId() {
        return _uniqueId++;
      }
      /**
       * get the window object of an element
       * @param {HTMLElement} element
       * @returns {DocumentView|Window}
       */


      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
      }

      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = ('ontouchstart' in window);
      var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = 'touch';
      var INPUT_TYPE_PEN = 'pen';
      var INPUT_TYPE_MOUSE = 'mouse';
      var INPUT_TYPE_KINECT = 'kinect';
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ['x', 'y'];
      var PROPS_CLIENT_XY = ['clientX', 'clientY'];
      /**
       * create new input type manager
       * @param {Manager} manager
       * @param {Function} callback
       * @returns {Input}
       * @constructor
       */

      function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.

        this.domHandler = function (ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
          }
        };

        this.init();
      }

      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function handler() {},

        /**
         * bind the events
         */
        init: function init() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function destroy() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      /**
       * create new input type manager
       * called by the Manager constructor
       * @param {Hammer} manager
       * @returns {Input}
       */

      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }

        return new Type(manager, inputHandler);
      }
      /**
       * handle input events
       * @param {Manager} manager
       * @param {String} eventType
       * @param {Object} input
       */


      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
          manager.session = {};
        } // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'


        input.eventType = eventType; // compute scale, rotation etc

        computeInputData(manager, input); // emit secret event

        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      /**
       * extend the data with some usable properties like scale, rotate, velocity etc
       * @param {Object} manager
       * @param {Object} input
       */


      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length; // store the first input to calculate the distance and direction

        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        } // to compute scale and rotation we need to store the multiple touches


        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input); // find the correct target

        var target = manager.element;

        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }

        input.target = target;
      }

      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      /**
       * velocity is calculated every x ms
       * @param {Object} session
       * @param {Object} input
       */


      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      /**
       * create a simple clone from the input used for storage of firstInput and firstMultiple
       * @param {Object} input
       * @returns {Object} clonedInputData
       */


      function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;

        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
          };
          i++;
        }

        return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      /**
       * get the center of all the pointers
       * @param {Array} pointers
       * @return {Object} center contains `x` and `y` properties
       */


      function getCenter(pointers) {
        var pointersLength = pointers.length; // no need to loop when only one touch

        if (pointersLength === 1) {
          return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
          };
        }

        var x = 0,
            y = 0,
            i = 0;

        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }

        return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
        };
      }
      /**
       * calculate the velocity between two points. unit is in px per ms.
       * @param {Number} deltaTime
       * @param {Number} x
       * @param {Number} y
       * @return {Object} velocity `x` and `y`
       */


      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      /**
       * get the direction between two points
       * @param {Number} x
       * @param {Number} y
       * @return {Number} direction
       */


      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }

        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      /**
       * calculate the absolute distance between two points
       * @param {Object} p1 {x, y}
       * @param {Object} p2 {x, y}
       * @param {Array} [props] containing x and y keys
       * @return {Number} distance
       */


      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }

        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      /**
       * calculate the angle between two coordinates
       * @param {Object} p1
       * @param {Object} p2
       * @param {Array} [props] containing x and y keys
       * @return {Number} angle
       */


      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }

        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      /**
       * calculate the rotation degrees between two pointersets
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} rotation
       */


      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      /**
       * calculate the scale factor between two pointersets
       * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} scale
       */


      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }

      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = 'mousedown';
      var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
      /**
       * Mouse events input
       * @constructor
       * @extends Input
       */

      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
      }

      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          } // mouse must be down


          if (!this.pressed) {
            return;
          }

          if (eventType & INPUT_END) {
            this.pressed = false;
          }

          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      }; // in IE10 the pointer types is defined as an enum

      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

      };
      var POINTER_ELEMENT_EVENTS = 'pointerdown';
      var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

      if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
      }
      /**
       * Pointer events input
       * @constructor
       * @extends Input
       */


      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }

      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

          var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          } // it not found, so the pointer hasn't been down (so it's probably a hover)


          if (storeIndex < 0) {
            return;
          } // update the event in the store


          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
          });

          if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
      var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
      /**
       * Touch events input
       * @constructor
       * @extends Input
       */

      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }

      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

          if (type === INPUT_START) {
            this.started = true;
          }

          if (!this.started) {
            return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }

          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */

      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
      }

      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
      /**
       * Multi-user touch events input
       * @constructor
       * @extends Input
       */

      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }

      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);

          if (!touches) {
            return;
          }

          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */

      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target; // get target touches from touches

        targetTouches = allTouches.filter(function (touch) {
          return hasParent(touch.target, target);
        }); // collect touches

        if (type === INPUT_START) {
          i = 0;

          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        } // filter changed touches to only contain touches that exist in the collected target ids


        i = 0;

        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          } // cleanup removed touches


          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }

          i++;
        }

        if (!changedTargetTouches.length) {
          return;
        }

        return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
      }
      /**
       * Combined touch and mouse input
       *
       * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
       * This because touch devices also emit mouse events while doing a touch.
       *
       * @constructor
       * @extends Input
       */


      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;

      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }

      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
              isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }

          this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });

      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }

      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
          var lastTouch = {
            x: touch.clientX,
            y: touch.clientY
          };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;

          var removeLastTouch = function removeLastTouch() {
            var i = lts.indexOf(lastTouch);

            if (i > -1) {
              lts.splice(i, 1);
            }
          };

          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }

      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX,
            y = eventData.srcEvent.clientY;

        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x),
              dy = Math.abs(y - t.y);

          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }

        return false;
      }

      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

      var TOUCH_ACTION_COMPUTE = 'compute';
      var TOUCH_ACTION_AUTO = 'auto';
      var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

      var TOUCH_ACTION_NONE = 'none';
      var TOUCH_ACTION_PAN_X = 'pan-x';
      var TOUCH_ACTION_PAN_Y = 'pan-y';
      var TOUCH_ACTION_MAP = getTouchActionProps();
      /**
       * Touch Action
       * sets the touchAction property or uses the js alternative
       * @param {Manager} manager
       * @param {String} value
       * @constructor
       */

      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }

      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function set(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }

          this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function update() {
          this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function compute() {
          var actions = [];
          each(this.manager.recognizers, function (recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function preventDefaults(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection; // if the touch action did prevented once this session

          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

          if (hasNone) {
            //do not prevent defaults if this is a tap gesture
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }

          if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
          }

          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function preventSrc(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      /**
       * when the touchActions are collected they are not a valid value, so we need to clean things up. *
       * @param {String} actions
       * @returns {*}
       */

      function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning

        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        } // pan-x OR pan-y


        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        } // manipulation


        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
      }

      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }

        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
      }
      /**
       * Recognizer flow explained; *
       * All recognizers have the initial state of POSSIBLE when a input session starts.
       * The definition of a input session is from the first input until the last input, with all it's movement in it. *
       * Example session for mouse-input: mousedown -> mousemove -> mouseup
       *
       * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
       * which determines with state it should be.
       *
       * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
       * POSSIBLE to give it another change on the next cycle.
       *
       *               Possible
       *                  |
       *            +-----+---------------+
       *            |                     |
       *      +-----+-----+               |
       *      |           |               |
       *   Failed      Cancelled          |
       *                          +-------+------+
       *                          |              |
       *                      Recognized       Began
       *                                         |
       *                                      Changed
       *                                         |
       *                                  Ended/Recognized
       */


      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      /**
       * Recognizer
       * Every recognizer needs to extend from this class.
       * @constructor
       * @param {Object} options
       */

      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null; // default is enable true

        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }

      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function set(options) {
          assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

          this.manager && this.manager.touchAction.update();
          return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function recognizeWith(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }

          return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function requireFailure(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }

          return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function dropRequireFailure(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);

          if (index > -1) {
            this.requireFail.splice(index, 1);
          }

          return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function hasRequireFailures() {
          return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function canRecognizeWith(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function emit(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
            self.manager.emit(event, input);
          } // 'panstart' and 'panmove'


          if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) {
            // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
          } // panend and pancancel


          if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function tryEmit(input) {
          if (this.canEmit()) {
            return this.emit(input);
          } // it's failing anyway


          this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function canEmit() {
          var i = 0;

          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }

            i++;
          }

          return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function recognize(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          } // reset when we've reached the end


          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
          // so trigger an event

          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function process(inputData) {},
        // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function getTouchAction() {},

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function reset() {}
      };
      /**
       * get a usable string, used as event postfix
       * @param {Const} state
       * @returns {String} state
       */

      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return 'cancel';
        } else if (state & STATE_ENDED) {
          return 'end';
        } else if (state & STATE_CHANGED) {
          return 'move';
        } else if (state & STATE_BEGAN) {
          return 'start';
        }

        return '';
      }
      /**
       * direction cons to string
       * @param {Const} direction
       * @returns {String}
       */


      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return 'down';
        } else if (direction == DIRECTION_UP) {
          return 'up';
        } else if (direction == DIRECTION_LEFT) {
          return 'left';
        } else if (direction == DIRECTION_RIGHT) {
          return 'right';
        }

        return '';
      }
      /**
       * get a recognizer by name if it is bound to a manager
       * @param {Recognizer|String} otherRecognizer
       * @param {Recognizer} recognizer
       * @returns {Recognizer}
       */


      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;

        if (manager) {
          return manager.get(otherRecognizer);
        }

        return otherRecognizer;
      }
      /**
       * This recognizer is just used as a base for the simple attribute recognizers.
       * @constructor
       * @extends Recognizer
       */


      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }

      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function attrTest(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function process(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }

            return state | STATE_CHANGED;
          }

          return STATE_FAILED;
        }
      });
      /**
       * Pan
       * Recognized when the pointer is down and moved in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */

      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }

      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function getTouchAction() {
          var direction = this.options.direction;
          var actions = [];

          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }

          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }

          return actions;
        },
        directionTest: function directionTest(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY; // lock to axis?

          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }

          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function attrTest(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function emit(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);

          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }

          this._super.emit.call(this, input);
        }
      });
      /**
       * Pinch
       * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
       * @constructor
       * @extends AttrRecognizer
       */

      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }

      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function emit(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
          }

          this._super.emit.call(this, input);
        }
      });
      /**
       * Press
       * Recognized when the pointer is down for x ms without any movement.
       * @constructor
       * @extends Recognizer
       */

      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }

      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: 'press',
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low

        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function process(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input; // we only allow little movement
          // and we've reached an end event, so a tap is possible

          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }

          return STATE_FAILED;
        },
        reset: function reset() {
          clearTimeout(this._timer);
        },
        emit: function emit(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }

          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + 'up', input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      /**
       * Rotate
       * Recognized when two or more pointer are moving in a circular motion.
       * @constructor
       * @extends AttrRecognizer
       */

      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }

      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      /**
       * Swipe
       * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */

      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }

      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function getTouchAction() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function attrTest(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function emit(input) {
          var direction = directionStr(input.offsetDirection);

          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
        }
      });
      /**
       * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
       * between the given interval and position. The delay option can be used to recognize multi-taps without firing
       * a single tap.
       *
       * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
       * multi-taps being recognized.
       * @constructor
       * @extends Recognizer
       */

      function TapRecognizer() {
        Recognizer.apply(this, arguments); // previous time and center,
        // used for tap counting

        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }

      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position

        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function process(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();

          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          } // we only allow little movement
          // and we've reached an end event, so a tap is possible


          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }

            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }

            this._input = input; // if tap count matches we have recognized it,
            // else it has began recognizing...

            var tapCount = this.count % options.taps;

            if (tapCount === 0) {
              // no failing requirements, immediately trigger the tap event
              // or wait as long as the multitap interval to trigger
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function () {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }

          return STATE_FAILED;
        },
        failTimeout: function failTimeout() {
          this._timer = setTimeoutContext(function () {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function reset() {
          clearTimeout(this._timer);
        },
        emit: function emit() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      /**
       * Simple way to create a manager with a default set of recognizers.
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */

      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
      }
      /**
       * @const {string}
       */


      Hammer.VERSION = '2.0.7';
      /**
       * default settings
       * @namespace
       */

      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {
          enable: false
        }], [PinchRecognizer, {
          enable: false
        }, ['rotate']], [SwipeRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }], [PanRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }, ['swipe']], [TapRecognizer], [TapRecognizer, {
          event: 'doubletap',
          taps: 2
        }, ['tap']], [PressRecognizer]],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      /**
       * Manager
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */

      function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function (item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }

      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function set(options) {
          assign(this.options, options); // Options that need a little more setup

          if (options.touchAction) {
            this.touchAction.update();
          }

          if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }

          return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function stop(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function recognize(inputData) {
          var session = this.session;

          if (session.stopped) {
            return;
          } // run the touch-action polyfill


          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`

          var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
          // or when we're in a new session

          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }

          var i = 0;

          while (i < recognizers.length) {
            recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.

            if (session.stopped !== FORCED_STOP && ( // 1
            !curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              // 3
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer


            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }

            i++;
          }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function get(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }

          var recognizers = this.recognizers;

          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }

          return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function add(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
          } // remove existing


          var existing = this.get(recognizer.options.event);

          if (existing) {
            this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function remove(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
          }

          recognizer = this.get(recognizer); // let's make sure this recognizer exists

          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }

          return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function on(events, handler) {
          if (events === undefined) {
            return;
          }

          if (handler === undefined) {
            return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function off(events, handler) {
          if (events === undefined) {
            return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function emit(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          } // no handlers, so skip it all


          var handlers = this.handlers[event] && this.handlers[event].slice();

          if (!handlers || !handlers.length) {
            return;
          }

          data.type = event;

          data.preventDefault = function () {
            data.srcEvent.preventDefault();
          };

          var i = 0;

          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function destroy() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      /**
       * add/remove the css properties as defined in manager.options.cssProps
       * @param {Manager} manager
       * @param {Boolean} add
       */

      function toggleCssProps(manager, add) {
        var element = manager.element;

        if (!element.style) {
          return;
        }

        var prop;
        each(manager.options.cssProps, function (value, name) {
          prop = prefixed(element.style, name);

          if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
          }
        });

        if (!add) {
          manager.oldCssProps = {};
        }
      }
      /**
       * trigger dom event
       * @param {String} event
       * @param {Object} data
       */


      function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }

      assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
      }); // this prevents errors when Hammer is loaded in the presence of an AMD
      //  style loader but by script tag, not by the loader.

      var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

      freeGlobal.Hammer = Hammer;

      if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return Hammer;
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(window, document, 'Hammer');
    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/AsyncSubject.js":
  /*!**************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/AsyncSubject.js ***!
    \**************************************************************************************************/

  /*! exports provided: AsyncSubject */

  /***/
  function node_modulesRxjs_esm2015InternalAsyncSubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsyncSubject", function () {
      return AsyncSubject;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");

    var AsyncSubject = /*#__PURE__*/function (_Subject__WEBPACK_IMP) {
      _inherits(AsyncSubject, _Subject__WEBPACK_IMP);

      var _super19 = _createSuper(AsyncSubject);

      function AsyncSubject() {
        var _this106;

        _classCallCheck(this, AsyncSubject);

        _this106 = _super19.apply(this, arguments);
        _this106.value = null;
        _this106.hasNext = false;
        _this106.hasCompleted = false;
        return _this106;
      }

      _createClass(AsyncSubject, [{
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
          } else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
          }

          return _get(_getPrototypeOf(AsyncSubject.prototype), "_subscribe", this).call(this, subscriber);
        }
      }, {
        key: "next",
        value: function next(value) {
          if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
          }
        }
      }, {
        key: "error",
        value: function error(_error) {
          if (!this.hasCompleted) {
            _get(_getPrototypeOf(AsyncSubject.prototype), "error", this).call(this, _error);
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          this.hasCompleted = true;

          if (this.hasNext) {
            _get(_getPrototypeOf(AsyncSubject.prototype), "next", this).call(this, this.value);
          }

          _get(_getPrototypeOf(AsyncSubject.prototype), "complete", this).call(this);
        }
      }]);

      return AsyncSubject;
    }(_Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]); //# sourceMappingURL=AsyncSubject.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/BehaviorSubject.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/BehaviorSubject.js ***!
    \*****************************************************************************************************/

  /*! exports provided: BehaviorSubject */

  /***/
  function node_modulesRxjs_esm2015InternalBehaviorSubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function () {
      return BehaviorSubject;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/ObjectUnsubscribedError */
    "../../node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");

    var BehaviorSubject = /*#__PURE__*/function (_Subject__WEBPACK_IMP2) {
      _inherits(BehaviorSubject, _Subject__WEBPACK_IMP2);

      var _super20 = _createSuper(BehaviorSubject);

      function BehaviorSubject(_value) {
        var _this107;

        _classCallCheck(this, BehaviorSubject);

        _this107 = _super20.call(this);
        _this107._value = _value;
        return _this107;
      }

      _createClass(BehaviorSubject, [{
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          var subscription = _get(_getPrototypeOf(BehaviorSubject.prototype), "_subscribe", this).call(this, subscriber);

          if (subscription && !subscription.closed) {
            subscriber.next(this._value);
          }

          return subscription;
        }
      }, {
        key: "getValue",
        value: function getValue() {
          if (this.hasError) {
            throw this.thrownError;
          } else if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__["ObjectUnsubscribedError"]();
          } else {
            return this._value;
          }
        }
      }, {
        key: "next",
        value: function next(value) {
          _get(_getPrototypeOf(BehaviorSubject.prototype), "next", this).call(this, this._value = value);
        }
      }, {
        key: "value",
        get: function get() {
          return this.getValue();
        }
      }]);

      return BehaviorSubject;
    }(_Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]); //# sourceMappingURL=BehaviorSubject.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/InnerSubscriber.js ***!
    \*****************************************************************************************************/

  /*! exports provided: InnerSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalInnerSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InnerSubscriber", function () {
      return InnerSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    var InnerSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_) {
      _inherits(InnerSubscriber, _Subscriber__WEBPACK_);

      var _super21 = _createSuper(InnerSubscriber);

      function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this108;

        _classCallCheck(this, InnerSubscriber);

        _this108 = _super21.call(this);
        _this108.parent = parent;
        _this108.outerValue = outerValue;
        _this108.outerIndex = outerIndex;
        _this108.index = 0;
        return _this108;
      }

      _createClass(InnerSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
        }
      }, {
        key: "_error",
        value: function _error(error) {
          this.parent.notifyError(error, this);
          this.unsubscribe();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.parent.notifyComplete(this);
          this.unsubscribe();
        }
      }]);

      return InnerSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=InnerSubscriber.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Notification.js":
  /*!**************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Notification.js ***!
    \**************************************************************************************************/

  /*! exports provided: NotificationKind, Notification */

  /***/
  function node_modulesRxjs_esm2015InternalNotificationJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NotificationKind", function () {
      return NotificationKind;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Notification", function () {
      return Notification;
    });
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./observable/empty */
    "../../node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony import */


    var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./observable/of */
    "../../node_modules/rxjs/_esm2015/internal/observable/of.js");
    /* harmony import */


    var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./observable/throwError */
    "../../node_modules/rxjs/_esm2015/internal/observable/throwError.js");

    var NotificationKind;

    (function (NotificationKind) {
      NotificationKind["NEXT"] = "N";
      NotificationKind["ERROR"] = "E";
      NotificationKind["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));

    var Notification = /*#__PURE__*/function () {
      function Notification(kind, value, error) {
        _classCallCheck(this, Notification);

        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
      }

      _createClass(Notification, [{
        key: "observe",
        value: function observe(observer) {
          switch (this.kind) {
            case 'N':
              return observer.next && observer.next(this.value);

            case 'E':
              return observer.error && observer.error(this.error);

            case 'C':
              return observer.complete && observer.complete();
          }
        }
      }, {
        key: "do",
        value: function _do(next, error, complete) {
          var kind = this.kind;

          switch (kind) {
            case 'N':
              return next && next(this.value);

            case 'E':
              return error && error(this.error);

            case 'C':
              return complete && complete();
          }
        }
      }, {
        key: "accept",
        value: function accept(nextOrObserver, error, complete) {
          if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
          } else {
            return this["do"](nextOrObserver, error, complete);
          }
        }
      }, {
        key: "toObservable",
        value: function toObservable() {
          var kind = this.kind;

          switch (kind) {
            case 'N':
              return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__["of"])(this.value);

            case 'E':
              return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__["throwError"])(this.error);

            case 'C':
              return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__["empty"])();
          }

          throw new Error('unexpected notification kind value');
        }
      }], [{
        key: "createNext",
        value: function createNext(value) {
          if (typeof value !== 'undefined') {
            return new Notification('N', value);
          }

          return Notification.undefinedValueNotification;
        }
      }, {
        key: "createError",
        value: function createError(err) {
          return new Notification('E', undefined, err);
        }
      }, {
        key: "createComplete",
        value: function createComplete() {
          return Notification.completeNotification;
        }
      }]);

      return Notification;
    }();

    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined); //# sourceMappingURL=Notification.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Observable.js":
  /*!************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Observable.js ***!
    \************************************************************************************************/

  /*! exports provided: Observable */

  /***/
  function node_modulesRxjs_esm2015InternalObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Observable", function () {
      return Observable;
    });
    /* harmony import */


    var _util_canReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./util/canReportError */
    "../../node_modules/rxjs/_esm2015/internal/util/canReportError.js");
    /* harmony import */


    var _util_toSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/toSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/util/toSubscriber.js");
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./symbol/observable */
    "../../node_modules/rxjs/_esm2015/internal/symbol/observable.js");
    /* harmony import */


    var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./util/pipe */
    "../../node_modules/rxjs/_esm2015/internal/util/pipe.js");
    /* harmony import */


    var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./config */
    "../../node_modules/rxjs/_esm2015/internal/config.js");

    var Observable = /*#__PURE__*/function () {
      function Observable(subscribe) {
        _classCallCheck(this, Observable);

        this._isScalar = false;

        if (subscribe) {
          this._subscribe = subscribe;
        }
      }

      _createClass(Observable, [{
        key: "lift",
        value: function lift(operator) {
          var observable = new Observable();
          observable.source = this;
          observable.operator = operator;
          return observable;
        }
      }, {
        key: "subscribe",
        value: function subscribe(observerOrNext, error, complete) {
          var operator = this.operator;
          var sink = Object(_util_toSubscriber__WEBPACK_IMPORTED_MODULE_1__["toSubscriber"])(observerOrNext, error, complete);

          if (operator) {
            sink.add(operator.call(sink, this.source));
          } else {
            sink.add(this.source || _config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
          }

          if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
              sink.syncErrorThrowable = false;

              if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
              }
            }
          }

          return sink;
        }
      }, {
        key: "_trySubscribe",
        value: function _trySubscribe(sink) {
          try {
            return this._subscribe(sink);
          } catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
              sink.syncErrorThrown = true;
              sink.syncErrorValue = err;
            }

            if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_0__["canReportError"])(sink)) {
              sink.error(err);
            } else {
              console.warn(err);
            }
          }
        }
      }, {
        key: "forEach",
        value: function forEach(next, promiseCtor) {
          var _this109 = this;

          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this109.subscribe(function (value) {
              try {
                next(value);
              } catch (err) {
                reject(err);

                if (subscription) {
                  subscription.unsubscribe();
                }
              }
            }, reject, resolve);
          });
        }
      }, {
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          var source = this.source;
          return source && source.subscribe(subscriber);
        }
      }, {
        key: _symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"],
        value: function value() {
          return this;
        }
      }, {
        key: "pipe",
        value: function pipe() {
          for (var _len3 = arguments.length, operations = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
            operations[_key4] = arguments[_key4];
          }

          if (operations.length === 0) {
            return this;
          }

          return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipeFromArray"])(operations)(this);
        }
      }, {
        key: "toPromise",
        value: function toPromise(promiseCtor) {
          var _this110 = this;

          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
            var value;

            _this110.subscribe(function (x) {
              return value = x;
            }, function (err) {
              return reject(err);
            }, function () {
              return resolve(value);
            });
          });
        }
      }]);

      return Observable;
    }();

    Observable.create = function (subscribe) {
      return new Observable(subscribe);
    };

    function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
        promiseCtor = _config__WEBPACK_IMPORTED_MODULE_4__["config"].Promise || Promise;
      }

      if (!promiseCtor) {
        throw new Error('no Promise impl found');
      }

      return promiseCtor;
    } //# sourceMappingURL=Observable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Observer.js":
  /*!**********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Observer.js ***!
    \**********************************************************************************************/

  /*! exports provided: empty */

  /***/
  function node_modulesRxjs_esm2015InternalObserverJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "empty", function () {
      return empty;
    });
    /* harmony import */


    var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./config */
    "../../node_modules/rxjs/_esm2015/internal/config.js");
    /* harmony import */


    var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/hostReportError */
    "../../node_modules/rxjs/_esm2015/internal/util/hostReportError.js");

    var empty = {
      closed: true,
      next: function next(value) {},
      error: function error(err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__["config"].useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__["hostReportError"])(err);
        }
      },
      complete: function complete() {}
    }; //# sourceMappingURL=Observer.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/OuterSubscriber.js ***!
    \*****************************************************************************************************/

  /*! exports provided: OuterSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOuterSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OuterSubscriber", function () {
      return OuterSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    var OuterSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_2) {
      _inherits(OuterSubscriber, _Subscriber__WEBPACK_2);

      var _super22 = _createSuper(OuterSubscriber);

      function OuterSubscriber() {
        _classCallCheck(this, OuterSubscriber);

        return _super22.apply(this, arguments);
      }

      _createClass(OuterSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
      }, {
        key: "notifyError",
        value: function notifyError(error, innerSub) {
          this.destination.error(error);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          this.destination.complete();
        }
      }]);

      return OuterSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=OuterSubscriber.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/ReplaySubject.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/ReplaySubject.js ***!
    \***************************************************************************************************/

  /*! exports provided: ReplaySubject */

  /***/
  function node_modulesRxjs_esm2015InternalReplaySubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReplaySubject", function () {
      return ReplaySubject;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _scheduler_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./scheduler/queue */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/queue.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _operators_observeOn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./operators/observeOn */
    "../../node_modules/rxjs/_esm2015/internal/operators/observeOn.js");
    /* harmony import */


    var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./util/ObjectUnsubscribedError */
    "../../node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");
    /* harmony import */


    var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./SubjectSubscription */
    "../../node_modules/rxjs/_esm2015/internal/SubjectSubscription.js");

    var ReplaySubject = /*#__PURE__*/function (_Subject__WEBPACK_IMP3) {
      _inherits(ReplaySubject, _Subject__WEBPACK_IMP3);

      var _super23 = _createSuper(ReplaySubject);

      function ReplaySubject() {
        var _this111;

        var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
        var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;
        var scheduler = arguments.length > 2 ? arguments[2] : undefined;

        _classCallCheck(this, ReplaySubject);

        _this111 = _super23.call(this);
        _this111.scheduler = scheduler;
        _this111._events = [];
        _this111._infiniteTimeWindow = false;
        _this111._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this111._windowTime = windowTime < 1 ? 1 : windowTime;

        if (windowTime === Number.POSITIVE_INFINITY) {
          _this111._infiniteTimeWindow = true;
          _this111.next = _this111.nextInfiniteTimeWindow;
        } else {
          _this111.next = _this111.nextTimeWindow;
        }

        return _this111;
      }

      _createClass(ReplaySubject, [{
        key: "nextInfiniteTimeWindow",
        value: function nextInfiniteTimeWindow(value) {
          var _events = this._events;

          _events.push(value);

          if (_events.length > this._bufferSize) {
            _events.shift();
          }

          _get(_getPrototypeOf(ReplaySubject.prototype), "next", this).call(this, value);
        }
      }, {
        key: "nextTimeWindow",
        value: function nextTimeWindow(value) {
          this._events.push(new ReplayEvent(this._getNow(), value));

          this._trimBufferThenGetEvents();

          _get(_getPrototypeOf(ReplaySubject.prototype), "next", this).call(this, value);
        }
      }, {
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          var _infiniteTimeWindow = this._infiniteTimeWindow;

          var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

          var scheduler = this.scheduler;
          var len = _events.length;
          var subscription;

          if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
          } else if (this.isStopped || this.hasError) {
            subscription = _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
          } else {
            this.observers.push(subscriber);
            subscription = new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__["SubjectSubscription"](this, subscriber);
          }

          if (scheduler) {
            subscriber.add(subscriber = new _operators_observeOn__WEBPACK_IMPORTED_MODULE_3__["ObserveOnSubscriber"](subscriber, scheduler));
          }

          if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
              subscriber.next(_events[i]);
            }
          } else {
            for (var _i8 = 0; _i8 < len && !subscriber.closed; _i8++) {
              subscriber.next(_events[_i8].value);
            }
          }

          if (this.hasError) {
            subscriber.error(this.thrownError);
          } else if (this.isStopped) {
            subscriber.complete();
          }

          return subscription;
        }
      }, {
        key: "_getNow",
        value: function _getNow() {
          return (this.scheduler || _scheduler_queue__WEBPACK_IMPORTED_MODULE_1__["queue"]).now();
        }
      }, {
        key: "_trimBufferThenGetEvents",
        value: function _trimBufferThenGetEvents() {
          var now = this._getNow();

          var _bufferSize = this._bufferSize;
          var _windowTime = this._windowTime;
          var _events = this._events;
          var eventsCount = _events.length;
          var spliceCount = 0;

          while (spliceCount < eventsCount) {
            if (now - _events[spliceCount].time < _windowTime) {
              break;
            }

            spliceCount++;
          }

          if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
          }

          if (spliceCount > 0) {
            _events.splice(0, spliceCount);
          }

          return _events;
        }
      }]);

      return ReplaySubject;
    }(_Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]);

    var ReplayEvent = function ReplayEvent(time, value) {
      _classCallCheck(this, ReplayEvent);

      this.time = time;
      this.value = value;
    }; //# sourceMappingURL=ReplaySubject.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Scheduler.js":
  /*!***********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Scheduler.js ***!
    \***********************************************************************************************/

  /*! exports provided: Scheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Scheduler", function () {
      return Scheduler;
    });

    var Scheduler = /*#__PURE__*/function () {
      function Scheduler(SchedulerAction) {
        var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.now;

        _classCallCheck(this, Scheduler);

        this.SchedulerAction = SchedulerAction;
        this.now = now;
      }

      _createClass(Scheduler, [{
        key: "schedule",
        value: function schedule(work) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var state = arguments.length > 2 ? arguments[2] : undefined;
          return new this.SchedulerAction(this, work).schedule(state, delay);
        }
      }]);

      return Scheduler;
    }();

    Scheduler.now = function () {
      return Date.now();
    }; //# sourceMappingURL=Scheduler.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Subject.js":
  /*!*********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Subject.js ***!
    \*********************************************************************************************/

  /*! exports provided: SubjectSubscriber, Subject, AnonymousSubject */

  /***/
  function node_modulesRxjs_esm2015InternalSubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SubjectSubscriber", function () {
      return SubjectSubscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Subject", function () {
      return Subject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnonymousSubject", function () {
      return AnonymousSubject;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./util/ObjectUnsubscribedError */
    "../../node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");
    /* harmony import */


    var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./SubjectSubscription */
    "../../node_modules/rxjs/_esm2015/internal/SubjectSubscription.js");
    /* harmony import */


    var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../internal/symbol/rxSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js");

    var SubjectSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_3) {
      _inherits(SubjectSubscriber, _Subscriber__WEBPACK_3);

      var _super24 = _createSuper(SubjectSubscriber);

      function SubjectSubscriber(destination) {
        var _this112;

        _classCallCheck(this, SubjectSubscriber);

        _this112 = _super24.call(this, destination);
        _this112.destination = destination;
        return _this112;
      }

      return SubjectSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]);

    var Subject = /*#__PURE__*/function (_Observable__WEBPACK_) {
      _inherits(Subject, _Observable__WEBPACK_);

      var _super25 = _createSuper(Subject);

      function Subject() {
        var _this113;

        _classCallCheck(this, Subject);

        _this113 = _super25.call(this);
        _this113.observers = [];
        _this113.closed = false;
        _this113.isStopped = false;
        _this113.hasError = false;
        _this113.thrownError = null;
        return _this113;
      }

      _createClass(Subject, [{
        key: _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__["rxSubscriber"],
        value: function value() {
          return new SubjectSubscriber(this);
        }
      }, {
        key: "lift",
        value: function lift(operator) {
          var subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
        }
      }, {
        key: "next",
        value: function next(value) {
          if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
          }

          if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();

            for (var i = 0; i < len; i++) {
              copy[i].next(value);
            }
          }
        }
      }, {
        key: "error",
        value: function error(err) {
          if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
          }

          this.hasError = true;
          this.thrownError = err;
          this.isStopped = true;
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();

          for (var i = 0; i < len; i++) {
            copy[i].error(err);
          }

          this.observers.length = 0;
        }
      }, {
        key: "complete",
        value: function complete() {
          if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
          }

          this.isStopped = true;
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();

          for (var i = 0; i < len; i++) {
            copy[i].complete();
          }

          this.observers.length = 0;
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe() {
          this.isStopped = true;
          this.closed = true;
          this.observers = null;
        }
      }, {
        key: "_trySubscribe",
        value: function _trySubscribe(subscriber) {
          if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
          } else {
            return _get(_getPrototypeOf(Subject.prototype), "_trySubscribe", this).call(this, subscriber);
          }
        }
      }, {
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
          } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
          } else if (this.isStopped) {
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
          } else {
            this.observers.push(subscriber);
            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__["SubjectSubscription"](this, subscriber);
          }
        }
      }, {
        key: "asObservable",
        value: function asObservable() {
          var observable = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]();
          observable.source = this;
          return observable;
        }
      }]);

      return Subject;
    }(_Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]);

    Subject.create = function (destination, source) {
      return new AnonymousSubject(destination, source);
    };

    var AnonymousSubject = /*#__PURE__*/function (_Subject) {
      _inherits(AnonymousSubject, _Subject);

      var _super26 = _createSuper(AnonymousSubject);

      function AnonymousSubject(destination, source) {
        var _this114;

        _classCallCheck(this, AnonymousSubject);

        _this114 = _super26.call(this);
        _this114.destination = destination;
        _this114.source = source;
        return _this114;
      }

      _createClass(AnonymousSubject, [{
        key: "next",
        value: function next(value) {
          var destination = this.destination;

          if (destination && destination.next) {
            destination.next(value);
          }
        }
      }, {
        key: "error",
        value: function error(err) {
          var destination = this.destination;

          if (destination && destination.error) {
            this.destination.error(err);
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          var destination = this.destination;

          if (destination && destination.complete) {
            this.destination.complete();
          }
        }
      }, {
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          var source = this.source;

          if (source) {
            return this.source.subscribe(subscriber);
          } else {
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
          }
        }
      }]);

      return AnonymousSubject;
    }(Subject); //# sourceMappingURL=Subject.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/SubjectSubscription.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/SubjectSubscription.js ***!
    \*********************************************************************************************************/

  /*! exports provided: SubjectSubscription */

  /***/
  function node_modulesRxjs_esm2015InternalSubjectSubscriptionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SubjectSubscription", function () {
      return SubjectSubscription;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");

    var SubjectSubscription = /*#__PURE__*/function (_Subscription__WEBPAC) {
      _inherits(SubjectSubscription, _Subscription__WEBPAC);

      var _super27 = _createSuper(SubjectSubscription);

      function SubjectSubscription(subject, subscriber) {
        var _this115;

        _classCallCheck(this, SubjectSubscription);

        _this115 = _super27.call(this);
        _this115.subject = subject;
        _this115.subscriber = subscriber;
        _this115.closed = false;
        return _this115;
      }

      _createClass(SubjectSubscription, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this.closed) {
            return;
          }

          this.closed = true;
          var subject = this.subject;
          var observers = subject.observers;
          this.subject = null;

          if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
          }

          var subscriberIndex = observers.indexOf(this.subscriber);

          if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
          }
        }
      }]);

      return SubjectSubscription;
    }(_Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"]); //# sourceMappingURL=SubjectSubscription.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Subscriber.js":
  /*!************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Subscriber.js ***!
    \************************************************************************************************/

  /*! exports provided: Subscriber, SafeSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Subscriber", function () {
      return Subscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SafeSubscriber", function () {
      return SafeSubscriber;
    });
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./util/isFunction */
    "../../node_modules/rxjs/_esm2015/internal/util/isFunction.js");
    /* harmony import */


    var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./Observer */
    "../../node_modules/rxjs/_esm2015/internal/Observer.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../internal/symbol/rxSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js");
    /* harmony import */


    var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./config */
    "../../node_modules/rxjs/_esm2015/internal/config.js");
    /* harmony import */


    var _util_hostReportError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./util/hostReportError */
    "../../node_modules/rxjs/_esm2015/internal/util/hostReportError.js");

    var Subscriber = /*#__PURE__*/function (_Subscription__WEBPAC2) {
      _inherits(Subscriber, _Subscription__WEBPAC2);

      var _super28 = _createSuper(Subscriber);

      function Subscriber(destinationOrNext, error, complete) {
        var _this116;

        _classCallCheck(this, Subscriber);

        _this116 = _super28.call(this);
        _this116.syncErrorValue = null;
        _this116.syncErrorThrown = false;
        _this116.syncErrorThrowable = false;
        _this116.isStopped = false;

        switch (arguments.length) {
          case 0:
            _this116.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__["empty"];
            break;

          case 1:
            if (!destinationOrNext) {
              _this116.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__["empty"];
              break;
            }

            if (typeof destinationOrNext === 'object') {
              if (destinationOrNext instanceof Subscriber) {
                _this116.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this116.destination = destinationOrNext;
                destinationOrNext.add(_assertThisInitialized(_this116));
              } else {
                _this116.syncErrorThrowable = true;
                _this116.destination = new SafeSubscriber(_assertThisInitialized(_this116), destinationOrNext);
              }

              break;
            }

          default:
            _this116.syncErrorThrowable = true;
            _this116.destination = new SafeSubscriber(_assertThisInitialized(_this116), destinationOrNext, error, complete);
            break;
        }

        return _this116;
      }

      _createClass(Subscriber, [{
        key: _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__["rxSubscriber"],
        value: function value() {
          return this;
        }
      }, {
        key: "next",
        value: function next(value) {
          if (!this.isStopped) {
            this._next(value);
          }
        }
      }, {
        key: "error",
        value: function error(err) {
          if (!this.isStopped) {
            this.isStopped = true;

            this._error(err);
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          if (!this.isStopped) {
            this.isStopped = true;

            this._complete();
          }
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this.closed) {
            return;
          }

          this.isStopped = true;

          _get(_getPrototypeOf(Subscriber.prototype), "unsubscribe", this).call(this);
        }
      }, {
        key: "_next",
        value: function _next(value) {
          this.destination.next(value);
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.destination.error(err);
          this.unsubscribe();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.destination.complete();
          this.unsubscribe();
        }
      }, {
        key: "_unsubscribeAndRecycle",
        value: function _unsubscribeAndRecycle() {
          var _parentOrParents = this._parentOrParents;
          this._parentOrParents = null;
          this.unsubscribe();
          this.closed = false;
          this.isStopped = false;
          this._parentOrParents = _parentOrParents;
          return this;
        }
      }], [{
        key: "create",
        value: function create(next, error, complete) {
          var subscriber = new Subscriber(next, error, complete);
          subscriber.syncErrorThrowable = false;
          return subscriber;
        }
      }]);

      return Subscriber;
    }(_Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]);

    var SafeSubscriber = /*#__PURE__*/function (_Subscriber) {
      _inherits(SafeSubscriber, _Subscriber);

      var _super29 = _createSuper(SafeSubscriber);

      function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this117;

        _classCallCheck(this, SafeSubscriber);

        _this117 = _super29.call(this);
        _this117._parentSubscriber = _parentSubscriber;
        var next;

        var context = _assertThisInitialized(_this117);

        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;

          if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__["empty"]) {
            context = Object.create(observerOrNext);

            if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(context.unsubscribe)) {
              _this117.add(context.unsubscribe.bind(context));
            }

            context.unsubscribe = _this117.unsubscribe.bind(_assertThisInitialized(_this117));
          }
        }

        _this117._context = context;
        _this117._next = next;
        _this117._error = error;
        _this117._complete = complete;
        return _this117;
      }

      _createClass(SafeSubscriber, [{
        key: "next",
        value: function next(value) {
          if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;

            if (!_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
              this.unsubscribe();
            }
          }
        }
      }, {
        key: "error",
        value: function error(err) {
          if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling;

            if (this._error) {
              if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._error, err);

                this.unsubscribe();
              } else {
                this.__tryOrSetError(_parentSubscriber, this._error, err);

                this.unsubscribe();
              }
            } else if (!_parentSubscriber.syncErrorThrowable) {
              this.unsubscribe();

              if (useDeprecatedSynchronousErrorHandling) {
                throw err;
              }

              Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
            } else {
              if (useDeprecatedSynchronousErrorHandling) {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
              } else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
              }

              this.unsubscribe();
            }
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          var _this118 = this;

          if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;

            if (this._complete) {
              var wrappedComplete = function wrappedComplete() {
                return _this118._complete.call(_this118._context);
              };

              if (!_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(wrappedComplete);

                this.unsubscribe();
              } else {
                this.__tryOrSetError(_parentSubscriber, wrappedComplete);

                this.unsubscribe();
              }
            } else {
              this.unsubscribe();
            }
          }
        }
      }, {
        key: "__tryOrUnsub",
        value: function __tryOrUnsub(fn, value) {
          try {
            fn.call(this._context, value);
          } catch (err) {
            this.unsubscribe();

            if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
              throw err;
            } else {
              Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
            }
          }
        }
      }, {
        key: "__tryOrSetError",
        value: function __tryOrSetError(parent, fn, value) {
          if (!_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
          }

          try {
            fn.call(this._context, value);
          } catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
              parent.syncErrorValue = err;
              parent.syncErrorThrown = true;
              return true;
            } else {
              Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
              return true;
            }
          }

          return false;
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var _parentSubscriber = this._parentSubscriber;
          this._context = null;
          this._parentSubscriber = null;

          _parentSubscriber.unsubscribe();
        }
      }]);

      return SafeSubscriber;
    }(Subscriber); //# sourceMappingURL=Subscriber.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/Subscription.js":
  /*!**************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/Subscription.js ***!
    \**************************************************************************************************/

  /*! exports provided: Subscription */

  /***/
  function node_modulesRxjs_esm2015InternalSubscriptionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Subscription", function () {
      return Subscription;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _util_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/isObject */
    "../../node_modules/rxjs/_esm2015/internal/util/isObject.js");
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./util/isFunction */
    "../../node_modules/rxjs/_esm2015/internal/util/isFunction.js");
    /* harmony import */


    var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./util/UnsubscriptionError */
    "../../node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js");

    var Subscription = /*#__PURE__*/function () {
      function Subscription(unsubscribe) {
        _classCallCheck(this, Subscription);

        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;

        if (unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
      }

      _createClass(Subscription, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          var errors;

          if (this.closed) {
            return;
          }

          var _parentOrParents = this._parentOrParents,
              _unsubscribe = this._unsubscribe,
              _subscriptions = this._subscriptions;
          this.closed = true;
          this._parentOrParents = null;
          this._subscriptions = null;

          if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
          } else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
              var parent = _parentOrParents[index];
              parent.remove(this);
            }
          }

          if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(_unsubscribe)) {
            try {
              _unsubscribe.call(this);
            } catch (e) {
              errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"] ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
          }

          if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(_subscriptions)) {
            var _index3 = -1;

            var len = _subscriptions.length;

            while (++_index3 < len) {
              var sub = _subscriptions[_index3];

              if (Object(_util_isObject__WEBPACK_IMPORTED_MODULE_1__["isObject"])(sub)) {
                try {
                  sub.unsubscribe();
                } catch (e) {
                  errors = errors || [];

                  if (e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"]) {
                    errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                  } else {
                    errors.push(e);
                  }
                }
              }
            }
          }

          if (errors) {
            throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"](errors);
          }
        }
      }, {
        key: "add",
        value: function add(teardown) {
          var subscription = teardown;

          if (!teardown) {
            return Subscription.EMPTY;
          }

          switch (typeof teardown) {
            case 'function':
              subscription = new Subscription(teardown);

            case 'object':
              if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                return subscription;
              } else if (this.closed) {
                subscription.unsubscribe();
                return subscription;
              } else if (!(subscription instanceof Subscription)) {
                var tmp = subscription;
                subscription = new Subscription();
                subscription._subscriptions = [tmp];
              }

              break;

            default:
              {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
              }
          }

          var _subscription = subscription,
              _parentOrParents = _subscription._parentOrParents;

          if (_parentOrParents === null) {
            subscription._parentOrParents = this;
          } else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
              return subscription;
            }

            subscription._parentOrParents = [_parentOrParents, this];
          } else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
          } else {
            return subscription;
          }

          var subscriptions = this._subscriptions;

          if (subscriptions === null) {
            this._subscriptions = [subscription];
          } else {
            subscriptions.push(subscription);
          }

          return subscription;
        }
      }, {
        key: "remove",
        value: function remove(subscription) {
          var subscriptions = this._subscriptions;

          if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);

            if (subscriptionIndex !== -1) {
              subscriptions.splice(subscriptionIndex, 1);
            }
          }
        }
      }]);

      return Subscription;
    }();

    Subscription.EMPTY = function (empty) {
      empty.closed = true;
      return empty;
    }(new Subscription());

    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"] ? err.errors : err);
      }, []);
    } //# sourceMappingURL=Subscription.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/config.js":
  /*!********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/config.js ***!
    \********************************************************************************************/

  /*! exports provided: config */

  /***/
  function node_modulesRxjs_esm2015InternalConfigJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "config", function () {
      return config;
    });

    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    var config = {
      Promise: undefined,

      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          var error = new Error();
          console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }

        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },

      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }

    }; //# sourceMappingURL=config.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js":
  /*!**********************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js ***!
    \**********************************************************************************************************************/

  /*! exports provided: ConnectableObservable, connectableObservableDescriptor */

  /***/
  function node_modulesRxjs_esm2015InternalObservableConnectableObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function () {
      return ConnectableObservable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "connectableObservableDescriptor", function () {
      return connectableObservableDescriptor;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _operators_refCount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../operators/refCount */
    "../../node_modules/rxjs/_esm2015/internal/operators/refCount.js");

    var ConnectableObservable = /*#__PURE__*/function (_Observable__WEBPACK_2) {
      _inherits(ConnectableObservable, _Observable__WEBPACK_2);

      var _super30 = _createSuper(ConnectableObservable);

      function ConnectableObservable(source, subjectFactory) {
        var _this119;

        _classCallCheck(this, ConnectableObservable);

        _this119 = _super30.call(this);
        _this119.source = source;
        _this119.subjectFactory = subjectFactory;
        _this119._refCount = 0;
        _this119._isComplete = false;
        return _this119;
      }

      _createClass(ConnectableObservable, [{
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          return this.getSubject().subscribe(subscriber);
        }
      }, {
        key: "getSubject",
        value: function getSubject() {
          var subject = this._subject;

          if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
          }

          return this._subject;
        }
      }, {
        key: "connect",
        value: function connect() {
          var connection = this._connection;

          if (!connection) {
            this._isComplete = false;
            connection = this._connection = new _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"]();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

            if (connection.closed) {
              this._connection = null;
              connection = _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
            }
          }

          return connection;
        }
      }, {
        key: "refCount",
        value: function refCount() {
          return Object(_operators_refCount__WEBPACK_IMPORTED_MODULE_4__["refCount"])()(this);
        }
      }]);

      return ConnectableObservable;
    }(_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]);

    var connectableObservableDescriptor = function () {
      var connectableProto = ConnectableObservable.prototype;
      return {
        operator: {
          value: null
        },
        _refCount: {
          value: 0,
          writable: true
        },
        _subject: {
          value: null,
          writable: true
        },
        _connection: {
          value: null,
          writable: true
        },
        _subscribe: {
          value: connectableProto._subscribe
        },
        _isComplete: {
          value: connectableProto._isComplete,
          writable: true
        },
        getSubject: {
          value: connectableProto.getSubject
        },
        connect: {
          value: connectableProto.connect
        },
        refCount: {
          value: connectableProto.refCount
        }
      };
    }();

    var ConnectableSubscriber = /*#__PURE__*/function (_Subject__WEBPACK_IMP4) {
      _inherits(ConnectableSubscriber, _Subject__WEBPACK_IMP4);

      var _super31 = _createSuper(ConnectableSubscriber);

      function ConnectableSubscriber(destination, connectable) {
        var _this120;

        _classCallCheck(this, ConnectableSubscriber);

        _this120 = _super31.call(this, destination);
        _this120.connectable = connectable;
        return _this120;
      }

      _createClass(ConnectableSubscriber, [{
        key: "_error",
        value: function _error(err) {
          this._unsubscribe();

          _get(_getPrototypeOf(ConnectableSubscriber.prototype), "_error", this).call(this, err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.connectable._isComplete = true;

          this._unsubscribe();

          _get(_getPrototypeOf(ConnectableSubscriber.prototype), "_complete", this).call(this);
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var connectable = this.connectable;

          if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;

            if (connection) {
              connection.unsubscribe();
            }
          }
        }
      }]);

      return ConnectableSubscriber;
    }(_Subject__WEBPACK_IMPORTED_MODULE_0__["SubjectSubscriber"]);

    var RefCountOperator = /*#__PURE__*/function () {
      function RefCountOperator(connectable) {
        _classCallCheck(this, RefCountOperator);

        this.connectable = connectable;
      }

      _createClass(RefCountOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          var connectable = this.connectable;
          connectable._refCount++;
          var refCounter = new RefCountSubscriber(subscriber, connectable);
          var subscription = source.subscribe(refCounter);

          if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
          }

          return subscription;
        }
      }]);

      return RefCountOperator;
    }();

    var RefCountSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_4) {
      _inherits(RefCountSubscriber, _Subscriber__WEBPACK_4);

      var _super32 = _createSuper(RefCountSubscriber);

      function RefCountSubscriber(destination, connectable) {
        var _this121;

        _classCallCheck(this, RefCountSubscriber);

        _this121 = _super32.call(this, destination);
        _this121.connectable = connectable;
        return _this121;
      }

      _createClass(RefCountSubscriber, [{
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var connectable = this.connectable;

          if (!connectable) {
            this.connection = null;
            return;
          }

          this.connectable = null;
          var refCount = connectable._refCount;

          if (refCount <= 0) {
            this.connection = null;
            return;
          }

          connectable._refCount = refCount - 1;

          if (refCount > 1) {
            this.connection = null;
            return;
          }

          var connection = this.connection;
          var sharedConnection = connectable._connection;
          this.connection = null;

          if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
          }
        }
      }]);

      return RefCountSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]); //# sourceMappingURL=ConnectableObservable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js":
  /*!**********************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js ***!
    \**********************************************************************************************************************/

  /*! exports provided: SubscribeOnObservable */

  /***/
  function node_modulesRxjs_esm2015InternalObservableSubscribeOnObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SubscribeOnObservable", function () {
      return SubscribeOnObservable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/asap */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/asap.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isNumeric */
    "../../node_modules/rxjs/_esm2015/internal/util/isNumeric.js");

    var SubscribeOnObservable = /*#__PURE__*/function (_Observable__WEBPACK_3) {
      _inherits(SubscribeOnObservable, _Observable__WEBPACK_3);

      var _super33 = _createSuper(SubscribeOnObservable);

      function SubscribeOnObservable(source) {
        var _this122;

        var delayTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var scheduler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__["asap"];

        _classCallCheck(this, SubscribeOnObservable);

        _this122 = _super33.call(this);
        _this122.source = source;
        _this122.delayTime = delayTime;
        _this122.scheduler = scheduler;

        if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(delayTime) || delayTime < 0) {
          _this122.delayTime = 0;
        }

        if (!scheduler || typeof scheduler.schedule !== 'function') {
          _this122.scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__["asap"];
        }

        return _this122;
      }

      _createClass(SubscribeOnObservable, [{
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          var delay = this.delayTime;
          var source = this.source;
          var scheduler = this.scheduler;
          return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source,
            subscriber: subscriber
          });
        }
      }], [{
        key: "create",
        value: function create(source) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var scheduler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__["asap"];
          return new SubscribeOnObservable(source, delay, scheduler);
        }
      }, {
        key: "dispatch",
        value: function dispatch(arg) {
          var source = arg.source,
              subscriber = arg.subscriber;
          return this.add(source.subscribe(subscriber));
        }
      }]);

      return SubscribeOnObservable;
    }(_Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]); //# sourceMappingURL=SubscribeOnObservable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/combineLatest.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/combineLatest.js ***!
    \**************************************************************************************************************/

  /*! exports provided: combineLatest, CombineLatestOperator, CombineLatestSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalObservableCombineLatestJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return combineLatest;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CombineLatestOperator", function () {
      return CombineLatestOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CombineLatestSubscriber", function () {
      return CombineLatestSubscriber;
    });
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./fromArray */
    "../../node_modules/rxjs/_esm2015/internal/observable/fromArray.js");

    var NONE = {};

    function combineLatest() {
      for (var _len4 = arguments.length, observables = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
        observables[_key5] = arguments[_key5];
      }

      var resultSelector = null;
      var scheduler = null;

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(observables[observables.length - 1])) {
        scheduler = observables.pop();
      }

      if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
      }

      if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(observables[0])) {
        observables = observables[0];
      }

      return Object(_fromArray__WEBPACK_IMPORTED_MODULE_4__["fromArray"])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
    }

    var CombineLatestOperator = /*#__PURE__*/function () {
      function CombineLatestOperator(resultSelector) {
        _classCallCheck(this, CombineLatestOperator);

        this.resultSelector = resultSelector;
      }

      _createClass(CombineLatestOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
        }
      }]);

      return CombineLatestOperator;
    }();

    var CombineLatestSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB) {
      _inherits(CombineLatestSubscriber, _OuterSubscriber__WEB);

      var _super34 = _createSuper(CombineLatestSubscriber);

      function CombineLatestSubscriber(destination, resultSelector) {
        var _this123;

        _classCallCheck(this, CombineLatestSubscriber);

        _this123 = _super34.call(this, destination);
        _this123.resultSelector = resultSelector;
        _this123.active = 0;
        _this123.values = [];
        _this123.observables = [];
        return _this123;
      }

      _createClass(CombineLatestSubscriber, [{
        key: "_next",
        value: function _next(observable) {
          this.values.push(NONE);
          this.observables.push(observable);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var observables = this.observables;
          var len = observables.length;

          if (len === 0) {
            this.destination.complete();
          } else {
            this.active = len;
            this.toRespond = len;

            for (var i = 0; i < len; i++) {
              var observable = observables[i];
              this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, observable, observable, i));
            }
          }
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(unused) {
          if ((this.active -= 1) === 0) {
            this.destination.complete();
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          var values = this.values;
          var oldVal = values[outerIndex];
          var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
          values[outerIndex] = innerValue;

          if (toRespond === 0) {
            if (this.resultSelector) {
              this._tryResultSelector(values);
            } else {
              this.destination.next(values.slice());
            }
          }
        }
      }, {
        key: "_tryResultSelector",
        value: function _tryResultSelector(values) {
          var result;

          try {
            result = this.resultSelector.apply(this, values);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.destination.next(result);
        }
      }]);

      return CombineLatestSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]); //# sourceMappingURL=combineLatest.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/concat.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/concat.js ***!
    \*******************************************************************************************************/

  /*! exports provided: concat */

  /***/
  function node_modulesRxjs_esm2015InternalObservableConcatJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return concat;
    });
    /* harmony import */


    var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./of */
    "../../node_modules/rxjs/_esm2015/internal/observable/of.js");
    /* harmony import */


    var _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../operators/concatAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/concatAll.js");

    function concat() {
      return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__["concatAll"])()(Object(_of__WEBPACK_IMPORTED_MODULE_0__["of"]).apply(void 0, arguments));
    } //# sourceMappingURL=concat.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/defer.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/defer.js ***!
    \******************************************************************************************************/

  /*! exports provided: defer */

  /***/
  function node_modulesRxjs_esm2015InternalObservableDeferJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defer", function () {
      return defer;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./from */
    "../../node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./empty */
    "../../node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function defer(observableFactory) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var input;

        try {
          input = observableFactory();
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        var source = input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        return source.subscribe(subscriber);
      });
    } //# sourceMappingURL=defer.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/empty.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/empty.js ***!
    \******************************************************************************************************/

  /*! exports provided: EMPTY, empty */

  /***/
  function node_modulesRxjs_esm2015InternalObservableEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EMPTY", function () {
      return EMPTY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "empty", function () {
      return empty;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");

    var EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
      return subscriber.complete();
    });

    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }

    function emptyScheduled(scheduler) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        return scheduler.schedule(function () {
          return subscriber.complete();
        });
      });
    } //# sourceMappingURL=empty.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/from.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/from.js ***!
    \*****************************************************************************************************/

  /*! exports provided: from */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "from", function () {
      return from;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeTo */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeTo.js");
    /* harmony import */


    var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../scheduled/scheduled */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduled.js");

    function from(input, scheduler) {
      if (!scheduler) {
        if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
          return input;
        }

        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(input));
      } else {
        return Object(_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_2__["scheduled"])(input, scheduler);
      }
    } //# sourceMappingURL=from.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/fromArray.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/fromArray.js ***!
    \**********************************************************************************************************/

  /*! exports provided: fromArray */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromArray", function () {
      return fromArray;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToArray */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js");
    /* harmony import */


    var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../scheduled/scheduleArray */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleArray.js");

    function fromArray(input, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__["subscribeToArray"])(input));
      } else {
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__["scheduleArray"])(input, scheduler);
      }
    } //# sourceMappingURL=fromArray.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/merge.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/merge.js ***!
    \******************************************************************************************************/

  /*! exports provided: merge */

  /***/
  function node_modulesRxjs_esm2015InternalObservableMergeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return merge;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../operators/mergeAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeAll.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./fromArray */
    "../../node_modules/rxjs/_esm2015/internal/observable/fromArray.js");

    function merge() {
      var concurrent = Number.POSITIVE_INFINITY;
      var scheduler = null;

      for (var _len5 = arguments.length, observables = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
        observables[_key6] = arguments[_key6];
      }

      var last = observables[observables.length - 1];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(last)) {
        scheduler = observables.pop();

        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
          concurrent = observables.pop();
        }
      } else if (typeof last === 'number') {
        concurrent = observables.pop();
      }

      if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
        return observables[0];
      }

      return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__["mergeAll"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__["fromArray"])(observables, scheduler));
    } //# sourceMappingURL=merge.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/of.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/of.js ***!
    \***************************************************************************************************/

  /*! exports provided: of */

  /***/
  function node_modulesRxjs_esm2015InternalObservableOfJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "of", function () {
      return of;
    });
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./fromArray */
    "../../node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../scheduled/scheduleArray */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleArray.js");

    function of() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var scheduler = args[args.length - 1];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(scheduler)) {
        args.pop();
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__["scheduleArray"])(args, scheduler);
      } else {
        return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(args);
      }
    } //# sourceMappingURL=of.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/race.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/race.js ***!
    \*****************************************************************************************************/

  /*! exports provided: race, RaceOperator, RaceSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalObservableRaceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return race;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RaceOperator", function () {
      return RaceOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RaceSubscriber", function () {
      return RaceSubscriber;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./fromArray */
    "../../node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function race() {
      for (var _len7 = arguments.length, observables = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
        observables[_key8] = arguments[_key8];
      }

      if (observables.length === 1) {
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
          observables = observables[0];
        } else {
          return observables[0];
        }
      }

      return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(observables, undefined).lift(new RaceOperator());
    }

    var RaceOperator = /*#__PURE__*/function () {
      function RaceOperator() {
        _classCallCheck(this, RaceOperator);
      }

      _createClass(RaceOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new RaceSubscriber(subscriber));
        }
      }]);

      return RaceOperator;
    }();

    var RaceSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB2) {
      _inherits(RaceSubscriber, _OuterSubscriber__WEB2);

      var _super35 = _createSuper(RaceSubscriber);

      function RaceSubscriber(destination) {
        var _this124;

        _classCallCheck(this, RaceSubscriber);

        _this124 = _super35.call(this, destination);
        _this124.hasFirst = false;
        _this124.observables = [];
        _this124.subscriptions = [];
        return _this124;
      }

      _createClass(RaceSubscriber, [{
        key: "_next",
        value: function _next(observable) {
          this.observables.push(observable);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var observables = this.observables;
          var len = observables.length;

          if (len === 0) {
            this.destination.complete();
          } else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
              var observable = observables[i];
              var subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, observable, observable, i);

              if (this.subscriptions) {
                this.subscriptions.push(subscription);
              }

              this.add(subscription);
            }

            this.observables = null;
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          if (!this.hasFirst) {
            this.hasFirst = true;

            for (var i = 0; i < this.subscriptions.length; i++) {
              if (i !== outerIndex) {
                var subscription = this.subscriptions[i];
                subscription.unsubscribe();
                this.remove(subscription);
              }
            }

            this.subscriptions = null;
          }

          this.destination.next(innerValue);
        }
      }]);

      return RaceSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]); //# sourceMappingURL=race.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/throwError.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/throwError.js ***!
    \***********************************************************************************************************/

  /*! exports provided: throwError */

  /***/
  function node_modulesRxjs_esm2015InternalObservableThrowErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throwError", function () {
      return throwError;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");

    function throwError(error, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
          return subscriber.error(error);
        });
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
          return scheduler.schedule(dispatch, 0, {
            error: error,
            subscriber: subscriber
          });
        });
      }
    }

    function dispatch(_ref4) {
      var error = _ref4.error,
          subscriber = _ref4.subscriber;
      subscriber.error(error);
    } //# sourceMappingURL=throwError.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/timer.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/timer.js ***!
    \******************************************************************************************************/

  /*! exports provided: timer */

  /***/
  function node_modulesRxjs_esm2015InternalObservableTimerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timer", function () {
      return timer;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isNumeric */
    "../../node_modules/rxjs/_esm2015/internal/util/isNumeric.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function timer() {
      var dueTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var periodOrScheduler = arguments.length > 1 ? arguments[1] : undefined;
      var scheduler = arguments.length > 2 ? arguments[2] : undefined;
      var period = -1;

      if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
      } else if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }

      if (!Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(dueTime) ? dueTime : +dueTime - scheduler.now();
        return scheduler.schedule(dispatch, due, {
          index: 0,
          period: period,
          subscriber: subscriber
        });
      });
    }

    function dispatch(state) {
      var index = state.index,
          period = state.period,
          subscriber = state.subscriber;
      subscriber.next(index);

      if (subscriber.closed) {
        return;
      } else if (period === -1) {
        return subscriber.complete();
      }

      state.index = index + 1;
      this.schedule(state, period);
    } //# sourceMappingURL=timer.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/observable/zip.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/observable/zip.js ***!
    \****************************************************************************************************/

  /*! exports provided: zip, ZipOperator, ZipSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalObservableZipJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return zip;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ZipOperator", function () {
      return ZipOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ZipSubscriber", function () {
      return ZipSubscriber;
    });
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./fromArray */
    "../../node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../../internal/symbol/iterator */
    "../../node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    function zip() {
      for (var _len8 = arguments.length, observables = new Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {
        observables[_key9] = arguments[_key9];
      }

      var resultSelector = observables[observables.length - 1];

      if (typeof resultSelector === 'function') {
        observables.pop();
      }

      return Object(_fromArray__WEBPACK_IMPORTED_MODULE_0__["fromArray"])(observables, undefined).lift(new ZipOperator(resultSelector));
    }

    var ZipOperator = /*#__PURE__*/function () {
      function ZipOperator(resultSelector) {
        _classCallCheck(this, ZipOperator);

        this.resultSelector = resultSelector;
      }

      _createClass(ZipOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
        }
      }]);

      return ZipOperator;
    }();

    var ZipSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_5) {
      _inherits(ZipSubscriber, _Subscriber__WEBPACK_5);

      var _super36 = _createSuper(ZipSubscriber);

      function ZipSubscriber(destination, resultSelector) {
        var _this125;

        var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Object.create(null);

        _classCallCheck(this, ZipSubscriber);

        _this125 = _super36.call(this, destination);
        _this125.iterators = [];
        _this125.active = 0;
        _this125.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
        _this125.values = values;
        return _this125;
      }

      _createClass(ZipSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var iterators = this.iterators;

          if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)) {
            iterators.push(new StaticArrayIterator(value));
          } else if (typeof value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"]] === 'function') {
            iterators.push(new StaticIterator(value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"]]()));
          } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var iterators = this.iterators;
          var len = iterators.length;
          this.unsubscribe();

          if (len === 0) {
            this.destination.complete();
            return;
          }

          this.active = len;

          for (var i = 0; i < len; i++) {
            var iterator = iterators[i];

            if (iterator.stillUnsubscribed) {
              var destination = this.destination;
              destination.add(iterator.subscribe(iterator, i));
            } else {
              this.active--;
            }
          }
        }
      }, {
        key: "notifyInactive",
        value: function notifyInactive() {
          this.active--;

          if (this.active === 0) {
            this.destination.complete();
          }
        }
      }, {
        key: "checkIterators",
        value: function checkIterators() {
          var iterators = this.iterators;
          var len = iterators.length;
          var destination = this.destination;

          for (var i = 0; i < len; i++) {
            var iterator = iterators[i];

            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
              return;
            }
          }

          var shouldComplete = false;
          var args = [];

          for (var _i9 = 0; _i9 < len; _i9++) {
            var _iterator13 = iterators[_i9];

            var result = _iterator13.next();

            if (_iterator13.hasCompleted()) {
              shouldComplete = true;
            }

            if (result.done) {
              destination.complete();
              return;
            }

            args.push(result.value);
          }

          if (this.resultSelector) {
            this._tryresultSelector(args);
          } else {
            destination.next(args);
          }

          if (shouldComplete) {
            destination.complete();
          }
        }
      }, {
        key: "_tryresultSelector",
        value: function _tryresultSelector(args) {
          var result;

          try {
            result = this.resultSelector.apply(this, args);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.destination.next(result);
        }
      }]);

      return ZipSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]);

    var StaticIterator = /*#__PURE__*/function () {
      function StaticIterator(iterator) {
        _classCallCheck(this, StaticIterator);

        this.iterator = iterator;
        this.nextResult = iterator.next();
      }

      _createClass(StaticIterator, [{
        key: "hasValue",
        value: function hasValue() {
          return true;
        }
      }, {
        key: "next",
        value: function next() {
          var result = this.nextResult;
          this.nextResult = this.iterator.next();
          return result;
        }
      }, {
        key: "hasCompleted",
        value: function hasCompleted() {
          var nextResult = this.nextResult;
          return nextResult && nextResult.done;
        }
      }]);

      return StaticIterator;
    }();

    var StaticArrayIterator = /*#__PURE__*/function () {
      function StaticArrayIterator(array) {
        _classCallCheck(this, StaticArrayIterator);

        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
      }

      _createClass(StaticArrayIterator, [{
        key: _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"],
        value: function value() {
          return this;
        }
      }, {
        key: "next",
        value: function next(value) {
          var i = this.index++;
          var array = this.array;
          return i < this.length ? {
            value: array[i],
            done: false
          } : {
            value: null,
            done: true
          };
        }
      }, {
        key: "hasValue",
        value: function hasValue() {
          return this.array.length > this.index;
        }
      }, {
        key: "hasCompleted",
        value: function hasCompleted() {
          return this.array.length === this.index;
        }
      }]);

      return StaticArrayIterator;
    }();

    var ZipBufferIterator = /*#__PURE__*/function (_OuterSubscriber__WEB3) {
      _inherits(ZipBufferIterator, _OuterSubscriber__WEB3);

      var _super37 = _createSuper(ZipBufferIterator);

      function ZipBufferIterator(destination, parent, observable) {
        var _this126;

        _classCallCheck(this, ZipBufferIterator);

        _this126 = _super37.call(this, destination);
        _this126.parent = parent;
        _this126.observable = observable;
        _this126.stillUnsubscribed = true;
        _this126.buffer = [];
        _this126.isComplete = false;
        return _this126;
      }

      _createClass(ZipBufferIterator, [{
        key: _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"],
        value: function value() {
          return this;
        }
      }, {
        key: "next",
        value: function next() {
          var buffer = this.buffer;

          if (buffer.length === 0 && this.isComplete) {
            return {
              value: null,
              done: true
            };
          } else {
            return {
              value: buffer.shift(),
              done: false
            };
          }
        }
      }, {
        key: "hasValue",
        value: function hasValue() {
          return this.buffer.length > 0;
        }
      }, {
        key: "hasCompleted",
        value: function hasCompleted() {
          return this.buffer.length === 0 && this.isComplete;
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {
          if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
          } else {
            this.destination.complete();
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.buffer.push(innerValue);
          this.parent.checkIterators();
        }
      }, {
        key: "subscribe",
        value: function subscribe(value, index) {
          return Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, this.observable, this, index);
        }
      }]);

      return ZipBufferIterator;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]); //# sourceMappingURL=zip.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/audit.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/audit.js ***!
    \*****************************************************************************************************/

  /*! exports provided: audit */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsAuditJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "audit", function () {
      return audit;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function audit(durationSelector) {
      return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
      };
    }

    var AuditOperator = /*#__PURE__*/function () {
      function AuditOperator(durationSelector) {
        _classCallCheck(this, AuditOperator);

        this.durationSelector = durationSelector;
      }

      _createClass(AuditOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
        }
      }]);

      return AuditOperator;
    }();

    var AuditSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB4) {
      _inherits(AuditSubscriber, _OuterSubscriber__WEB4);

      var _super38 = _createSuper(AuditSubscriber);

      function AuditSubscriber(destination, durationSelector) {
        var _this127;

        _classCallCheck(this, AuditSubscriber);

        _this127 = _super38.call(this, destination);
        _this127.durationSelector = durationSelector;
        _this127.hasValue = false;
        return _this127;
      }

      _createClass(AuditSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.value = value;
          this.hasValue = true;

          if (!this.throttled) {
            var duration;

            try {
              var durationSelector = this.durationSelector;
              duration = durationSelector(value);
            } catch (err) {
              return this.destination.error(err);
            }

            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, duration);

            if (!innerSubscription || innerSubscription.closed) {
              this.clearThrottle();
            } else {
              this.add(this.throttled = innerSubscription);
            }
          }
        }
      }, {
        key: "clearThrottle",
        value: function clearThrottle() {
          var value = this.value,
              hasValue = this.hasValue,
              throttled = this.throttled;

          if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
          }

          if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
          this.clearThrottle();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {
          this.clearThrottle();
        }
      }]);

      return AuditSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=audit.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/auditTime.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/auditTime.js ***!
    \*********************************************************************************************************/

  /*! exports provided: auditTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsAuditTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "auditTime", function () {
      return auditTime;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _audit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./audit */
    "../../node_modules/rxjs/_esm2015/internal/operators/audit.js");
    /* harmony import */


    var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/timer */
    "../../node_modules/rxjs/_esm2015/internal/observable/timer.js");

    function auditTime(duration) {
      var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
      return Object(_audit__WEBPACK_IMPORTED_MODULE_1__["audit"])(function () {
        return Object(_observable_timer__WEBPACK_IMPORTED_MODULE_2__["timer"])(duration, scheduler);
      });
    } //# sourceMappingURL=auditTime.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/buffer.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/buffer.js ***!
    \******************************************************************************************************/

  /*! exports provided: buffer */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buffer", function () {
      return buffer;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function buffer(closingNotifier) {
      return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
      };
    }

    var BufferOperator = /*#__PURE__*/function () {
      function BufferOperator(closingNotifier) {
        _classCallCheck(this, BufferOperator);

        this.closingNotifier = closingNotifier;
      }

      _createClass(BufferOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
        }
      }]);

      return BufferOperator;
    }();

    var BufferSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB5) {
      _inherits(BufferSubscriber, _OuterSubscriber__WEB5);

      var _super39 = _createSuper(BufferSubscriber);

      function BufferSubscriber(destination, closingNotifier) {
        var _this128;

        _classCallCheck(this, BufferSubscriber);

        _this128 = _super39.call(this, destination);
        _this128.buffer = [];

        _this128.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(_assertThisInitialized(_this128), closingNotifier));

        return _this128;
      }

      _createClass(BufferSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.buffer.push(value);
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          var buffer = this.buffer;
          this.buffer = [];
          this.destination.next(buffer);
        }
      }]);

      return BufferSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=buffer.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/bufferCount.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/bufferCount.js ***!
    \***********************************************************************************************************/

  /*! exports provided: bufferCount */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferCount", function () {
      return bufferCount;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function bufferCount(bufferSize) {
      var startBufferEvery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
      };
    }

    var BufferCountOperator = /*#__PURE__*/function () {
      function BufferCountOperator(bufferSize, startBufferEvery) {
        _classCallCheck(this, BufferCountOperator);

        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;

        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }

      _createClass(BufferCountOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
        }
      }]);

      return BufferCountOperator;
    }();

    var BufferCountSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_6) {
      _inherits(BufferCountSubscriber, _Subscriber__WEBPACK_6);

      var _super40 = _createSuper(BufferCountSubscriber);

      function BufferCountSubscriber(destination, bufferSize) {
        var _this129;

        _classCallCheck(this, BufferCountSubscriber);

        _this129 = _super40.call(this, destination);
        _this129.bufferSize = bufferSize;
        _this129.buffer = [];
        return _this129;
      }

      _createClass(BufferCountSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var buffer = this.buffer;
          buffer.push(value);

          if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var buffer = this.buffer;

          if (buffer.length > 0) {
            this.destination.next(buffer);
          }

          _get(_getPrototypeOf(BufferCountSubscriber.prototype), "_complete", this).call(this);
        }
      }]);

      return BufferCountSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    var BufferSkipCountSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_7) {
      _inherits(BufferSkipCountSubscriber, _Subscriber__WEBPACK_7);

      var _super41 = _createSuper(BufferSkipCountSubscriber);

      function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this130;

        _classCallCheck(this, BufferSkipCountSubscriber);

        _this130 = _super41.call(this, destination);
        _this130.bufferSize = bufferSize;
        _this130.startBufferEvery = startBufferEvery;
        _this130.buffers = [];
        _this130.count = 0;
        return _this130;
      }

      _createClass(BufferSkipCountSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var bufferSize = this.bufferSize,
              startBufferEvery = this.startBufferEvery,
              buffers = this.buffers,
              count = this.count;
          this.count++;

          if (count % startBufferEvery === 0) {
            buffers.push([]);
          }

          for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);

            if (buffer.length === bufferSize) {
              buffers.splice(i, 1);
              this.destination.next(buffer);
            }
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var buffers = this.buffers,
              destination = this.destination;

          while (buffers.length > 0) {
            var buffer = buffers.shift();

            if (buffer.length > 0) {
              destination.next(buffer);
            }
          }

          _get(_getPrototypeOf(BufferSkipCountSubscriber.prototype), "_complete", this).call(this);
        }
      }]);

      return BufferSkipCountSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=bufferCount.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/bufferTime.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/bufferTime.js ***!
    \**********************************************************************************************************/

  /*! exports provided: bufferTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferTime", function () {
      return bufferTime;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function bufferTime(bufferTimeSpan) {
      var length = arguments.length;
      var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__["isScheduler"])(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
      }

      var bufferCreationInterval = null;

      if (length >= 2) {
        bufferCreationInterval = arguments[1];
      }

      var maxBufferSize = Number.POSITIVE_INFINITY;

      if (length >= 3) {
        maxBufferSize = arguments[2];
      }

      return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
      };
    }

    var BufferTimeOperator = /*#__PURE__*/function () {
      function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _classCallCheck(this, BufferTimeOperator);

        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }

      _createClass(BufferTimeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
        }
      }]);

      return BufferTimeOperator;
    }();

    var Context = function Context() {
      _classCallCheck(this, Context);

      this.buffer = [];
    };

    var BufferTimeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_8) {
      _inherits(BufferTimeSubscriber, _Subscriber__WEBPACK_8);

      var _super42 = _createSuper(BufferTimeSubscriber);

      function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this131;

        _classCallCheck(this, BufferTimeSubscriber);

        _this131 = _super42.call(this, destination);
        _this131.bufferTimeSpan = bufferTimeSpan;
        _this131.bufferCreationInterval = bufferCreationInterval;
        _this131.maxBufferSize = maxBufferSize;
        _this131.scheduler = scheduler;
        _this131.contexts = [];

        var context = _this131.openContext();

        _this131.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

        if (_this131.timespanOnly) {
          var timeSpanOnlyState = {
            subscriber: _assertThisInitialized(_this131),
            context: context,
            bufferTimeSpan: bufferTimeSpan
          };

          _this131.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          var closeState = {
            subscriber: _assertThisInitialized(_this131),
            context: context
          };
          var creationState = {
            bufferTimeSpan: bufferTimeSpan,
            bufferCreationInterval: bufferCreationInterval,
            subscriber: _assertThisInitialized(_this131),
            scheduler: scheduler
          };

          _this131.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));

          _this131.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }

        return _this131;
      }

      _createClass(BufferTimeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var contexts = this.contexts;
          var len = contexts.length;
          var filledBufferContext;

          for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);

            if (buffer.length == this.maxBufferSize) {
              filledBufferContext = context;
            }
          }

          if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
          }
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.contexts.length = 0;

          _get(_getPrototypeOf(BufferTimeSubscriber.prototype), "_error", this).call(this, err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var contexts = this.contexts,
              destination = this.destination;

          while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
          }

          _get(_getPrototypeOf(BufferTimeSubscriber.prototype), "_complete", this).call(this);
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.contexts = null;
        }
      }, {
        key: "onBufferFull",
        value: function onBufferFull(context) {
          this.closeContext(context);
          var closeAction = context.closeAction;
          closeAction.unsubscribe();
          this.remove(closeAction);

          if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = {
              subscriber: this,
              context: context,
              bufferTimeSpan: bufferTimeSpan
            };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
          }
        }
      }, {
        key: "openContext",
        value: function openContext() {
          var context = new Context();
          this.contexts.push(context);
          return context;
        }
      }, {
        key: "closeContext",
        value: function closeContext(context) {
          this.destination.next(context.buffer);
          var contexts = this.contexts;
          var spliceIndex = contexts ? contexts.indexOf(context) : -1;

          if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
          }
        }
      }]);

      return BufferTimeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]);

    function dispatchBufferTimeSpanOnly(state) {
      var subscriber = state.subscriber;
      var prevContext = state.context;

      if (prevContext) {
        subscriber.closeContext(prevContext);
      }

      if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
      }
    }

    function dispatchBufferCreation(state) {
      var bufferCreationInterval = state.bufferCreationInterval,
          bufferTimeSpan = state.bufferTimeSpan,
          subscriber = state.subscriber,
          scheduler = state.scheduler;
      var context = subscriber.openContext();
      var action = this;

      if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
          subscriber: subscriber,
          context: context
        }));
        action.schedule(state, bufferCreationInterval);
      }
    }

    function dispatchBufferClose(arg) {
      var subscriber = arg.subscriber,
          context = arg.context;
      subscriber.closeContext(context);
    } //# sourceMappingURL=bufferTime.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js ***!
    \************************************************************************************************************/

  /*! exports provided: bufferToggle */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferToggleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferToggle", function () {
      return bufferToggle;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");

    function bufferToggle(openings, closingSelector) {
      return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
      };
    }

    var BufferToggleOperator = /*#__PURE__*/function () {
      function BufferToggleOperator(openings, closingSelector) {
        _classCallCheck(this, BufferToggleOperator);

        this.openings = openings;
        this.closingSelector = closingSelector;
      }

      _createClass(BufferToggleOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
        }
      }]);

      return BufferToggleOperator;
    }();

    var BufferToggleSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB6) {
      _inherits(BufferToggleSubscriber, _OuterSubscriber__WEB6);

      var _super43 = _createSuper(BufferToggleSubscriber);

      function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this132;

        _classCallCheck(this, BufferToggleSubscriber);

        _this132 = _super43.call(this, destination);
        _this132.openings = openings;
        _this132.closingSelector = closingSelector;
        _this132.contexts = [];

        _this132.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(_assertThisInitialized(_this132), openings));

        return _this132;
      }

      _createClass(BufferToggleSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var contexts = this.contexts;
          var len = contexts.length;

          for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
          }
        }
      }, {
        key: "_error",
        value: function _error(err) {
          var contexts = this.contexts;

          while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
          }

          this.contexts = null;

          _get(_getPrototypeOf(BufferToggleSubscriber.prototype), "_error", this).call(this, err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var contexts = this.contexts;

          while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
          }

          this.contexts = null;

          _get(_getPrototypeOf(BufferToggleSubscriber.prototype), "_complete", this).call(this);
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          this.closeBuffer(innerSub.context);
        }
      }, {
        key: "openBuffer",
        value: function openBuffer(value) {
          try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);

            if (closingNotifier) {
              this.trySubscribe(closingNotifier);
            }
          } catch (err) {
            this._error(err);
          }
        }
      }, {
        key: "closeBuffer",
        value: function closeBuffer(context) {
          var contexts = this.contexts;

          if (contexts && context) {
            var buffer = context.buffer,
                subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
          }
        }
      }, {
        key: "trySubscribe",
        value: function trySubscribe(closingNotifier) {
          var contexts = this.contexts;
          var buffer = [];
          var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"]();
          var context = {
            buffer: buffer,
            subscription: subscription
          };
          contexts.push(context);
          var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, closingNotifier, context);

          if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
          } else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
          }
        }
      }]);

      return BufferToggleSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]); //# sourceMappingURL=bufferToggle.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js ***!
    \**********************************************************************************************************/

  /*! exports provided: bufferWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferWhen", function () {
      return bufferWhen;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function bufferWhen(closingSelector) {
      return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
      };
    }

    var BufferWhenOperator = /*#__PURE__*/function () {
      function BufferWhenOperator(closingSelector) {
        _classCallCheck(this, BufferWhenOperator);

        this.closingSelector = closingSelector;
      }

      _createClass(BufferWhenOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
        }
      }]);

      return BufferWhenOperator;
    }();

    var BufferWhenSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB7) {
      _inherits(BufferWhenSubscriber, _OuterSubscriber__WEB7);

      var _super44 = _createSuper(BufferWhenSubscriber);

      function BufferWhenSubscriber(destination, closingSelector) {
        var _this133;

        _classCallCheck(this, BufferWhenSubscriber);

        _this133 = _super44.call(this, destination);
        _this133.closingSelector = closingSelector;
        _this133.subscribing = false;

        _this133.openBuffer();

        return _this133;
      }

      _createClass(BufferWhenSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.buffer.push(value);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var buffer = this.buffer;

          if (buffer) {
            this.destination.next(buffer);
          }

          _get(_getPrototypeOf(BufferWhenSubscriber.prototype), "_complete", this).call(this);
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.buffer = null;
          this.subscribing = false;
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.openBuffer();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {
          if (this.subscribing) {
            this.complete();
          } else {
            this.openBuffer();
          }
        }
      }, {
        key: "openBuffer",
        value: function openBuffer() {
          var closingSubscription = this.closingSubscription;

          if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
          }

          var buffer = this.buffer;

          if (this.buffer) {
            this.destination.next(buffer);
          }

          this.buffer = [];
          var closingNotifier;

          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
          } catch (err) {
            return this.error(err);
          }

          closingSubscription = new _Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"]();
          this.closingSubscription = closingSubscription;
          this.add(closingSubscription);
          this.subscribing = true;
          closingSubscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, closingNotifier));
          this.subscribing = false;
        }
      }]);

      return BufferWhenSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=bufferWhen.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/catchError.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/catchError.js ***!
    \**********************************************************************************************************/

  /*! exports provided: catchError */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCatchErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "catchError", function () {
      return catchError;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function catchError(selector) {
      return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return operator.caught = caught;
      };
    }

    var CatchOperator = /*#__PURE__*/function () {
      function CatchOperator(selector) {
        _classCallCheck(this, CatchOperator);

        this.selector = selector;
      }

      _createClass(CatchOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
        }
      }]);

      return CatchOperator;
    }();

    var CatchSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB8) {
      _inherits(CatchSubscriber, _OuterSubscriber__WEB8);

      var _super45 = _createSuper(CatchSubscriber);

      function CatchSubscriber(destination, selector, caught) {
        var _this134;

        _classCallCheck(this, CatchSubscriber);

        _this134 = _super45.call(this, destination);
        _this134.selector = selector;
        _this134.caught = caught;
        return _this134;
      }

      _createClass(CatchSubscriber, [{
        key: "error",
        value: function error(err) {
          if (!this.isStopped) {
            var result;

            try {
              result = this.selector(err, this.caught);
            } catch (err2) {
              _get(_getPrototypeOf(CatchSubscriber.prototype), "error", this).call(this, err2);

              return;
            }

            this._unsubscribeAndRecycle();

            var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, undefined, undefined);
            this.add(innerSubscriber);
            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, undefined, undefined, innerSubscriber);

            if (innerSubscription !== innerSubscriber) {
              this.add(innerSubscription);
            }
          }
        }
      }]);

      return CatchSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=catchError.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/combineAll.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/combineAll.js ***!
    \**********************************************************************************************************/

  /*! exports provided: combineAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCombineAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineAll", function () {
      return combineAll;
    });
    /* harmony import */


    var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/combineLatest */
    "../../node_modules/rxjs/_esm2015/internal/observable/combineLatest.js");

    function combineAll(project) {
      return function (source) {
        return source.lift(new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__["CombineLatestOperator"](project));
      };
    } //# sourceMappingURL=combineAll.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/combineLatest.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/combineLatest.js ***!
    \*************************************************************************************************************/

  /*! exports provided: combineLatest */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCombineLatestJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return combineLatest;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/combineLatest */
    "../../node_modules/rxjs/_esm2015/internal/observable/combineLatest.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/from */
    "../../node_modules/rxjs/_esm2015/internal/observable/from.js");

    var none = {};

    function combineLatest() {
      for (var _len9 = arguments.length, observables = new Array(_len9), _key10 = 0; _key10 < _len9; _key10++) {
        observables[_key10] = arguments[_key10];
      }

      var project = null;

      if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
      }

      if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
        observables = observables[0].slice();
      }

      return function (source) {
        return source.lift.call(Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__["from"])([source].concat(_toConsumableArray(observables))), new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__["CombineLatestOperator"](project));
      };
    } //# sourceMappingURL=combineLatest.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/concat.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/concat.js ***!
    \******************************************************************************************************/

  /*! exports provided: concat */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return concat;
    });
    /* harmony import */


    var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/concat */
    "../../node_modules/rxjs/_esm2015/internal/observable/concat.js");

    function concat() {
      for (var _len10 = arguments.length, observables = new Array(_len10), _key11 = 0; _key11 < _len10; _key11++) {
        observables[_key11] = arguments[_key11];
      }

      return function (source) {
        return source.lift.call(Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"]).apply(void 0, [source].concat(observables)));
      };
    } //# sourceMappingURL=concat.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/concatAll.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/concatAll.js ***!
    \*********************************************************************************************************/

  /*! exports provided: concatAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concatAll", function () {
      return concatAll;
    });
    /* harmony import */


    var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeAll.js");

    function concatAll() {
      return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__["mergeAll"])(1);
    } //# sourceMappingURL=concatAll.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/concatMap.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/concatMap.js ***!
    \*********************************************************************************************************/

  /*! exports provided: concatMap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concatMap", function () {
      return concatMap;
    });
    /* harmony import */


    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");

    function concatMap(project, resultSelector) {
      return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(project, resultSelector, 1);
    } //# sourceMappingURL=concatMap.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js ***!
    \***********************************************************************************************************/

  /*! exports provided: concatMapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concatMapTo", function () {
      return concatMapTo;
    });
    /* harmony import */


    var _concatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./concatMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/concatMap.js");

    function concatMapTo(innerObservable, resultSelector) {
      return Object(_concatMap__WEBPACK_IMPORTED_MODULE_0__["concatMap"])(function () {
        return innerObservable;
      }, resultSelector);
    } //# sourceMappingURL=concatMapTo.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/count.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/count.js ***!
    \*****************************************************************************************************/

  /*! exports provided: count */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "count", function () {
      return count;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function count(predicate) {
      return function (source) {
        return source.lift(new CountOperator(predicate, source));
      };
    }

    var CountOperator = /*#__PURE__*/function () {
      function CountOperator(predicate, source) {
        _classCallCheck(this, CountOperator);

        this.predicate = predicate;
        this.source = source;
      }

      _createClass(CountOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
        }
      }]);

      return CountOperator;
    }();

    var CountSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_9) {
      _inherits(CountSubscriber, _Subscriber__WEBPACK_9);

      var _super46 = _createSuper(CountSubscriber);

      function CountSubscriber(destination, predicate, source) {
        var _this135;

        _classCallCheck(this, CountSubscriber);

        _this135 = _super46.call(this, destination);
        _this135.predicate = predicate;
        _this135.source = source;
        _this135.count = 0;
        _this135.index = 0;
        return _this135;
      }

      _createClass(CountSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (this.predicate) {
            this._tryPredicate(value);
          } else {
            this.count++;
          }
        }
      }, {
        key: "_tryPredicate",
        value: function _tryPredicate(value) {
          var result;

          try {
            result = this.predicate(value, this.index++, this.source);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          if (result) {
            this.count++;
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.destination.next(this.count);
          this.destination.complete();
        }
      }]);

      return CountSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=count.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/debounce.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/debounce.js ***!
    \********************************************************************************************************/

  /*! exports provided: debounce */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDebounceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "debounce", function () {
      return debounce;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function debounce(durationSelector) {
      return function (source) {
        return source.lift(new DebounceOperator(durationSelector));
      };
    }

    var DebounceOperator = /*#__PURE__*/function () {
      function DebounceOperator(durationSelector) {
        _classCallCheck(this, DebounceOperator);

        this.durationSelector = durationSelector;
      }

      _createClass(DebounceOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
        }
      }]);

      return DebounceOperator;
    }();

    var DebounceSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB9) {
      _inherits(DebounceSubscriber, _OuterSubscriber__WEB9);

      var _super47 = _createSuper(DebounceSubscriber);

      function DebounceSubscriber(destination, durationSelector) {
        var _this136;

        _classCallCheck(this, DebounceSubscriber);

        _this136 = _super47.call(this, destination);
        _this136.durationSelector = durationSelector;
        _this136.hasValue = false;
        _this136.durationSubscription = null;
        return _this136;
      }

      _createClass(DebounceSubscriber, [{
        key: "_next",
        value: function _next(value) {
          try {
            var result = this.durationSelector.call(this, value);

            if (result) {
              this._tryNext(value, result);
            }
          } catch (err) {
            this.destination.error(err);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.emitValue();
          this.destination.complete();
        }
      }, {
        key: "_tryNext",
        value: function _tryNext(value, duration) {
          var subscription = this.durationSubscription;
          this.value = value;
          this.hasValue = true;

          if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
          }

          subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, duration);

          if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.emitValue();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {
          this.emitValue();
        }
      }, {
        key: "emitValue",
        value: function emitValue() {
          if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;

            if (subscription) {
              this.durationSubscription = null;
              subscription.unsubscribe();
              this.remove(subscription);
            }

            this.value = null;
            this.hasValue = false;

            _get(_getPrototypeOf(DebounceSubscriber.prototype), "_next", this).call(this, value);
          }
        }
      }]);

      return DebounceSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=debounce.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/debounceTime.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/debounceTime.js ***!
    \************************************************************************************************************/

  /*! exports provided: debounceTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDebounceTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "debounceTime", function () {
      return debounceTime;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");

    function debounceTime(dueTime) {
      var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      return function (source) {
        return source.lift(new DebounceTimeOperator(dueTime, scheduler));
      };
    }

    var DebounceTimeOperator = /*#__PURE__*/function () {
      function DebounceTimeOperator(dueTime, scheduler) {
        _classCallCheck(this, DebounceTimeOperator);

        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }

      _createClass(DebounceTimeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
        }
      }]);

      return DebounceTimeOperator;
    }();

    var DebounceTimeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_10) {
      _inherits(DebounceTimeSubscriber, _Subscriber__WEBPACK_10);

      var _super48 = _createSuper(DebounceTimeSubscriber);

      function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this137;

        _classCallCheck(this, DebounceTimeSubscriber);

        _this137 = _super48.call(this, destination);
        _this137.dueTime = dueTime;
        _this137.scheduler = scheduler;
        _this137.debouncedSubscription = null;
        _this137.lastValue = null;
        _this137.hasValue = false;
        return _this137;
      }

      _createClass(DebounceTimeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.clearDebounce();
          this.lastValue = value;
          this.hasValue = true;
          this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.debouncedNext();
          this.destination.complete();
        }
      }, {
        key: "debouncedNext",
        value: function debouncedNext() {
          this.clearDebounce();

          if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
          }
        }
      }, {
        key: "clearDebounce",
        value: function clearDebounce() {
          var debouncedSubscription = this.debouncedSubscription;

          if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
          }
        }
      }]);

      return DebounceTimeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    function dispatchNext(subscriber) {
      subscriber.debouncedNext();
    } //# sourceMappingURL=debounceTime.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js ***!
    \**************************************************************************************************************/

  /*! exports provided: defaultIfEmpty */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDefaultIfEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function () {
      return defaultIfEmpty;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function defaultIfEmpty() {
      var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return function (source) {
        return source.lift(new DefaultIfEmptyOperator(defaultValue));
      };
    }

    var DefaultIfEmptyOperator = /*#__PURE__*/function () {
      function DefaultIfEmptyOperator(defaultValue) {
        _classCallCheck(this, DefaultIfEmptyOperator);

        this.defaultValue = defaultValue;
      }

      _createClass(DefaultIfEmptyOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
        }
      }]);

      return DefaultIfEmptyOperator;
    }();

    var DefaultIfEmptySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_11) {
      _inherits(DefaultIfEmptySubscriber, _Subscriber__WEBPACK_11);

      var _super49 = _createSuper(DefaultIfEmptySubscriber);

      function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this138;

        _classCallCheck(this, DefaultIfEmptySubscriber);

        _this138 = _super49.call(this, destination);
        _this138.defaultValue = defaultValue;
        _this138.isEmpty = true;
        return _this138;
      }

      _createClass(DefaultIfEmptySubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.isEmpty = false;
          this.destination.next(value);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          if (this.isEmpty) {
            this.destination.next(this.defaultValue);
          }

          this.destination.complete();
        }
      }]);

      return DefaultIfEmptySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=defaultIfEmpty.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/delay.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/delay.js ***!
    \*****************************************************************************************************/

  /*! exports provided: delay */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDelayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "delay", function () {
      return delay;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isDate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isDate */
    "../../node_modules/rxjs/_esm2015/internal/util/isDate.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Notification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../Notification */
    "../../node_modules/rxjs/_esm2015/internal/Notification.js");

    function delay(delay) {
      var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
      var absoluteDelay = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_1__["isDate"])(delay);
      var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
      return function (source) {
        return source.lift(new DelayOperator(delayFor, scheduler));
      };
    }

    var DelayOperator = /*#__PURE__*/function () {
      function DelayOperator(delay, scheduler) {
        _classCallCheck(this, DelayOperator);

        this.delay = delay;
        this.scheduler = scheduler;
      }

      _createClass(DelayOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
        }
      }]);

      return DelayOperator;
    }();

    var DelaySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_12) {
      _inherits(DelaySubscriber, _Subscriber__WEBPACK_12);

      var _super50 = _createSuper(DelaySubscriber);

      function DelaySubscriber(destination, delay, scheduler) {
        var _this139;

        _classCallCheck(this, DelaySubscriber);

        _this139 = _super50.call(this, destination);
        _this139.delay = delay;
        _this139.scheduler = scheduler;
        _this139.queue = [];
        _this139.active = false;
        _this139.errored = false;
        return _this139;
      }

      _createClass(DelaySubscriber, [{
        key: "_schedule",
        value: function _schedule(scheduler) {
          this.active = true;
          var destination = this.destination;
          destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this,
            destination: this.destination,
            scheduler: scheduler
          }));
        }
      }, {
        key: "scheduleNotification",
        value: function scheduleNotification(notification) {
          if (this.errored === true) {
            return;
          }

          var scheduler = this.scheduler;
          var message = new DelayMessage(scheduler.now() + this.delay, notification);
          this.queue.push(message);

          if (this.active === false) {
            this._schedule(scheduler);
          }
        }
      }, {
        key: "_next",
        value: function _next(value) {
          this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__["Notification"].createNext(value));
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.errored = true;
          this.queue = [];
          this.destination.error(err);
          this.unsubscribe();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__["Notification"].createComplete());
          this.unsubscribe();
        }
      }], [{
        key: "dispatch",
        value: function dispatch(state) {
          var source = state.source;
          var queue = source.queue;
          var scheduler = state.scheduler;
          var destination = state.destination;

          while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
          }

          if (queue.length > 0) {
            var _delay2 = Math.max(0, queue[0].time - scheduler.now());

            this.schedule(state, _delay2);
          } else {
            this.unsubscribe();
            source.active = false;
          }
        }
      }]);

      return DelaySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]);

    var DelayMessage = function DelayMessage(time, notification) {
      _classCallCheck(this, DelayMessage);

      this.time = time;
      this.notification = notification;
    }; //# sourceMappingURL=delay.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/delayWhen.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/delayWhen.js ***!
    \*********************************************************************************************************/

  /*! exports provided: delayWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDelayWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "delayWhen", function () {
      return delayWhen;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function (source) {
          return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
        };
      }

      return function (source) {
        return source.lift(new DelayWhenOperator(delayDurationSelector));
      };
    }

    var DelayWhenOperator = /*#__PURE__*/function () {
      function DelayWhenOperator(delayDurationSelector) {
        _classCallCheck(this, DelayWhenOperator);

        this.delayDurationSelector = delayDurationSelector;
      }

      _createClass(DelayWhenOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
        }
      }]);

      return DelayWhenOperator;
    }();

    var DelayWhenSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB10) {
      _inherits(DelayWhenSubscriber, _OuterSubscriber__WEB10);

      var _super51 = _createSuper(DelayWhenSubscriber);

      function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this140;

        _classCallCheck(this, DelayWhenSubscriber);

        _this140 = _super51.call(this, destination);
        _this140.delayDurationSelector = delayDurationSelector;
        _this140.completed = false;
        _this140.delayNotifierSubscriptions = [];
        _this140.index = 0;
        return _this140;
      }

      _createClass(DelayWhenSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(outerValue);
          this.removeSubscription(innerSub);
          this.tryComplete();
        }
      }, {
        key: "notifyError",
        value: function notifyError(error, innerSub) {
          this._error(error);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          var value = this.removeSubscription(innerSub);

          if (value) {
            this.destination.next(value);
          }

          this.tryComplete();
        }
      }, {
        key: "_next",
        value: function _next(value) {
          var index = this.index++;

          try {
            var delayNotifier = this.delayDurationSelector(value, index);

            if (delayNotifier) {
              this.tryDelay(delayNotifier, value);
            }
          } catch (err) {
            this.destination.error(err);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.completed = true;
          this.tryComplete();
          this.unsubscribe();
        }
      }, {
        key: "removeSubscription",
        value: function removeSubscription(subscription) {
          subscription.unsubscribe();
          var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);

          if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
          }

          return subscription.outerValue;
        }
      }, {
        key: "tryDelay",
        value: function tryDelay(delayNotifier, value) {
          var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, delayNotifier, value);

          if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
          }
        }
      }, {
        key: "tryComplete",
        value: function tryComplete() {
          if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
          }
        }
      }]);

      return DelayWhenSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]);

    var SubscriptionDelayObservable = /*#__PURE__*/function (_Observable__WEBPACK_4) {
      _inherits(SubscriptionDelayObservable, _Observable__WEBPACK_4);

      var _super52 = _createSuper(SubscriptionDelayObservable);

      function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this141;

        _classCallCheck(this, SubscriptionDelayObservable);

        _this141 = _super52.call(this);
        _this141.source = source;
        _this141.subscriptionDelay = subscriptionDelay;
        return _this141;
      }

      _createClass(SubscriptionDelayObservable, [{
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
        }
      }]);

      return SubscriptionDelayObservable;
    }(_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]);

    var SubscriptionDelaySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_13) {
      _inherits(SubscriptionDelaySubscriber, _Subscriber__WEBPACK_13);

      var _super53 = _createSuper(SubscriptionDelaySubscriber);

      function SubscriptionDelaySubscriber(parent, source) {
        var _this142;

        _classCallCheck(this, SubscriptionDelaySubscriber);

        _this142 = _super53.call(this);
        _this142.parent = parent;
        _this142.source = source;
        _this142.sourceSubscribed = false;
        return _this142;
      }

      _createClass(SubscriptionDelaySubscriber, [{
        key: "_next",
        value: function _next(unused) {
          this.subscribeToSource();
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.unsubscribe();
          this.parent.error(err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.unsubscribe();
          this.subscribeToSource();
        }
      }, {
        key: "subscribeToSource",
        value: function subscribeToSource() {
          if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
          }
        }
      }]);

      return SubscriptionDelaySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=delayWhen.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/dematerialize.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/dematerialize.js ***!
    \*************************************************************************************************************/

  /*! exports provided: dematerialize */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDematerializeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "dematerialize", function () {
      return dematerialize;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function dematerialize() {
      return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
      };
    }

    var DeMaterializeOperator = /*#__PURE__*/function () {
      function DeMaterializeOperator() {
        _classCallCheck(this, DeMaterializeOperator);
      }

      _createClass(DeMaterializeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DeMaterializeSubscriber(subscriber));
        }
      }]);

      return DeMaterializeOperator;
    }();

    var DeMaterializeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_14) {
      _inherits(DeMaterializeSubscriber, _Subscriber__WEBPACK_14);

      var _super54 = _createSuper(DeMaterializeSubscriber);

      function DeMaterializeSubscriber(destination) {
        _classCallCheck(this, DeMaterializeSubscriber);

        return _super54.call(this, destination);
      }

      _createClass(DeMaterializeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          value.observe(this.destination);
        }
      }]);

      return DeMaterializeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=dematerialize.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/distinct.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/distinct.js ***!
    \********************************************************************************************************/

  /*! exports provided: distinct, DistinctSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDistinctJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distinct", function () {
      return distinct;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DistinctSubscriber", function () {
      return DistinctSubscriber;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function distinct(keySelector, flushes) {
      return function (source) {
        return source.lift(new DistinctOperator(keySelector, flushes));
      };
    }

    var DistinctOperator = /*#__PURE__*/function () {
      function DistinctOperator(keySelector, flushes) {
        _classCallCheck(this, DistinctOperator);

        this.keySelector = keySelector;
        this.flushes = flushes;
      }

      _createClass(DistinctOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
        }
      }]);

      return DistinctOperator;
    }();

    var DistinctSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB11) {
      _inherits(DistinctSubscriber, _OuterSubscriber__WEB11);

      var _super55 = _createSuper(DistinctSubscriber);

      function DistinctSubscriber(destination, keySelector, flushes) {
        var _this143;

        _classCallCheck(this, DistinctSubscriber);

        _this143 = _super55.call(this, destination);
        _this143.keySelector = keySelector;
        _this143.values = new Set();

        if (flushes) {
          _this143.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(_assertThisInitialized(_this143), flushes));
        }

        return _this143;
      }

      _createClass(DistinctSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.values.clear();
        }
      }, {
        key: "notifyError",
        value: function notifyError(error, innerSub) {
          this._error(error);
        }
      }, {
        key: "_next",
        value: function _next(value) {
          if (this.keySelector) {
            this._useKeySelector(value);
          } else {
            this._finalizeNext(value, value);
          }
        }
      }, {
        key: "_useKeySelector",
        value: function _useKeySelector(value) {
          var key;
          var destination = this.destination;

          try {
            key = this.keySelector(value);
          } catch (err) {
            destination.error(err);
            return;
          }

          this._finalizeNext(key, value);
        }
      }, {
        key: "_finalizeNext",
        value: function _finalizeNext(key, value) {
          var values = this.values;

          if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
          }
        }
      }]);

      return DistinctSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=distinct.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js":
  /*!********************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js ***!
    \********************************************************************************************************************/

  /*! exports provided: distinctUntilChanged */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDistinctUntilChangedJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function () {
      return distinctUntilChanged;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function distinctUntilChanged(compare, keySelector) {
      return function (source) {
        return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
      };
    }

    var DistinctUntilChangedOperator = /*#__PURE__*/function () {
      function DistinctUntilChangedOperator(compare, keySelector) {
        _classCallCheck(this, DistinctUntilChangedOperator);

        this.compare = compare;
        this.keySelector = keySelector;
      }

      _createClass(DistinctUntilChangedOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
        }
      }]);

      return DistinctUntilChangedOperator;
    }();

    var DistinctUntilChangedSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_15) {
      _inherits(DistinctUntilChangedSubscriber, _Subscriber__WEBPACK_15);

      var _super56 = _createSuper(DistinctUntilChangedSubscriber);

      function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this144;

        _classCallCheck(this, DistinctUntilChangedSubscriber);

        _this144 = _super56.call(this, destination);
        _this144.keySelector = keySelector;
        _this144.hasKey = false;

        if (typeof compare === 'function') {
          _this144.compare = compare;
        }

        return _this144;
      }

      _createClass(DistinctUntilChangedSubscriber, [{
        key: "compare",
        value: function compare(x, y) {
          return x === y;
        }
      }, {
        key: "_next",
        value: function _next(value) {
          var key;

          try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
          } catch (err) {
            return this.destination.error(err);
          }

          var result = false;

          if (this.hasKey) {
            try {
              var compare = this.compare;
              result = compare(this.key, key);
            } catch (err) {
              return this.destination.error(err);
            }
          } else {
            this.hasKey = true;
          }

          if (!result) {
            this.key = key;
            this.destination.next(value);
          }
        }
      }]);

      return DistinctUntilChangedSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=distinctUntilChanged.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js":
  /*!***********************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js ***!
    \***********************************************************************************************************************/

  /*! exports provided: distinctUntilKeyChanged */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDistinctUntilKeyChangedJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function () {
      return distinctUntilKeyChanged;
    });
    /* harmony import */


    var _distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./distinctUntilChanged */
    "../../node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js");

    function distinctUntilKeyChanged(key, compare) {
      return Object(_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__["distinctUntilChanged"])(function (x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    } //# sourceMappingURL=distinctUntilKeyChanged.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/elementAt.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/elementAt.js ***!
    \*********************************************************************************************************/

  /*! exports provided: elementAt */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsElementAtJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "elementAt", function () {
      return elementAt;
    });
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "../../node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "../../node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony import */


    var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./throwIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _take__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./take */
    "../../node_modules/rxjs/_esm2015/internal/operators/take.js");

    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"]();
      }

      var hasDefaultValue = arguments.length >= 2;
      return function (source) {
        return source.pipe(Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) {
          return i === index;
        }), Object(_take__WEBPACK_IMPORTED_MODULE_4__["take"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__["throwIfEmpty"])(function () {
          return new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"]();
        }));
      };
    } //# sourceMappingURL=elementAt.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/endWith.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/endWith.js ***!
    \*******************************************************************************************************/

  /*! exports provided: endWith */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsEndWithJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "endWith", function () {
      return endWith;
    });
    /* harmony import */


    var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/concat */
    "../../node_modules/rxjs/_esm2015/internal/observable/concat.js");
    /* harmony import */


    var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/of */
    "../../node_modules/rxjs/_esm2015/internal/observable/of.js");

    function endWith() {
      for (var _len11 = arguments.length, array = new Array(_len11), _key12 = 0; _key12 < _len11; _key12++) {
        array[_key12] = arguments[_key12];
      }

      return function (source) {
        return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(source, Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__["of"]).apply(void 0, array));
      };
    } //# sourceMappingURL=endWith.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/every.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/every.js ***!
    \*****************************************************************************************************/

  /*! exports provided: every */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsEveryJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "every", function () {
      return every;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function every(predicate, thisArg) {
      return function (source) {
        return source.lift(new EveryOperator(predicate, thisArg, source));
      };
    }

    var EveryOperator = /*#__PURE__*/function () {
      function EveryOperator(predicate, thisArg, source) {
        _classCallCheck(this, EveryOperator);

        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }

      _createClass(EveryOperator, [{
        key: "call",
        value: function call(observer, source) {
          return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
        }
      }]);

      return EveryOperator;
    }();

    var EverySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_16) {
      _inherits(EverySubscriber, _Subscriber__WEBPACK_16);

      var _super57 = _createSuper(EverySubscriber);

      function EverySubscriber(destination, predicate, thisArg, source) {
        var _this145;

        _classCallCheck(this, EverySubscriber);

        _this145 = _super57.call(this, destination);
        _this145.predicate = predicate;
        _this145.thisArg = thisArg;
        _this145.source = source;
        _this145.index = 0;
        _this145.thisArg = thisArg || _assertThisInitialized(_this145);
        return _this145;
      }

      _createClass(EverySubscriber, [{
        key: "notifyComplete",
        value: function notifyComplete(everyValueMatch) {
          this.destination.next(everyValueMatch);
          this.destination.complete();
        }
      }, {
        key: "_next",
        value: function _next(value) {
          var result = false;

          try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          if (!result) {
            this.notifyComplete(false);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.notifyComplete(true);
        }
      }]);

      return EverySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=every.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/exhaust.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/exhaust.js ***!
    \*******************************************************************************************************/

  /*! exports provided: exhaust */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsExhaustJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "exhaust", function () {
      return exhaust;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function exhaust() {
      return function (source) {
        return source.lift(new SwitchFirstOperator());
      };
    }

    var SwitchFirstOperator = /*#__PURE__*/function () {
      function SwitchFirstOperator() {
        _classCallCheck(this, SwitchFirstOperator);
      }

      _createClass(SwitchFirstOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SwitchFirstSubscriber(subscriber));
        }
      }]);

      return SwitchFirstOperator;
    }();

    var SwitchFirstSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB12) {
      _inherits(SwitchFirstSubscriber, _OuterSubscriber__WEB12);

      var _super58 = _createSuper(SwitchFirstSubscriber);

      function SwitchFirstSubscriber(destination) {
        var _this146;

        _classCallCheck(this, SwitchFirstSubscriber);

        _this146 = _super58.call(this, destination);
        _this146.hasCompleted = false;
        _this146.hasSubscription = false;
        return _this146;
      }

      _createClass(SwitchFirstSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, value));
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.hasCompleted = true;

          if (!this.hasSubscription) {
            this.destination.complete();
          }
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          this.remove(innerSub);
          this.hasSubscription = false;

          if (this.hasCompleted) {
            this.destination.complete();
          }
        }
      }]);

      return SwitchFirstSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=exhaust.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js ***!
    \**********************************************************************************************************/

  /*! exports provided: exhaustMap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsExhaustMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "exhaustMap", function () {
      return exhaustMap;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../observable/from */
    "../../node_modules/rxjs/_esm2015/internal/observable/from.js");

    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function (source) {
          return source.pipe(exhaustMap(function (a, i) {
            return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }

      return function (source) {
        return source.lift(new ExhaustMapOperator(project));
      };
    }

    var ExhaustMapOperator = /*#__PURE__*/function () {
      function ExhaustMapOperator(project) {
        _classCallCheck(this, ExhaustMapOperator);

        this.project = project;
      }

      _createClass(ExhaustMapOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
        }
      }]);

      return ExhaustMapOperator;
    }();

    var ExhaustMapSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB13) {
      _inherits(ExhaustMapSubscriber, _OuterSubscriber__WEB13);

      var _super59 = _createSuper(ExhaustMapSubscriber);

      function ExhaustMapSubscriber(destination, project) {
        var _this147;

        _classCallCheck(this, ExhaustMapSubscriber);

        _this147 = _super59.call(this, destination);
        _this147.project = project;
        _this147.hasSubscription = false;
        _this147.hasCompleted = false;
        _this147.index = 0;
        return _this147;
      }

      _createClass(ExhaustMapSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (!this.hasSubscription) {
            this.tryNext(value);
          }
        }
      }, {
        key: "tryNext",
        value: function tryNext(value) {
          var result;
          var index = this.index++;

          try {
            result = this.project(value, index);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.hasSubscription = true;

          this._innerSub(result, value, index);
        }
      }, {
        key: "_innerSub",
        value: function _innerSub(result, value, index) {
          var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, value, index);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, undefined, undefined, innerSubscriber);

          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.hasCompleted = true;

          if (!this.hasSubscription) {
            this.destination.complete();
          }

          this.unsubscribe();
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
      }, {
        key: "notifyError",
        value: function notifyError(err) {
          this.destination.error(err);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          var destination = this.destination;
          destination.remove(innerSub);
          this.hasSubscription = false;

          if (this.hasCompleted) {
            this.destination.complete();
          }
        }
      }]);

      return ExhaustMapSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=exhaustMap.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/expand.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/expand.js ***!
    \******************************************************************************************************/

  /*! exports provided: expand, ExpandOperator, ExpandSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsExpandJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "expand", function () {
      return expand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpandOperator", function () {
      return ExpandOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpandSubscriber", function () {
      return ExpandSubscriber;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function expand(project) {
      var concurrent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;
      var scheduler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
      return function (source) {
        return source.lift(new ExpandOperator(project, concurrent, scheduler));
      };
    }

    var ExpandOperator = /*#__PURE__*/function () {
      function ExpandOperator(project, concurrent, scheduler) {
        _classCallCheck(this, ExpandOperator);

        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }

      _createClass(ExpandOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
        }
      }]);

      return ExpandOperator;
    }();

    var ExpandSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB14) {
      _inherits(ExpandSubscriber, _OuterSubscriber__WEB14);

      var _super60 = _createSuper(ExpandSubscriber);

      function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this148;

        _classCallCheck(this, ExpandSubscriber);

        _this148 = _super60.call(this, destination);
        _this148.project = project;
        _this148.concurrent = concurrent;
        _this148.scheduler = scheduler;
        _this148.index = 0;
        _this148.active = 0;
        _this148.hasCompleted = false;

        if (concurrent < Number.POSITIVE_INFINITY) {
          _this148.buffer = [];
        }

        return _this148;
      }

      _createClass(ExpandSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var destination = this.destination;

          if (destination.closed) {
            this._complete();

            return;
          }

          var index = this.index++;

          if (this.active < this.concurrent) {
            destination.next(value);

            try {
              var project = this.project;
              var result = project(value, index);

              if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
              } else {
                var state = {
                  subscriber: this,
                  result: result,
                  value: value,
                  index: index
                };
                var _destination = this.destination;

                _destination.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
              }
            } catch (e) {
              destination.error(e);
            }
          } else {
            this.buffer.push(value);
          }
        }
      }, {
        key: "subscribeToProjection",
        value: function subscribeToProjection(result, value, index) {
          this.active++;
          var destination = this.destination;
          destination.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, result, value, index));
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.hasCompleted = true;

          if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
          }

          this.unsubscribe();
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this._next(innerValue);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          var buffer = this.buffer;
          var destination = this.destination;
          destination.remove(innerSub);
          this.active--;

          if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
          }

          if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
          }
        }
      }], [{
        key: "dispatch",
        value: function dispatch(arg) {
          var subscriber = arg.subscriber,
              result = arg.result,
              value = arg.value,
              index = arg.index;
          subscriber.subscribeToProjection(result, value, index);
        }
      }]);

      return ExpandSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=expand.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/filter.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/filter.js ***!
    \******************************************************************************************************/

  /*! exports provided: filter */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFilterJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "filter", function () {
      return filter;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function filter(predicate, thisArg) {
      return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
      };
    }

    var FilterOperator = /*#__PURE__*/function () {
      function FilterOperator(predicate, thisArg) {
        _classCallCheck(this, FilterOperator);

        this.predicate = predicate;
        this.thisArg = thisArg;
      }

      _createClass(FilterOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
        }
      }]);

      return FilterOperator;
    }();

    var FilterSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_17) {
      _inherits(FilterSubscriber, _Subscriber__WEBPACK_17);

      var _super61 = _createSuper(FilterSubscriber);

      function FilterSubscriber(destination, predicate, thisArg) {
        var _this149;

        _classCallCheck(this, FilterSubscriber);

        _this149 = _super61.call(this, destination);
        _this149.predicate = predicate;
        _this149.thisArg = thisArg;
        _this149.count = 0;
        return _this149;
      }

      _createClass(FilterSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var result;

          try {
            result = this.predicate.call(this.thisArg, value, this.count++);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          if (result) {
            this.destination.next(value);
          }
        }
      }]);

      return FilterSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=filter.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/finalize.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/finalize.js ***!
    \********************************************************************************************************/

  /*! exports provided: finalize */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFinalizeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "finalize", function () {
      return finalize;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");

    function finalize(callback) {
      return function (source) {
        return source.lift(new FinallyOperator(callback));
      };
    }

    var FinallyOperator = /*#__PURE__*/function () {
      function FinallyOperator(callback) {
        _classCallCheck(this, FinallyOperator);

        this.callback = callback;
      }

      _createClass(FinallyOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new FinallySubscriber(subscriber, this.callback));
        }
      }]);

      return FinallyOperator;
    }();

    var FinallySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_18) {
      _inherits(FinallySubscriber, _Subscriber__WEBPACK_18);

      var _super62 = _createSuper(FinallySubscriber);

      function FinallySubscriber(destination, callback) {
        var _this150;

        _classCallCheck(this, FinallySubscriber);

        _this150 = _super62.call(this, destination);

        _this150.add(new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"](callback));

        return _this150;
      }

      return FinallySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=finalize.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/find.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/find.js ***!
    \****************************************************************************************************/

  /*! exports provided: find, FindValueOperator, FindValueSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFindJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "find", function () {
      return find;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FindValueOperator", function () {
      return FindValueOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FindValueSubscriber", function () {
      return FindValueSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function find(predicate, thisArg) {
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
      }

      return function (source) {
        return source.lift(new FindValueOperator(predicate, source, false, thisArg));
      };
    }

    var FindValueOperator = /*#__PURE__*/function () {
      function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        _classCallCheck(this, FindValueOperator);

        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }

      _createClass(FindValueOperator, [{
        key: "call",
        value: function call(observer, source) {
          return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
        }
      }]);

      return FindValueOperator;
    }();

    var FindValueSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_19) {
      _inherits(FindValueSubscriber, _Subscriber__WEBPACK_19);

      var _super63 = _createSuper(FindValueSubscriber);

      function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this151;

        _classCallCheck(this, FindValueSubscriber);

        _this151 = _super63.call(this, destination);
        _this151.predicate = predicate;
        _this151.source = source;
        _this151.yieldIndex = yieldIndex;
        _this151.thisArg = thisArg;
        _this151.index = 0;
        return _this151;
      }

      _createClass(FindValueSubscriber, [{
        key: "notifyComplete",
        value: function notifyComplete(value) {
          var destination = this.destination;
          destination.next(value);
          destination.complete();
          this.unsubscribe();
        }
      }, {
        key: "_next",
        value: function _next(value) {
          var predicate = this.predicate,
              thisArg = this.thisArg;
          var index = this.index++;

          try {
            var result = predicate.call(thisArg || this, value, index, this.source);

            if (result) {
              this.notifyComplete(this.yieldIndex ? index : value);
            }
          } catch (err) {
            this.destination.error(err);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.notifyComplete(this.yieldIndex ? -1 : undefined);
        }
      }]);

      return FindValueSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=find.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/findIndex.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/findIndex.js ***!
    \*********************************************************************************************************/

  /*! exports provided: findIndex */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFindIndexJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "findIndex", function () {
      return findIndex;
    });
    /* harmony import */


    var _operators_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../operators/find */
    "../../node_modules/rxjs/_esm2015/internal/operators/find.js");

    function findIndex(predicate, thisArg) {
      return function (source) {
        return source.lift(new _operators_find__WEBPACK_IMPORTED_MODULE_0__["FindValueOperator"](predicate, source, true, thisArg));
      };
    } //# sourceMappingURL=findIndex.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/first.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/first.js ***!
    \*****************************************************************************************************/

  /*! exports provided: first */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFirstJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "first", function () {
      return first;
    });
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/EmptyError */
    "../../node_modules/rxjs/_esm2015/internal/util/EmptyError.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "../../node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony import */


    var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./take */
    "../../node_modules/rxjs/_esm2015/internal/operators/take.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./throwIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/identity */
    "../../node_modules/rxjs/_esm2015/internal/util/identity.js");

    function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function (source) {
        return source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) {
          return predicate(v, i, source);
        }) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_take__WEBPACK_IMPORTED_MODULE_2__["take"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__["throwIfEmpty"])(function () {
          return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"]();
        }));
      };
    } //# sourceMappingURL=first.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/groupBy.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/groupBy.js ***!
    \*******************************************************************************************************/

  /*! exports provided: groupBy, GroupedObservable */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsGroupByJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "groupBy", function () {
      return groupBy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GroupedObservable", function () {
      return GroupedObservable;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");

    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
      return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
      };
    }

    var GroupByOperator = /*#__PURE__*/function () {
      function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        _classCallCheck(this, GroupByOperator);

        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }

      _createClass(GroupByOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
        }
      }]);

      return GroupByOperator;
    }();

    var GroupBySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_20) {
      _inherits(GroupBySubscriber, _Subscriber__WEBPACK_20);

      var _super64 = _createSuper(GroupBySubscriber);

      function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this152;

        _classCallCheck(this, GroupBySubscriber);

        _this152 = _super64.call(this, destination);
        _this152.keySelector = keySelector;
        _this152.elementSelector = elementSelector;
        _this152.durationSelector = durationSelector;
        _this152.subjectSelector = subjectSelector;
        _this152.groups = null;
        _this152.attemptedToUnsubscribe = false;
        _this152.count = 0;
        return _this152;
      }

      _createClass(GroupBySubscriber, [{
        key: "_next",
        value: function _next(value) {
          var key;

          try {
            key = this.keySelector(value);
          } catch (err) {
            this.error(err);
            return;
          }

          this._group(value, key);
        }
      }, {
        key: "_group",
        value: function _group(value, key) {
          var groups = this.groups;

          if (!groups) {
            groups = this.groups = new Map();
          }

          var group = groups.get(key);
          var element;

          if (this.elementSelector) {
            try {
              element = this.elementSelector(value);
            } catch (err) {
              this.error(err);
            }
          } else {
            element = value;
          }

          if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new _Subject__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);

            if (this.durationSelector) {
              var duration;

              try {
                duration = this.durationSelector(new GroupedObservable(key, group));
              } catch (err) {
                this.error(err);
                return;
              }

              this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
          }

          if (!group.closed) {
            group.next(element);
          }
        }
      }, {
        key: "_error",
        value: function _error(err) {
          var groups = this.groups;

          if (groups) {
            groups.forEach(function (group, key) {
              group.error(err);
            });
            groups.clear();
          }

          this.destination.error(err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var groups = this.groups;

          if (groups) {
            groups.forEach(function (group, key) {
              group.complete();
            });
            groups.clear();
          }

          this.destination.complete();
        }
      }, {
        key: "removeGroup",
        value: function removeGroup(key) {
          this.groups["delete"](key);
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe() {
          if (!this.closed) {
            this.attemptedToUnsubscribe = true;

            if (this.count === 0) {
              _get(_getPrototypeOf(GroupBySubscriber.prototype), "unsubscribe", this).call(this);
            }
          }
        }
      }]);

      return GroupBySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    var GroupDurationSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_21) {
      _inherits(GroupDurationSubscriber, _Subscriber__WEBPACK_21);

      var _super65 = _createSuper(GroupDurationSubscriber);

      function GroupDurationSubscriber(key, group, parent) {
        var _this153;

        _classCallCheck(this, GroupDurationSubscriber);

        _this153 = _super65.call(this, group);
        _this153.key = key;
        _this153.group = group;
        _this153.parent = parent;
        return _this153;
      }

      _createClass(GroupDurationSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.complete();
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var parent = this.parent,
              key = this.key;
          this.key = this.parent = null;

          if (parent) {
            parent.removeGroup(key);
          }
        }
      }]);

      return GroupDurationSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    var GroupedObservable = /*#__PURE__*/function (_Observable__WEBPACK_5) {
      _inherits(GroupedObservable, _Observable__WEBPACK_5);

      var _super66 = _createSuper(GroupedObservable);

      function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this154;

        _classCallCheck(this, GroupedObservable);

        _this154 = _super66.call(this);
        _this154.key = key;
        _this154.groupSubject = groupSubject;
        _this154.refCountSubscription = refCountSubscription;
        return _this154;
      }

      _createClass(GroupedObservable, [{
        key: "_subscribe",
        value: function _subscribe(subscriber) {
          var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          var refCountSubscription = this.refCountSubscription,
              groupSubject = this.groupSubject;

          if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
          }

          subscription.add(groupSubject.subscribe(subscriber));
          return subscription;
        }
      }]);

      return GroupedObservable;
    }(_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]);

    var InnerRefCountSubscription = /*#__PURE__*/function (_Subscription__WEBPAC3) {
      _inherits(InnerRefCountSubscription, _Subscription__WEBPAC3);

      var _super67 = _createSuper(InnerRefCountSubscription);

      function InnerRefCountSubscription(parent) {
        var _this155;

        _classCallCheck(this, InnerRefCountSubscription);

        _this155 = _super67.call(this);
        _this155.parent = parent;
        parent.count++;
        return _this155;
      }

      _createClass(InnerRefCountSubscription, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          var parent = this.parent;

          if (!parent.closed && !this.closed) {
            _get(_getPrototypeOf(InnerRefCountSubscription.prototype), "unsubscribe", this).call(this);

            parent.count -= 1;

            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
              parent.unsubscribe();
            }
          }
        }
      }]);

      return InnerRefCountSubscription;
    }(_Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]); //# sourceMappingURL=groupBy.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js ***!
    \**************************************************************************************************************/

  /*! exports provided: ignoreElements */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsIgnoreElementsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ignoreElements", function () {
      return ignoreElements;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function ignoreElements() {
      return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
      };
    }

    var IgnoreElementsOperator = /*#__PURE__*/function () {
      function IgnoreElementsOperator() {
        _classCallCheck(this, IgnoreElementsOperator);
      }

      _createClass(IgnoreElementsOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new IgnoreElementsSubscriber(subscriber));
        }
      }]);

      return IgnoreElementsOperator;
    }();

    var IgnoreElementsSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_22) {
      _inherits(IgnoreElementsSubscriber, _Subscriber__WEBPACK_22);

      var _super68 = _createSuper(IgnoreElementsSubscriber);

      function IgnoreElementsSubscriber() {
        _classCallCheck(this, IgnoreElementsSubscriber);

        return _super68.apply(this, arguments);
      }

      _createClass(IgnoreElementsSubscriber, [{
        key: "_next",
        value: function _next(unused) {}
      }]);

      return IgnoreElementsSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=ignoreElements.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/isEmpty.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/isEmpty.js ***!
    \*******************************************************************************************************/

  /*! exports provided: isEmpty */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsIsEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isEmpty", function () {
      return isEmpty;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function isEmpty() {
      return function (source) {
        return source.lift(new IsEmptyOperator());
      };
    }

    var IsEmptyOperator = /*#__PURE__*/function () {
      function IsEmptyOperator() {
        _classCallCheck(this, IsEmptyOperator);
      }

      _createClass(IsEmptyOperator, [{
        key: "call",
        value: function call(observer, source) {
          return source.subscribe(new IsEmptySubscriber(observer));
        }
      }]);

      return IsEmptyOperator;
    }();

    var IsEmptySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_23) {
      _inherits(IsEmptySubscriber, _Subscriber__WEBPACK_23);

      var _super69 = _createSuper(IsEmptySubscriber);

      function IsEmptySubscriber(destination) {
        _classCallCheck(this, IsEmptySubscriber);

        return _super69.call(this, destination);
      }

      _createClass(IsEmptySubscriber, [{
        key: "notifyComplete",
        value: function notifyComplete(isEmpty) {
          var destination = this.destination;
          destination.next(isEmpty);
          destination.complete();
        }
      }, {
        key: "_next",
        value: function _next(value) {
          this.notifyComplete(false);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.notifyComplete(true);
        }
      }]);

      return IsEmptySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=isEmpty.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/last.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/last.js ***!
    \****************************************************************************************************/

  /*! exports provided: last */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "last", function () {
      return last;
    });
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/EmptyError */
    "../../node_modules/rxjs/_esm2015/internal/util/EmptyError.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "../../node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony import */


    var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./takeLast */
    "../../node_modules/rxjs/_esm2015/internal/operators/takeLast.js");
    /* harmony import */


    var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./throwIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/identity */
    "../../node_modules/rxjs/_esm2015/internal/util/identity.js");

    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function (source) {
        return source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) {
          return predicate(v, i, source);
        }) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_takeLast__WEBPACK_IMPORTED_MODULE_2__["takeLast"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__["throwIfEmpty"])(function () {
          return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"]();
        }));
      };
    } //# sourceMappingURL=last.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/map.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/map.js ***!
    \***************************************************************************************************/

  /*! exports provided: map, MapOperator */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "map", function () {
      return map;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MapOperator", function () {
      return MapOperator;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function map(project, thisArg) {
      return function mapOperation(source) {
        if (typeof project !== 'function') {
          throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }

        return source.lift(new MapOperator(project, thisArg));
      };
    }

    var MapOperator = /*#__PURE__*/function () {
      function MapOperator(project, thisArg) {
        _classCallCheck(this, MapOperator);

        this.project = project;
        this.thisArg = thisArg;
      }

      _createClass(MapOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        }
      }]);

      return MapOperator;
    }();

    var MapSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_24) {
      _inherits(MapSubscriber, _Subscriber__WEBPACK_24);

      var _super70 = _createSuper(MapSubscriber);

      function MapSubscriber(destination, project, thisArg) {
        var _this156;

        _classCallCheck(this, MapSubscriber);

        _this156 = _super70.call(this, destination);
        _this156.project = project;
        _this156.count = 0;
        _this156.thisArg = thisArg || _assertThisInitialized(_this156);
        return _this156;
      }

      _createClass(MapSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var result;

          try {
            result = this.project.call(this.thisArg, value, this.count++);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.destination.next(result);
        }
      }]);

      return MapSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=map.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/mapTo.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/mapTo.js ***!
    \*****************************************************************************************************/

  /*! exports provided: mapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mapTo", function () {
      return mapTo;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function mapTo(value) {
      return function (source) {
        return source.lift(new MapToOperator(value));
      };
    }

    var MapToOperator = /*#__PURE__*/function () {
      function MapToOperator(value) {
        _classCallCheck(this, MapToOperator);

        this.value = value;
      }

      _createClass(MapToOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new MapToSubscriber(subscriber, this.value));
        }
      }]);

      return MapToOperator;
    }();

    var MapToSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_25) {
      _inherits(MapToSubscriber, _Subscriber__WEBPACK_25);

      var _super71 = _createSuper(MapToSubscriber);

      function MapToSubscriber(destination, value) {
        var _this157;

        _classCallCheck(this, MapToSubscriber);

        _this157 = _super71.call(this, destination);
        _this157.value = value;
        return _this157;
      }

      _createClass(MapToSubscriber, [{
        key: "_next",
        value: function _next(x) {
          this.destination.next(this.value);
        }
      }]);

      return MapToSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=mapTo.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/materialize.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/materialize.js ***!
    \***********************************************************************************************************/

  /*! exports provided: materialize */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMaterializeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "materialize", function () {
      return materialize;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Notification */
    "../../node_modules/rxjs/_esm2015/internal/Notification.js");

    function materialize() {
      return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
      };
    }

    var MaterializeOperator = /*#__PURE__*/function () {
      function MaterializeOperator() {
        _classCallCheck(this, MaterializeOperator);
      }

      _createClass(MaterializeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new MaterializeSubscriber(subscriber));
        }
      }]);

      return MaterializeOperator;
    }();

    var MaterializeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_26) {
      _inherits(MaterializeSubscriber, _Subscriber__WEBPACK_26);

      var _super72 = _createSuper(MaterializeSubscriber);

      function MaterializeSubscriber(destination) {
        _classCallCheck(this, MaterializeSubscriber);

        return _super72.call(this, destination);
      }

      _createClass(MaterializeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createNext(value));
        }
      }, {
        key: "_error",
        value: function _error(err) {
          var destination = this.destination;
          destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createError(err));
          destination.complete();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var destination = this.destination;
          destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createComplete());
          destination.complete();
        }
      }]);

      return MaterializeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=materialize.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/max.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/max.js ***!
    \***************************************************************************************************/

  /*! exports provided: max */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMaxJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "max", function () {
      return max;
    });
    /* harmony import */


    var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./reduce */
    "../../node_modules/rxjs/_esm2015/internal/operators/reduce.js");

    function max(comparer) {
      var max = typeof comparer === 'function' ? function (x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function (x, y) {
        return x > y ? x : y;
      };
      return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(max);
    } //# sourceMappingURL=max.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/merge.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/merge.js ***!
    \*****************************************************************************************************/

  /*! exports provided: merge */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return merge;
    });
    /* harmony import */


    var _observable_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/merge */
    "../../node_modules/rxjs/_esm2015/internal/observable/merge.js");

    function merge() {
      for (var _len12 = arguments.length, observables = new Array(_len12), _key13 = 0; _key13 < _len12; _key13++) {
        observables[_key13] = arguments[_key13];
      }

      return function (source) {
        return source.lift.call(Object(_observable_merge__WEBPACK_IMPORTED_MODULE_0__["merge"]).apply(void 0, [source].concat(observables)));
      };
    } //# sourceMappingURL=merge.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/mergeAll.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/mergeAll.js ***!
    \********************************************************************************************************/

  /*! exports provided: mergeAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeAll", function () {
      return mergeAll;
    });
    /* harmony import */


    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/identity */
    "../../node_modules/rxjs/_esm2015/internal/util/identity.js");

    function mergeAll() {
      var concurrent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
      return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"], concurrent);
    } //# sourceMappingURL=mergeAll.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/mergeMap.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/mergeMap.js ***!
    \********************************************************************************************************/

  /*! exports provided: mergeMap, MergeMapOperator, MergeMapSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeMap", function () {
      return mergeMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeMapOperator", function () {
      return MergeMapOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeMapSubscriber", function () {
      return MergeMapSubscriber;
    });
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../observable/from */
    "../../node_modules/rxjs/_esm2015/internal/observable/from.js");

    function mergeMap(project, resultSelector) {
      var concurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;

      if (typeof resultSelector === 'function') {
        return function (source) {
          return source.pipe(mergeMap(function (a, i) {
            return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }, concurrent));
        };
      } else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
      }

      return function (source) {
        return source.lift(new MergeMapOperator(project, concurrent));
      };
    }

    var MergeMapOperator = /*#__PURE__*/function () {
      function MergeMapOperator(project) {
        var concurrent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;

        _classCallCheck(this, MergeMapOperator);

        this.project = project;
        this.concurrent = concurrent;
      }

      _createClass(MergeMapOperator, [{
        key: "call",
        value: function call(observer, source) {
          return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
        }
      }]);

      return MergeMapOperator;
    }();

    var MergeMapSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB15) {
      _inherits(MergeMapSubscriber, _OuterSubscriber__WEB15);

      var _super73 = _createSuper(MergeMapSubscriber);

      function MergeMapSubscriber(destination, project) {
        var _this158;

        var concurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;

        _classCallCheck(this, MergeMapSubscriber);

        _this158 = _super73.call(this, destination);
        _this158.project = project;
        _this158.concurrent = concurrent;
        _this158.hasCompleted = false;
        _this158.buffer = [];
        _this158.active = 0;
        _this158.index = 0;
        return _this158;
      }

      _createClass(MergeMapSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (this.active < this.concurrent) {
            this._tryNext(value);
          } else {
            this.buffer.push(value);
          }
        }
      }, {
        key: "_tryNext",
        value: function _tryNext(value) {
          var result;
          var index = this.index++;

          try {
            result = this.project(value, index);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.active++;

          this._innerSub(result, value, index);
        }
      }, {
        key: "_innerSub",
        value: function _innerSub(ish, value, index) {
          var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, value, index);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__["subscribeToResult"])(this, ish, undefined, undefined, innerSubscriber);

          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.hasCompleted = true;

          if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
          }

          this.unsubscribe();
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          var buffer = this.buffer;
          this.remove(innerSub);
          this.active--;

          if (buffer.length > 0) {
            this._next(buffer.shift());
          } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
          }
        }
      }]);

      return MergeMapSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=mergeMap.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js ***!
    \**********************************************************************************************************/

  /*! exports provided: mergeMapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeMapTo", function () {
      return mergeMapTo;
    });
    /* harmony import */


    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");

    function mergeMapTo(innerObservable, resultSelector) {
      var concurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;

      if (typeof resultSelector === 'function') {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(function () {
          return innerObservable;
        }, resultSelector, concurrent);
      }

      if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
      }

      return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(function () {
        return innerObservable;
      }, concurrent);
    } //# sourceMappingURL=mergeMapTo.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/mergeScan.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/mergeScan.js ***!
    \*********************************************************************************************************/

  /*! exports provided: mergeScan, MergeScanOperator, MergeScanSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeScanJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeScan", function () {
      return mergeScan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeScanOperator", function () {
      return MergeScanOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeScanSubscriber", function () {
      return MergeScanSubscriber;
    });
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");

    function mergeScan(accumulator, seed) {
      var concurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;
      return function (source) {
        return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
      };
    }

    var MergeScanOperator = /*#__PURE__*/function () {
      function MergeScanOperator(accumulator, seed, concurrent) {
        _classCallCheck(this, MergeScanOperator);

        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }

      _createClass(MergeScanOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
        }
      }]);

      return MergeScanOperator;
    }();

    var MergeScanSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB16) {
      _inherits(MergeScanSubscriber, _OuterSubscriber__WEB16);

      var _super74 = _createSuper(MergeScanSubscriber);

      function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this159;

        _classCallCheck(this, MergeScanSubscriber);

        _this159 = _super74.call(this, destination);
        _this159.accumulator = accumulator;
        _this159.acc = acc;
        _this159.concurrent = concurrent;
        _this159.hasValue = false;
        _this159.hasCompleted = false;
        _this159.buffer = [];
        _this159.active = 0;
        _this159.index = 0;
        return _this159;
      }

      _createClass(MergeScanSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish;

            try {
              var accumulator = this.accumulator;
              ish = accumulator(this.acc, value, index);
            } catch (e) {
              return destination.error(e);
            }

            this.active++;

            this._innerSub(ish, value, index);
          } else {
            this.buffer.push(value);
          }
        }
      }, {
        key: "_innerSub",
        value: function _innerSub(ish, value, index) {
          var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, value, index);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__["subscribeToResult"])(this, ish, undefined, undefined, innerSubscriber);

          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.hasCompleted = true;

          if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
              this.destination.next(this.acc);
            }

            this.destination.complete();
          }

          this.unsubscribe();
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          var destination = this.destination;
          this.acc = innerValue;
          this.hasValue = true;
          destination.next(innerValue);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          var buffer = this.buffer;
          var destination = this.destination;
          destination.remove(innerSub);
          this.active--;

          if (buffer.length > 0) {
            this._next(buffer.shift());
          } else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
              this.destination.next(this.acc);
            }

            this.destination.complete();
          }
        }
      }]);

      return MergeScanSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=mergeScan.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/min.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/min.js ***!
    \***************************************************************************************************/

  /*! exports provided: min */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMinJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "min", function () {
      return min;
    });
    /* harmony import */


    var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./reduce */
    "../../node_modules/rxjs/_esm2015/internal/operators/reduce.js");

    function min(comparer) {
      var min = typeof comparer === 'function' ? function (x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function (x, y) {
        return x < y ? x : y;
      };
      return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(min);
    } //# sourceMappingURL=min.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/multicast.js ***!
    \*********************************************************************************************************/

  /*! exports provided: multicast, MulticastOperator */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMulticastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "multicast", function () {
      return multicast;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MulticastOperator", function () {
      return MulticastOperator;
    });
    /* harmony import */


    var _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/ConnectableObservable */
    "../../node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js");

    function multicast(subjectOrSubjectFactory, selector) {
      return function multicastOperatorFunction(source) {
        var subjectFactory;

        if (typeof subjectOrSubjectFactory === 'function') {
          subjectFactory = subjectOrSubjectFactory;
        } else {
          subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
          };
        }

        if (typeof selector === 'function') {
          return source.lift(new MulticastOperator(subjectFactory, selector));
        }

        var connectable = Object.create(source, _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__["connectableObservableDescriptor"]);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
      };
    }

    var MulticastOperator = /*#__PURE__*/function () {
      function MulticastOperator(subjectFactory, selector) {
        _classCallCheck(this, MulticastOperator);

        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }

      _createClass(MulticastOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          var selector = this.selector;
          var subject = this.subjectFactory();
          var subscription = selector(subject).subscribe(subscriber);
          subscription.add(source.subscribe(subject));
          return subscription;
        }
      }]);

      return MulticastOperator;
    }(); //# sourceMappingURL=multicast.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/observeOn.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/observeOn.js ***!
    \*********************************************************************************************************/

  /*! exports provided: observeOn, ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsObserveOnJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "observeOn", function () {
      return observeOn;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObserveOnOperator", function () {
      return ObserveOnOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObserveOnSubscriber", function () {
      return ObserveOnSubscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObserveOnMessage", function () {
      return ObserveOnMessage;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Notification */
    "../../node_modules/rxjs/_esm2015/internal/Notification.js");

    function observeOn(scheduler) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
      };
    }

    var ObserveOnOperator = /*#__PURE__*/function () {
      function ObserveOnOperator(scheduler) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, ObserveOnOperator);

        this.scheduler = scheduler;
        this.delay = delay;
      }

      _createClass(ObserveOnOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
        }
      }]);

      return ObserveOnOperator;
    }();

    var ObserveOnSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_27) {
      _inherits(ObserveOnSubscriber, _Subscriber__WEBPACK_27);

      var _super75 = _createSuper(ObserveOnSubscriber);

      function ObserveOnSubscriber(destination, scheduler) {
        var _this160;

        var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        _classCallCheck(this, ObserveOnSubscriber);

        _this160 = _super75.call(this, destination);
        _this160.scheduler = scheduler;
        _this160.delay = delay;
        return _this160;
      }

      _createClass(ObserveOnSubscriber, [{
        key: "scheduleMessage",
        value: function scheduleMessage(notification) {
          var destination = this.destination;
          destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
        }
      }, {
        key: "_next",
        value: function _next(value) {
          this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createNext(value));
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createError(err));
          this.unsubscribe();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createComplete());
          this.unsubscribe();
        }
      }], [{
        key: "dispatch",
        value: function dispatch(arg) {
          var notification = arg.notification,
              destination = arg.destination;
          notification.observe(destination);
          this.unsubscribe();
        }
      }]);

      return ObserveOnSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    var ObserveOnMessage = function ObserveOnMessage(notification, destination) {
      _classCallCheck(this, ObserveOnMessage);

      this.notification = notification;
      this.destination = destination;
    }; //# sourceMappingURL=observeOn.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js":
  /*!*****************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js ***!
    \*****************************************************************************************************************/

  /*! exports provided: onErrorResumeNext, onErrorResumeNextStatic */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsOnErrorResumeNextJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function () {
      return onErrorResumeNext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNextStatic", function () {
      return onErrorResumeNextStatic;
    });
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/from */
    "../../node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function onErrorResumeNext() {
      for (var _len13 = arguments.length, nextSources = new Array(_len13), _key14 = 0; _key14 < _len13; _key14++) {
        nextSources[_key14] = arguments[_key14];
      }

      if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
      }

      return function (source) {
        return source.lift(new OnErrorResumeNextOperator(nextSources));
      };
    }

    function onErrorResumeNextStatic() {
      for (var _len14 = arguments.length, nextSources = new Array(_len14), _key15 = 0; _key15 < _len14; _key15++) {
        nextSources[_key15] = arguments[_key15];
      }

      var source = null;

      if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
      }

      source = nextSources.shift();
      return Object(_observable_from__WEBPACK_IMPORTED_MODULE_0__["from"])(source, null).lift(new OnErrorResumeNextOperator(nextSources));
    }

    var OnErrorResumeNextOperator = /*#__PURE__*/function () {
      function OnErrorResumeNextOperator(nextSources) {
        _classCallCheck(this, OnErrorResumeNextOperator);

        this.nextSources = nextSources;
      }

      _createClass(OnErrorResumeNextOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
        }
      }]);

      return OnErrorResumeNextOperator;
    }();

    var OnErrorResumeNextSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB17) {
      _inherits(OnErrorResumeNextSubscriber, _OuterSubscriber__WEB17);

      var _super76 = _createSuper(OnErrorResumeNextSubscriber);

      function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this161;

        _classCallCheck(this, OnErrorResumeNextSubscriber);

        _this161 = _super76.call(this, destination);
        _this161.destination = destination;
        _this161.nextSources = nextSources;
        return _this161;
      }

      _createClass(OnErrorResumeNextSubscriber, [{
        key: "notifyError",
        value: function notifyError(error, innerSub) {
          this.subscribeToNextSource();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          this.subscribeToNextSource();
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.subscribeToNextSource();
          this.unsubscribe();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.subscribeToNextSource();
          this.unsubscribe();
        }
      }, {
        key: "subscribeToNextSource",
        value: function subscribeToNextSource() {
          var next = this.nextSources.shift();

          if (!!next) {
            var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__["InnerSubscriber"](this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, next, undefined, undefined, innerSubscriber);

            if (innerSubscription !== innerSubscriber) {
              destination.add(innerSubscription);
            }
          } else {
            this.destination.complete();
          }
        }
      }]);

      return OnErrorResumeNextSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]); //# sourceMappingURL=onErrorResumeNext.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/pairwise.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/pairwise.js ***!
    \********************************************************************************************************/

  /*! exports provided: pairwise */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPairwiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pairwise", function () {
      return pairwise;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function pairwise() {
      return function (source) {
        return source.lift(new PairwiseOperator());
      };
    }

    var PairwiseOperator = /*#__PURE__*/function () {
      function PairwiseOperator() {
        _classCallCheck(this, PairwiseOperator);
      }

      _createClass(PairwiseOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new PairwiseSubscriber(subscriber));
        }
      }]);

      return PairwiseOperator;
    }();

    var PairwiseSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_28) {
      _inherits(PairwiseSubscriber, _Subscriber__WEBPACK_28);

      var _super77 = _createSuper(PairwiseSubscriber);

      function PairwiseSubscriber(destination) {
        var _this162;

        _classCallCheck(this, PairwiseSubscriber);

        _this162 = _super77.call(this, destination);
        _this162.hasPrev = false;
        return _this162;
      }

      _createClass(PairwiseSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var pair;

          if (this.hasPrev) {
            pair = [this.prev, value];
          } else {
            this.hasPrev = true;
          }

          this.prev = value;

          if (pair) {
            this.destination.next(pair);
          }
        }
      }]);

      return PairwiseSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=pairwise.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/partition.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/partition.js ***!
    \*********************************************************************************************************/

  /*! exports provided: partition */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPartitionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "partition", function () {
      return partition;
    });
    /* harmony import */


    var _util_not__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/not */
    "../../node_modules/rxjs/_esm2015/internal/util/not.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "../../node_modules/rxjs/_esm2015/internal/operators/filter.js");

    function partition(predicate, thisArg) {
      return function (source) {
        return [Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(predicate, thisArg)(source), Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(Object(_util_not__WEBPACK_IMPORTED_MODULE_0__["not"])(predicate, thisArg))(source)];
      };
    } //# sourceMappingURL=partition.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/pluck.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/pluck.js ***!
    \*****************************************************************************************************/

  /*! exports provided: pluck */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPluckJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pluck", function () {
      return pluck;
    });
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");

    function pluck() {
      for (var _len15 = arguments.length, properties = new Array(_len15), _key16 = 0; _key16 < _len15; _key16++) {
        properties[_key16] = arguments[_key16];
      }

      var length = properties.length;

      if (length === 0) {
        throw new Error('list of properties cannot be empty.');
      }

      return function (source) {
        return Object(_map__WEBPACK_IMPORTED_MODULE_0__["map"])(plucker(properties, length))(source);
      };
    }

    function plucker(props, length) {
      var mapper = function mapper(x) {
        var currentProp = x;

        for (var i = 0; i < length; i++) {
          var p = currentProp[props[i]];

          if (typeof p !== 'undefined') {
            currentProp = p;
          } else {
            return undefined;
          }
        }

        return currentProp;
      };

      return mapper;
    } //# sourceMappingURL=pluck.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/publish.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/publish.js ***!
    \*******************************************************************************************************/

  /*! exports provided: publish */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publish", function () {
      return publish;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publish(selector) {
      return selector ? Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(function () {
        return new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
      }, selector) : Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]());
    } //# sourceMappingURL=publish.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js":
  /*!***************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js ***!
    \***************************************************************************************************************/

  /*! exports provided: publishBehavior */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishBehaviorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishBehavior", function () {
      return publishBehavior;
    });
    /* harmony import */


    var _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../BehaviorSubject */
    "../../node_modules/rxjs/_esm2015/internal/BehaviorSubject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publishBehavior(value) {
      return function (source) {
        return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__["BehaviorSubject"](value))(source);
      };
    } //# sourceMappingURL=publishBehavior.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/publishLast.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/publishLast.js ***!
    \***********************************************************************************************************/

  /*! exports provided: publishLast */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishLast", function () {
      return publishLast;
    });
    /* harmony import */


    var _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../AsyncSubject */
    "../../node_modules/rxjs/_esm2015/internal/AsyncSubject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publishLast() {
      return function (source) {
        return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__["AsyncSubject"]())(source);
      };
    } //# sourceMappingURL=publishLast.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/publishReplay.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/publishReplay.js ***!
    \*************************************************************************************************************/

  /*! exports provided: publishReplay */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishReplayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishReplay", function () {
      return publishReplay;
    });
    /* harmony import */


    var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../ReplaySubject */
    "../../node_modules/rxjs/_esm2015/internal/ReplaySubject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
      if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
      }

      var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
      var subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
      return function (source) {
        return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(function () {
          return subject;
        }, selector)(source);
      };
    } //# sourceMappingURL=publishReplay.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/race.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/race.js ***!
    \****************************************************************************************************/

  /*! exports provided: race */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRaceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return race;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _observable_race__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/race */
    "../../node_modules/rxjs/_esm2015/internal/observable/race.js");

    function race() {
      for (var _len16 = arguments.length, observables = new Array(_len16), _key17 = 0; _key17 < _len16; _key17++) {
        observables[_key17] = arguments[_key17];
      }

      return function raceOperatorFunction(source) {
        if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
          observables = observables[0];
        }

        return source.lift.call(Object(_observable_race__WEBPACK_IMPORTED_MODULE_1__["race"]).apply(void 0, [source].concat(_toConsumableArray(observables))));
      };
    } //# sourceMappingURL=race.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/reduce.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/reduce.js ***!
    \******************************************************************************************************/

  /*! exports provided: reduce */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsReduceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "reduce", function () {
      return reduce;
    });
    /* harmony import */


    var _scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./scan */
    "../../node_modules/rxjs/_esm2015/internal/operators/scan.js");
    /* harmony import */


    var _takeLast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./takeLast */
    "../../node_modules/rxjs/_esm2015/internal/operators/takeLast.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/pipe */
    "../../node_modules/rxjs/_esm2015/internal/util/pipe.js");

    function reduce(accumulator, seed) {
      if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
          return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(accumulator, seed), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1), Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__["defaultIfEmpty"])(seed))(source);
        };
      }

      return function reduceOperatorFunction(source) {
        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(function (acc, value, index) {
          return accumulator(acc, value, index + 1);
        }), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1))(source);
      };
    } //# sourceMappingURL=reduce.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/refCount.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/refCount.js ***!
    \********************************************************************************************************/

  /*! exports provided: refCount */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRefCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "refCount", function () {
      return refCount;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function refCount() {
      return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
      };
    }

    var RefCountOperator = /*#__PURE__*/function () {
      function RefCountOperator(connectable) {
        _classCallCheck(this, RefCountOperator);

        this.connectable = connectable;
      }

      _createClass(RefCountOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          var connectable = this.connectable;
          connectable._refCount++;
          var refCounter = new RefCountSubscriber(subscriber, connectable);
          var subscription = source.subscribe(refCounter);

          if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
          }

          return subscription;
        }
      }]);

      return RefCountOperator;
    }();

    var RefCountSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_29) {
      _inherits(RefCountSubscriber, _Subscriber__WEBPACK_29);

      var _super78 = _createSuper(RefCountSubscriber);

      function RefCountSubscriber(destination, connectable) {
        var _this163;

        _classCallCheck(this, RefCountSubscriber);

        _this163 = _super78.call(this, destination);
        _this163.connectable = connectable;
        return _this163;
      }

      _createClass(RefCountSubscriber, [{
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var connectable = this.connectable;

          if (!connectable) {
            this.connection = null;
            return;
          }

          this.connectable = null;
          var refCount = connectable._refCount;

          if (refCount <= 0) {
            this.connection = null;
            return;
          }

          connectable._refCount = refCount - 1;

          if (refCount > 1) {
            this.connection = null;
            return;
          }

          var connection = this.connection;
          var sharedConnection = connectable._connection;
          this.connection = null;

          if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
          }
        }
      }]);

      return RefCountSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=refCount.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/repeat.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/repeat.js ***!
    \******************************************************************************************************/

  /*! exports provided: repeat */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRepeatJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "repeat", function () {
      return repeat;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/empty */
    "../../node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function repeat() {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      return function (source) {
        if (count === 0) {
          return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_1__["empty"])();
        } else if (count < 0) {
          return source.lift(new RepeatOperator(-1, source));
        } else {
          return source.lift(new RepeatOperator(count - 1, source));
        }
      };
    }

    var RepeatOperator = /*#__PURE__*/function () {
      function RepeatOperator(count, source) {
        _classCallCheck(this, RepeatOperator);

        this.count = count;
        this.source = source;
      }

      _createClass(RepeatOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
        }
      }]);

      return RepeatOperator;
    }();

    var RepeatSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_30) {
      _inherits(RepeatSubscriber, _Subscriber__WEBPACK_30);

      var _super79 = _createSuper(RepeatSubscriber);

      function RepeatSubscriber(destination, count, source) {
        var _this164;

        _classCallCheck(this, RepeatSubscriber);

        _this164 = _super79.call(this, destination);
        _this164.count = count;
        _this164.source = source;
        return _this164;
      }

      _createClass(RepeatSubscriber, [{
        key: "complete",
        value: function complete() {
          if (!this.isStopped) {
            var source = this.source,
                count = this.count;

            if (count === 0) {
              return _get(_getPrototypeOf(RepeatSubscriber.prototype), "complete", this).call(this);
            } else if (count > -1) {
              this.count = count - 1;
            }

            source.subscribe(this._unsubscribeAndRecycle());
          }
        }
      }]);

      return RepeatSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=repeat.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js ***!
    \**********************************************************************************************************/

  /*! exports provided: repeatWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRepeatWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "repeatWhen", function () {
      return repeatWhen;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function repeatWhen(notifier) {
      return function (source) {
        return source.lift(new RepeatWhenOperator(notifier));
      };
    }

    var RepeatWhenOperator = /*#__PURE__*/function () {
      function RepeatWhenOperator(notifier) {
        _classCallCheck(this, RepeatWhenOperator);

        this.notifier = notifier;
      }

      _createClass(RepeatWhenOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
        }
      }]);

      return RepeatWhenOperator;
    }();

    var RepeatWhenSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB18) {
      _inherits(RepeatWhenSubscriber, _OuterSubscriber__WEB18);

      var _super80 = _createSuper(RepeatWhenSubscriber);

      function RepeatWhenSubscriber(destination, notifier, source) {
        var _this165;

        _classCallCheck(this, RepeatWhenSubscriber);

        _this165 = _super80.call(this, destination);
        _this165.notifier = notifier;
        _this165.source = source;
        _this165.sourceIsBeingSubscribedTo = true;
        return _this165;
      }

      _createClass(RepeatWhenSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.sourceIsBeingSubscribedTo = true;
          this.source.subscribe(this);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          if (this.sourceIsBeingSubscribedTo === false) {
            return _get(_getPrototypeOf(RepeatWhenSubscriber.prototype), "complete", this).call(this);
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          this.sourceIsBeingSubscribedTo = false;

          if (!this.isStopped) {
            if (!this.retries) {
              this.subscribeToRetries();
            }

            if (!this.retriesSubscription || this.retriesSubscription.closed) {
              return _get(_getPrototypeOf(RepeatWhenSubscriber.prototype), "complete", this).call(this);
            }

            this._unsubscribeAndRecycle();

            this.notifications.next();
          }
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var notifications = this.notifications,
              retriesSubscription = this.retriesSubscription;

          if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
          }

          if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
          }

          this.retries = null;
        }
      }, {
        key: "_unsubscribeAndRecycle",
        value: function _unsubscribeAndRecycle() {
          var _unsubscribe = this._unsubscribe;
          this._unsubscribe = null;

          _get(_getPrototypeOf(RepeatWhenSubscriber.prototype), "_unsubscribeAndRecycle", this).call(this);

          this._unsubscribe = _unsubscribe;
          return this;
        }
      }, {
        key: "subscribeToRetries",
        value: function subscribeToRetries() {
          this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
          var retries;

          try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
          } catch (e) {
            return _get(_getPrototypeOf(RepeatWhenSubscriber.prototype), "complete", this).call(this);
          }

          this.retries = retries;
          this.retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, retries);
        }
      }]);

      return RepeatWhenSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=repeatWhen.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/retry.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/retry.js ***!
    \*****************************************************************************************************/

  /*! exports provided: retry */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRetryJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "retry", function () {
      return retry;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function retry() {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      return function (source) {
        return source.lift(new RetryOperator(count, source));
      };
    }

    var RetryOperator = /*#__PURE__*/function () {
      function RetryOperator(count, source) {
        _classCallCheck(this, RetryOperator);

        this.count = count;
        this.source = source;
      }

      _createClass(RetryOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
        }
      }]);

      return RetryOperator;
    }();

    var RetrySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_31) {
      _inherits(RetrySubscriber, _Subscriber__WEBPACK_31);

      var _super81 = _createSuper(RetrySubscriber);

      function RetrySubscriber(destination, count, source) {
        var _this166;

        _classCallCheck(this, RetrySubscriber);

        _this166 = _super81.call(this, destination);
        _this166.count = count;
        _this166.source = source;
        return _this166;
      }

      _createClass(RetrySubscriber, [{
        key: "error",
        value: function error(err) {
          if (!this.isStopped) {
            var source = this.source,
                count = this.count;

            if (count === 0) {
              return _get(_getPrototypeOf(RetrySubscriber.prototype), "error", this).call(this, err);
            } else if (count > -1) {
              this.count = count - 1;
            }

            source.subscribe(this._unsubscribeAndRecycle());
          }
        }
      }]);

      return RetrySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=retry.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/retryWhen.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/retryWhen.js ***!
    \*********************************************************************************************************/

  /*! exports provided: retryWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRetryWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "retryWhen", function () {
      return retryWhen;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function retryWhen(notifier) {
      return function (source) {
        return source.lift(new RetryWhenOperator(notifier, source));
      };
    }

    var RetryWhenOperator = /*#__PURE__*/function () {
      function RetryWhenOperator(notifier, source) {
        _classCallCheck(this, RetryWhenOperator);

        this.notifier = notifier;
        this.source = source;
      }

      _createClass(RetryWhenOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
        }
      }]);

      return RetryWhenOperator;
    }();

    var RetryWhenSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB19) {
      _inherits(RetryWhenSubscriber, _OuterSubscriber__WEB19);

      var _super82 = _createSuper(RetryWhenSubscriber);

      function RetryWhenSubscriber(destination, notifier, source) {
        var _this167;

        _classCallCheck(this, RetryWhenSubscriber);

        _this167 = _super82.call(this, destination);
        _this167.notifier = notifier;
        _this167.source = source;
        return _this167;
      }

      _createClass(RetryWhenSubscriber, [{
        key: "error",
        value: function error(err) {
          if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;

            if (!retries) {
              errors = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();

              try {
                var notifier = this.notifier;
                retries = notifier(errors);
              } catch (e) {
                return _get(_getPrototypeOf(RetryWhenSubscriber.prototype), "error", this).call(this, e);
              }

              retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, retries);
            } else {
              this.errors = null;
              this.retriesSubscription = null;
            }

            this._unsubscribeAndRecycle();

            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
          }
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var errors = this.errors,
              retriesSubscription = this.retriesSubscription;

          if (errors) {
            errors.unsubscribe();
            this.errors = null;
          }

          if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
          }

          this.retries = null;
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          var _unsubscribe = this._unsubscribe;
          this._unsubscribe = null;

          this._unsubscribeAndRecycle();

          this._unsubscribe = _unsubscribe;
          this.source.subscribe(this);
        }
      }]);

      return RetryWhenSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=retryWhen.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/sample.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/sample.js ***!
    \******************************************************************************************************/

  /*! exports provided: sample */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSampleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sample", function () {
      return sample;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function sample(notifier) {
      return function (source) {
        return source.lift(new SampleOperator(notifier));
      };
    }

    var SampleOperator = /*#__PURE__*/function () {
      function SampleOperator(notifier) {
        _classCallCheck(this, SampleOperator);

        this.notifier = notifier;
      }

      _createClass(SampleOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          var sampleSubscriber = new SampleSubscriber(subscriber);
          var subscription = source.subscribe(sampleSubscriber);
          subscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(sampleSubscriber, this.notifier));
          return subscription;
        }
      }]);

      return SampleOperator;
    }();

    var SampleSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB20) {
      _inherits(SampleSubscriber, _OuterSubscriber__WEB20);

      var _super83 = _createSuper(SampleSubscriber);

      function SampleSubscriber() {
        var _this168;

        _classCallCheck(this, SampleSubscriber);

        _this168 = _super83.apply(this, arguments);
        _this168.hasValue = false;
        return _this168;
      }

      _createClass(SampleSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.value = value;
          this.hasValue = true;
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.emitValue();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {
          this.emitValue();
        }
      }, {
        key: "emitValue",
        value: function emitValue() {
          if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
          }
        }
      }]);

      return SampleSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=sample.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/sampleTime.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/sampleTime.js ***!
    \**********************************************************************************************************/

  /*! exports provided: sampleTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSampleTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sampleTime", function () {
      return sampleTime;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");

    function sampleTime(period) {
      var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      return function (source) {
        return source.lift(new SampleTimeOperator(period, scheduler));
      };
    }

    var SampleTimeOperator = /*#__PURE__*/function () {
      function SampleTimeOperator(period, scheduler) {
        _classCallCheck(this, SampleTimeOperator);

        this.period = period;
        this.scheduler = scheduler;
      }

      _createClass(SampleTimeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
        }
      }]);

      return SampleTimeOperator;
    }();

    var SampleTimeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_32) {
      _inherits(SampleTimeSubscriber, _Subscriber__WEBPACK_32);

      var _super84 = _createSuper(SampleTimeSubscriber);

      function SampleTimeSubscriber(destination, period, scheduler) {
        var _this169;

        _classCallCheck(this, SampleTimeSubscriber);

        _this169 = _super84.call(this, destination);
        _this169.period = period;
        _this169.scheduler = scheduler;
        _this169.hasValue = false;

        _this169.add(scheduler.schedule(dispatchNotification, period, {
          subscriber: _assertThisInitialized(_this169),
          period: period
        }));

        return _this169;
      }

      _createClass(SampleTimeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.lastValue = value;
          this.hasValue = true;
        }
      }, {
        key: "notifyNext",
        value: function notifyNext() {
          if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
          }
        }
      }]);

      return SampleTimeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    function dispatchNotification(state) {
      var subscriber = state.subscriber,
          period = state.period;
      subscriber.notifyNext();
      this.schedule(state, period);
    } //# sourceMappingURL=sampleTime.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/scan.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/scan.js ***!
    \****************************************************************************************************/

  /*! exports provided: scan */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsScanJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scan", function () {
      return scan;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function scan(accumulator, seed) {
      var hasSeed = false;

      if (arguments.length >= 2) {
        hasSeed = true;
      }

      return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
      };
    }

    var ScanOperator = /*#__PURE__*/function () {
      function ScanOperator(accumulator, seed) {
        var hasSeed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _classCallCheck(this, ScanOperator);

        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }

      _createClass(ScanOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
        }
      }]);

      return ScanOperator;
    }();

    var ScanSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_33) {
      _inherits(ScanSubscriber, _Subscriber__WEBPACK_33);

      var _super85 = _createSuper(ScanSubscriber);

      function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this170;

        _classCallCheck(this, ScanSubscriber);

        _this170 = _super85.call(this, destination);
        _this170.accumulator = accumulator;
        _this170._seed = _seed;
        _this170.hasSeed = hasSeed;
        _this170.index = 0;
        return _this170;
      }

      _createClass(ScanSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
          } else {
            return this._tryNext(value);
          }
        }
      }, {
        key: "_tryNext",
        value: function _tryNext(value) {
          var index = this.index++;
          var result;

          try {
            result = this.accumulator(this.seed, value, index);
          } catch (err) {
            this.destination.error(err);
          }

          this.seed = result;
          this.destination.next(result);
        }
      }, {
        key: "seed",
        get: function get() {
          return this._seed;
        },
        set: function set(value) {
          this.hasSeed = true;
          this._seed = value;
        }
      }]);

      return ScanSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=scan.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js ***!
    \*************************************************************************************************************/

  /*! exports provided: sequenceEqual, SequenceEqualOperator, SequenceEqualSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSequenceEqualJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sequenceEqual", function () {
      return sequenceEqual;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SequenceEqualOperator", function () {
      return SequenceEqualOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SequenceEqualSubscriber", function () {
      return SequenceEqualSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function sequenceEqual(compareTo, comparator) {
      return function (source) {
        return source.lift(new SequenceEqualOperator(compareTo, comparator));
      };
    }

    var SequenceEqualOperator = /*#__PURE__*/function () {
      function SequenceEqualOperator(compareTo, comparator) {
        _classCallCheck(this, SequenceEqualOperator);

        this.compareTo = compareTo;
        this.comparator = comparator;
      }

      _createClass(SequenceEqualOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
        }
      }]);

      return SequenceEqualOperator;
    }();

    var SequenceEqualSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_34) {
      _inherits(SequenceEqualSubscriber, _Subscriber__WEBPACK_34);

      var _super86 = _createSuper(SequenceEqualSubscriber);

      function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this171;

        _classCallCheck(this, SequenceEqualSubscriber);

        _this171 = _super86.call(this, destination);
        _this171.compareTo = compareTo;
        _this171.comparator = comparator;
        _this171._a = [];
        _this171._b = [];
        _this171._oneComplete = false;

        _this171.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _assertThisInitialized(_this171))));

        return _this171;
      }

      _createClass(SequenceEqualSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
          } else {
            this._a.push(value);

            this.checkValues();
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
          } else {
            this._oneComplete = true;
          }

          this.unsubscribe();
        }
      }, {
        key: "checkValues",
        value: function checkValues() {
          var _a = this._a,
              _b = this._b,
              comparator = this.comparator;

          while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();

            var b = _b.shift();

            var areEqual = false;

            try {
              areEqual = comparator ? comparator(a, b) : a === b;
            } catch (e) {
              this.destination.error(e);
            }

            if (!areEqual) {
              this.emit(false);
            }
          }
        }
      }, {
        key: "emit",
        value: function emit(value) {
          var destination = this.destination;
          destination.next(value);
          destination.complete();
        }
      }, {
        key: "nextB",
        value: function nextB(value) {
          if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
          } else {
            this._b.push(value);

            this.checkValues();
          }
        }
      }, {
        key: "completeB",
        value: function completeB() {
          if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
          } else {
            this._oneComplete = true;
          }
        }
      }]);

      return SequenceEqualSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    var SequenceEqualCompareToSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_35) {
      _inherits(SequenceEqualCompareToSubscriber, _Subscriber__WEBPACK_35);

      var _super87 = _createSuper(SequenceEqualCompareToSubscriber);

      function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this172;

        _classCallCheck(this, SequenceEqualCompareToSubscriber);

        _this172 = _super87.call(this, destination);
        _this172.parent = parent;
        return _this172;
      }

      _createClass(SequenceEqualCompareToSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.parent.nextB(value);
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.parent.error(err);
          this.unsubscribe();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.parent.completeB();
          this.unsubscribe();
        }
      }]);

      return SequenceEqualCompareToSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=sequenceEqual.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/share.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/share.js ***!
    \*****************************************************************************************************/

  /*! exports provided: share */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsShareJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "share", function () {
      return share;
    });
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./multicast */
    "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js");
    /* harmony import */


    var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./refCount */
    "../../node_modules/rxjs/_esm2015/internal/operators/refCount.js");
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");

    function shareSubjectFactory() {
      return new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
    }

    function share() {
      return function (source) {
        return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__["refCount"])()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__["multicast"])(shareSubjectFactory)(source));
      };
    } //# sourceMappingURL=share.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/shareReplay.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/shareReplay.js ***!
    \***********************************************************************************************************/

  /*! exports provided: shareReplay */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsShareReplayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shareReplay", function () {
      return shareReplay;
    });
    /* harmony import */


    var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../ReplaySubject */
    "../../node_modules/rxjs/_esm2015/internal/ReplaySubject.js");

    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var config;

      if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
      } else {
        config = {
          bufferSize: configOrBufferSize,
          windowTime: windowTime,
          refCount: false,
          scheduler: scheduler
        };
      }

      return function (source) {
        return source.lift(shareReplayOperator(config));
      };
    }

    function shareReplayOperator(_ref5) {
      var _ref5$bufferSize = _ref5.bufferSize,
          bufferSize = _ref5$bufferSize === void 0 ? Number.POSITIVE_INFINITY : _ref5$bufferSize,
          _ref5$windowTime = _ref5.windowTime,
          windowTime = _ref5$windowTime === void 0 ? Number.POSITIVE_INFINITY : _ref5$windowTime,
          useRefCount = _ref5.refCount,
          scheduler = _ref5.scheduler;
      var subject;
      var refCount = 0;
      var subscription;
      var hasError = false;
      var isComplete = false;
      return function shareReplayOperation(source) {
        refCount++;

        if (!subject || hasError) {
          hasError = false;
          subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
          subscription = source.subscribe({
            next: function next(value) {
              subject.next(value);
            },
            error: function error(err) {
              hasError = true;
              subject.error(err);
            },
            complete: function complete() {
              isComplete = true;
              subscription = undefined;
              subject.complete();
            }
          });
        }

        var innerSub = subject.subscribe(this);
        this.add(function () {
          refCount--;
          innerSub.unsubscribe();

          if (subscription && !isComplete && useRefCount && refCount === 0) {
            subscription.unsubscribe();
            subscription = undefined;
            subject = undefined;
          }
        });
      };
    } //# sourceMappingURL=shareReplay.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/single.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/single.js ***!
    \******************************************************************************************************/

  /*! exports provided: single */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSingleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "single", function () {
      return single;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/EmptyError */
    "../../node_modules/rxjs/_esm2015/internal/util/EmptyError.js");

    function single(predicate) {
      return function (source) {
        return source.lift(new SingleOperator(predicate, source));
      };
    }

    var SingleOperator = /*#__PURE__*/function () {
      function SingleOperator(predicate, source) {
        _classCallCheck(this, SingleOperator);

        this.predicate = predicate;
        this.source = source;
      }

      _createClass(SingleOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
        }
      }]);

      return SingleOperator;
    }();

    var SingleSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_36) {
      _inherits(SingleSubscriber, _Subscriber__WEBPACK_36);

      var _super88 = _createSuper(SingleSubscriber);

      function SingleSubscriber(destination, predicate, source) {
        var _this173;

        _classCallCheck(this, SingleSubscriber);

        _this173 = _super88.call(this, destination);
        _this173.predicate = predicate;
        _this173.source = source;
        _this173.seenValue = false;
        _this173.index = 0;
        return _this173;
      }

      _createClass(SingleSubscriber, [{
        key: "applySingleValue",
        value: function applySingleValue(value) {
          if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
          } else {
            this.seenValue = true;
            this.singleValue = value;
          }
        }
      }, {
        key: "_next",
        value: function _next(value) {
          var index = this.index++;

          if (this.predicate) {
            this.tryNext(value, index);
          } else {
            this.applySingleValue(value);
          }
        }
      }, {
        key: "tryNext",
        value: function tryNext(value, index) {
          try {
            if (this.predicate(value, index, this.source)) {
              this.applySingleValue(value);
            }
          } catch (err) {
            this.destination.error(err);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var destination = this.destination;

          if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
          } else {
            destination.error(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__["EmptyError"]());
          }
        }
      }]);

      return SingleSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=single.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/skip.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/skip.js ***!
    \****************************************************************************************************/

  /*! exports provided: skip */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skip", function () {
      return skip;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function skip(count) {
      return function (source) {
        return source.lift(new SkipOperator(count));
      };
    }

    var SkipOperator = /*#__PURE__*/function () {
      function SkipOperator(total) {
        _classCallCheck(this, SkipOperator);

        this.total = total;
      }

      _createClass(SkipOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SkipSubscriber(subscriber, this.total));
        }
      }]);

      return SkipOperator;
    }();

    var SkipSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_37) {
      _inherits(SkipSubscriber, _Subscriber__WEBPACK_37);

      var _super89 = _createSuper(SkipSubscriber);

      function SkipSubscriber(destination, total) {
        var _this174;

        _classCallCheck(this, SkipSubscriber);

        _this174 = _super89.call(this, destination);
        _this174.total = total;
        _this174.count = 0;
        return _this174;
      }

      _createClass(SkipSubscriber, [{
        key: "_next",
        value: function _next(x) {
          if (++this.count > this.total) {
            this.destination.next(x);
          }
        }
      }]);

      return SkipSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=skip.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/skipLast.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/skipLast.js ***!
    \********************************************************************************************************/

  /*! exports provided: skipLast */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skipLast", function () {
      return skipLast;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "../../node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");

    function skipLast(count) {
      return function (source) {
        return source.lift(new SkipLastOperator(count));
      };
    }

    var SkipLastOperator = /*#__PURE__*/function () {
      function SkipLastOperator(_skipCount) {
        _classCallCheck(this, SkipLastOperator);

        this._skipCount = _skipCount;

        if (this._skipCount < 0) {
          throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__["ArgumentOutOfRangeError"]();
        }
      }

      _createClass(SkipLastOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          if (this._skipCount === 0) {
            return source.subscribe(new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](subscriber));
          } else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
          }
        }
      }]);

      return SkipLastOperator;
    }();

    var SkipLastSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_38) {
      _inherits(SkipLastSubscriber, _Subscriber__WEBPACK_38);

      var _super90 = _createSuper(SkipLastSubscriber);

      function SkipLastSubscriber(destination, _skipCount) {
        var _this175;

        _classCallCheck(this, SkipLastSubscriber);

        _this175 = _super90.call(this, destination);
        _this175._skipCount = _skipCount;
        _this175._count = 0;
        _this175._ring = new Array(_skipCount);
        return _this175;
      }

      _createClass(SkipLastSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var skipCount = this._skipCount;
          var count = this._count++;

          if (count < skipCount) {
            this._ring[count] = value;
          } else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
          }
        }
      }]);

      return SkipLastSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=skipLast.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/skipUntil.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/skipUntil.js ***!
    \*********************************************************************************************************/

  /*! exports provided: skipUntil */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipUntilJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skipUntil", function () {
      return skipUntil;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function skipUntil(notifier) {
      return function (source) {
        return source.lift(new SkipUntilOperator(notifier));
      };
    }

    var SkipUntilOperator = /*#__PURE__*/function () {
      function SkipUntilOperator(notifier) {
        _classCallCheck(this, SkipUntilOperator);

        this.notifier = notifier;
      }

      _createClass(SkipUntilOperator, [{
        key: "call",
        value: function call(destination, source) {
          return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
        }
      }]);

      return SkipUntilOperator;
    }();

    var SkipUntilSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB21) {
      _inherits(SkipUntilSubscriber, _OuterSubscriber__WEB21);

      var _super91 = _createSuper(SkipUntilSubscriber);

      function SkipUntilSubscriber(destination, notifier) {
        var _this176;

        _classCallCheck(this, SkipUntilSubscriber);

        _this176 = _super91.call(this, destination);
        _this176.hasValue = false;
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](_assertThisInitialized(_this176), undefined, undefined);

        _this176.add(innerSubscriber);

        _this176.innerSubscription = innerSubscriber;
        var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_assertThisInitialized(_this176), notifier, undefined, undefined, innerSubscriber);

        if (innerSubscription !== innerSubscriber) {
          _this176.add(innerSubscription);

          _this176.innerSubscription = innerSubscription;
        }

        return _this176;
      }

      _createClass(SkipUntilSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (this.hasValue) {
            _get(_getPrototypeOf(SkipUntilSubscriber.prototype), "_next", this).call(this, value);
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.hasValue = true;

          if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
          }
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {}
      }]);

      return SkipUntilSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=skipUntil.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/skipWhile.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/skipWhile.js ***!
    \*********************************************************************************************************/

  /*! exports provided: skipWhile */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipWhileJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skipWhile", function () {
      return skipWhile;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function skipWhile(predicate) {
      return function (source) {
        return source.lift(new SkipWhileOperator(predicate));
      };
    }

    var SkipWhileOperator = /*#__PURE__*/function () {
      function SkipWhileOperator(predicate) {
        _classCallCheck(this, SkipWhileOperator);

        this.predicate = predicate;
      }

      _createClass(SkipWhileOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
        }
      }]);

      return SkipWhileOperator;
    }();

    var SkipWhileSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_39) {
      _inherits(SkipWhileSubscriber, _Subscriber__WEBPACK_39);

      var _super92 = _createSuper(SkipWhileSubscriber);

      function SkipWhileSubscriber(destination, predicate) {
        var _this177;

        _classCallCheck(this, SkipWhileSubscriber);

        _this177 = _super92.call(this, destination);
        _this177.predicate = predicate;
        _this177.skipping = true;
        _this177.index = 0;
        return _this177;
      }

      _createClass(SkipWhileSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var destination = this.destination;

          if (this.skipping) {
            this.tryCallPredicate(value);
          }

          if (!this.skipping) {
            destination.next(value);
          }
        }
      }, {
        key: "tryCallPredicate",
        value: function tryCallPredicate(value) {
          try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
          } catch (err) {
            this.destination.error(err);
          }
        }
      }]);

      return SkipWhileSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=skipWhile.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/startWith.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/startWith.js ***!
    \*********************************************************************************************************/

  /*! exports provided: startWith */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsStartWithJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "startWith", function () {
      return startWith;
    });
    /* harmony import */


    var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/concat */
    "../../node_modules/rxjs/_esm2015/internal/observable/concat.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function startWith() {
      for (var _len17 = arguments.length, array = new Array(_len17), _key18 = 0; _key18 < _len17; _key18++) {
        array[_key18] = arguments[_key18];
      }

      var scheduler = array[array.length - 1];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(scheduler)) {
        array.pop();
        return function (source) {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(array, source, scheduler);
        };
      } else {
        return function (source) {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(array, source);
        };
      }
    } //# sourceMappingURL=startWith.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js ***!
    \***********************************************************************************************************/

  /*! exports provided: subscribeOn */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSubscribeOnJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeOn", function () {
      return subscribeOn;
    });
    /* harmony import */


    var _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/SubscribeOnObservable */
    "../../node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js");

    function subscribeOn(scheduler) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
      };
    }

    var SubscribeOnOperator = /*#__PURE__*/function () {
      function SubscribeOnOperator(scheduler, delay) {
        _classCallCheck(this, SubscribeOnOperator);

        this.scheduler = scheduler;
        this.delay = delay;
      }

      _createClass(SubscribeOnOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return new _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__["SubscribeOnObservable"](source, this.delay, this.scheduler).subscribe(subscriber);
        }
      }]);

      return SubscribeOnOperator;
    }(); //# sourceMappingURL=subscribeOn.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/switchAll.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/switchAll.js ***!
    \*********************************************************************************************************/

  /*! exports provided: switchAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSwitchAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "switchAll", function () {
      return switchAll;
    });
    /* harmony import */


    var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./switchMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/switchMap.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/identity */
    "../../node_modules/rxjs/_esm2015/internal/util/identity.js");

    function switchAll() {
      return Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"]);
    } //# sourceMappingURL=switchAll.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/switchMap.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/switchMap.js ***!
    \*********************************************************************************************************/

  /*! exports provided: switchMap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSwitchMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "switchMap", function () {
      return switchMap;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../observable/from */
    "../../node_modules/rxjs/_esm2015/internal/observable/from.js");

    function switchMap(project, resultSelector) {
      if (typeof resultSelector === 'function') {
        return function (source) {
          return source.pipe(switchMap(function (a, i) {
            return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }

      return function (source) {
        return source.lift(new SwitchMapOperator(project));
      };
    }

    var SwitchMapOperator = /*#__PURE__*/function () {
      function SwitchMapOperator(project) {
        _classCallCheck(this, SwitchMapOperator);

        this.project = project;
      }

      _createClass(SwitchMapOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
        }
      }]);

      return SwitchMapOperator;
    }();

    var SwitchMapSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB22) {
      _inherits(SwitchMapSubscriber, _OuterSubscriber__WEB22);

      var _super93 = _createSuper(SwitchMapSubscriber);

      function SwitchMapSubscriber(destination, project) {
        var _this178;

        _classCallCheck(this, SwitchMapSubscriber);

        _this178 = _super93.call(this, destination);
        _this178.project = project;
        _this178.index = 0;
        return _this178;
      }

      _createClass(SwitchMapSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var result;
          var index = this.index++;

          try {
            result = this.project(value, index);
          } catch (error) {
            this.destination.error(error);
            return;
          }

          this._innerSub(result, value, index);
        }
      }, {
        key: "_innerSub",
        value: function _innerSub(result, value, index) {
          var innerSubscription = this.innerSubscription;

          if (innerSubscription) {
            innerSubscription.unsubscribe();
          }

          var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, value, index);
          var destination = this.destination;
          destination.add(innerSubscriber);
          this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, undefined, undefined, innerSubscriber);

          if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var innerSubscription = this.innerSubscription;

          if (!innerSubscription || innerSubscription.closed) {
            _get(_getPrototypeOf(SwitchMapSubscriber.prototype), "_complete", this).call(this);
          }

          this.unsubscribe();
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.innerSubscription = null;
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          var destination = this.destination;
          destination.remove(innerSub);
          this.innerSubscription = null;

          if (this.isStopped) {
            _get(_getPrototypeOf(SwitchMapSubscriber.prototype), "_complete", this).call(this);
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
      }]);

      return SwitchMapSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=switchMap.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js ***!
    \***********************************************************************************************************/

  /*! exports provided: switchMapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSwitchMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "switchMapTo", function () {
      return switchMapTo;
    });
    /* harmony import */


    var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./switchMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/switchMap.js");

    function switchMapTo(innerObservable, resultSelector) {
      return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(function () {
        return innerObservable;
      }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(function () {
        return innerObservable;
      });
    } //# sourceMappingURL=switchMapTo.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/take.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/take.js ***!
    \****************************************************************************************************/

  /*! exports provided: take */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "take", function () {
      return take;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "../../node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/empty */
    "../../node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function take(count) {
      return function (source) {
        if (count === 0) {
          return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        } else {
          return source.lift(new TakeOperator(count));
        }
      };
    }

    var TakeOperator = /*#__PURE__*/function () {
      function TakeOperator(total) {
        _classCallCheck(this, TakeOperator);

        this.total = total;

        if (this.total < 0) {
          throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__["ArgumentOutOfRangeError"]();
        }
      }

      _createClass(TakeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new TakeSubscriber(subscriber, this.total));
        }
      }]);

      return TakeOperator;
    }();

    var TakeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_40) {
      _inherits(TakeSubscriber, _Subscriber__WEBPACK_40);

      var _super94 = _createSuper(TakeSubscriber);

      function TakeSubscriber(destination, total) {
        var _this179;

        _classCallCheck(this, TakeSubscriber);

        _this179 = _super94.call(this, destination);
        _this179.total = total;
        _this179.count = 0;
        return _this179;
      }

      _createClass(TakeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var total = this.total;
          var count = ++this.count;

          if (count <= total) {
            this.destination.next(value);

            if (count === total) {
              this.destination.complete();
              this.unsubscribe();
            }
          }
        }
      }]);

      return TakeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=take.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/takeLast.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/takeLast.js ***!
    \********************************************************************************************************/

  /*! exports provided: takeLast */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "takeLast", function () {
      return takeLast;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "../../node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/empty */
    "../../node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function takeLast(count) {
      return function takeLastOperatorFunction(source) {
        if (count === 0) {
          return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        } else {
          return source.lift(new TakeLastOperator(count));
        }
      };
    }

    var TakeLastOperator = /*#__PURE__*/function () {
      function TakeLastOperator(total) {
        _classCallCheck(this, TakeLastOperator);

        this.total = total;

        if (this.total < 0) {
          throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__["ArgumentOutOfRangeError"]();
        }
      }

      _createClass(TakeLastOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
        }
      }]);

      return TakeLastOperator;
    }();

    var TakeLastSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_41) {
      _inherits(TakeLastSubscriber, _Subscriber__WEBPACK_41);

      var _super95 = _createSuper(TakeLastSubscriber);

      function TakeLastSubscriber(destination, total) {
        var _this180;

        _classCallCheck(this, TakeLastSubscriber);

        _this180 = _super95.call(this, destination);
        _this180.total = total;
        _this180.ring = new Array();
        _this180.count = 0;
        return _this180;
      }

      _createClass(TakeLastSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var ring = this.ring;
          var total = this.total;
          var count = this.count++;

          if (ring.length < total) {
            ring.push(value);
          } else {
            var index = count % total;
            ring[index] = value;
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var destination = this.destination;
          var count = this.count;

          if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;

            for (var i = 0; i < total; i++) {
              var idx = count++ % total;
              destination.next(ring[idx]);
            }
          }

          destination.complete();
        }
      }]);

      return TakeLastSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=takeLast.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/takeUntil.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/takeUntil.js ***!
    \*********************************************************************************************************/

  /*! exports provided: takeUntil */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeUntilJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "takeUntil", function () {
      return takeUntil;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function takeUntil(notifier) {
      return function (source) {
        return source.lift(new TakeUntilOperator(notifier));
      };
    }

    var TakeUntilOperator = /*#__PURE__*/function () {
      function TakeUntilOperator(notifier) {
        _classCallCheck(this, TakeUntilOperator);

        this.notifier = notifier;
      }

      _createClass(TakeUntilOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
          var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(takeUntilSubscriber, this.notifier);

          if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
          }

          return takeUntilSubscriber;
        }
      }]);

      return TakeUntilOperator;
    }();

    var TakeUntilSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB23) {
      _inherits(TakeUntilSubscriber, _OuterSubscriber__WEB23);

      var _super96 = _createSuper(TakeUntilSubscriber);

      function TakeUntilSubscriber(destination) {
        var _this181;

        _classCallCheck(this, TakeUntilSubscriber);

        _this181 = _super96.call(this, destination);
        _this181.seenValue = false;
        return _this181;
      }

      _createClass(TakeUntilSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.seenValue = true;
          this.complete();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {}
      }]);

      return TakeUntilSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=takeUntil.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/takeWhile.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/takeWhile.js ***!
    \*********************************************************************************************************/

  /*! exports provided: takeWhile */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeWhileJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "takeWhile", function () {
      return takeWhile;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function takeWhile(predicate) {
      var inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
      };
    }

    var TakeWhileOperator = /*#__PURE__*/function () {
      function TakeWhileOperator(predicate, inclusive) {
        _classCallCheck(this, TakeWhileOperator);

        this.predicate = predicate;
        this.inclusive = inclusive;
      }

      _createClass(TakeWhileOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
        }
      }]);

      return TakeWhileOperator;
    }();

    var TakeWhileSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_42) {
      _inherits(TakeWhileSubscriber, _Subscriber__WEBPACK_42);

      var _super97 = _createSuper(TakeWhileSubscriber);

      function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this182;

        _classCallCheck(this, TakeWhileSubscriber);

        _this182 = _super97.call(this, destination);
        _this182.predicate = predicate;
        _this182.inclusive = inclusive;
        _this182.index = 0;
        return _this182;
      }

      _createClass(TakeWhileSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var destination = this.destination;
          var result;

          try {
            result = this.predicate(value, this.index++);
          } catch (err) {
            destination.error(err);
            return;
          }

          this.nextOrComplete(value, result);
        }
      }, {
        key: "nextOrComplete",
        value: function nextOrComplete(value, predicateResult) {
          var destination = this.destination;

          if (Boolean(predicateResult)) {
            destination.next(value);
          } else {
            if (this.inclusive) {
              destination.next(value);
            }

            destination.complete();
          }
        }
      }]);

      return TakeWhileSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=takeWhile.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/tap.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/tap.js ***!
    \***************************************************************************************************/

  /*! exports provided: tap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "tap", function () {
      return tap;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/noop */
    "../../node_modules/rxjs/_esm2015/internal/util/noop.js");
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isFunction */
    "../../node_modules/rxjs/_esm2015/internal/util/isFunction.js");

    function tap(nextOrObserver, error, complete) {
      return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
      };
    }

    var DoOperator = /*#__PURE__*/function () {
      function DoOperator(nextOrObserver, error, complete) {
        _classCallCheck(this, DoOperator);

        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }

      _createClass(DoOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
        }
      }]);

      return DoOperator;
    }();

    var TapSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_43) {
      _inherits(TapSubscriber, _Subscriber__WEBPACK_43);

      var _super98 = _createSuper(TapSubscriber);

      function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this183;

        _classCallCheck(this, TapSubscriber);

        _this183 = _super98.call(this, destination);
        _this183._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        _this183._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        _this183._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        _this183._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        _this183._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];

        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(observerOrNext)) {
          _this183._context = _assertThisInitialized(_this183);
          _this183._tapNext = observerOrNext;
        } else if (observerOrNext) {
          _this183._context = observerOrNext;
          _this183._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
          _this183._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
          _this183._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        }

        return _this183;
      }

      _createClass(TapSubscriber, [{
        key: "_next",
        value: function _next(value) {
          try {
            this._tapNext.call(this._context, value);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.destination.next(value);
        }
      }, {
        key: "_error",
        value: function _error(err) {
          try {
            this._tapError.call(this._context, err);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.destination.error(err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          try {
            this._tapComplete.call(this._context);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          return this.destination.complete();
        }
      }]);

      return TapSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=tap.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/throttle.js":
  /*!********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/throttle.js ***!
    \********************************************************************************************************/

  /*! exports provided: defaultThrottleConfig, throttle */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsThrottleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defaultThrottleConfig", function () {
      return defaultThrottleConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throttle", function () {
      return throttle;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    var defaultThrottleConfig = {
      leading: true,
      trailing: false
    };

    function throttle(durationSelector) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultThrottleConfig;
      return function (source) {
        return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));
      };
    }

    var ThrottleOperator = /*#__PURE__*/function () {
      function ThrottleOperator(durationSelector, leading, trailing) {
        _classCallCheck(this, ThrottleOperator);

        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }

      _createClass(ThrottleOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
        }
      }]);

      return ThrottleOperator;
    }();

    var ThrottleSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB24) {
      _inherits(ThrottleSubscriber, _OuterSubscriber__WEB24);

      var _super99 = _createSuper(ThrottleSubscriber);

      function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this184;

        _classCallCheck(this, ThrottleSubscriber);

        _this184 = _super99.call(this, destination);
        _this184.destination = destination;
        _this184.durationSelector = durationSelector;
        _this184._leading = _leading;
        _this184._trailing = _trailing;
        _this184._hasValue = false;
        return _this184;
      }

      _createClass(ThrottleSubscriber, [{
        key: "_next",
        value: function _next(value) {
          this._hasValue = true;
          this._sendValue = value;

          if (!this._throttled) {
            if (this._leading) {
              this.send();
            } else {
              this.throttle(value);
            }
          }
        }
      }, {
        key: "send",
        value: function send() {
          var _hasValue = this._hasValue,
              _sendValue = this._sendValue;

          if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
          }

          this._hasValue = false;
          this._sendValue = null;
        }
      }, {
        key: "throttle",
        value: function throttle(value) {
          var duration = this.tryDurationSelector(value);

          if (!!duration) {
            this.add(this._throttled = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, duration));
          }
        }
      }, {
        key: "tryDurationSelector",
        value: function tryDurationSelector(value) {
          try {
            return this.durationSelector(value);
          } catch (err) {
            this.destination.error(err);
            return null;
          }
        }
      }, {
        key: "throttlingDone",
        value: function throttlingDone() {
          var _throttled = this._throttled,
              _trailing = this._trailing;

          if (_throttled) {
            _throttled.unsubscribe();
          }

          this._throttled = null;

          if (_trailing) {
            this.send();
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.throttlingDone();
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {
          this.throttlingDone();
        }
      }]);

      return ThrottleSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=throttle.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/throttleTime.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/throttleTime.js ***!
    \************************************************************************************************************/

  /*! exports provided: throttleTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsThrottleTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throttleTime", function () {
      return throttleTime;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./throttle */
    "../../node_modules/rxjs/_esm2015/internal/operators/throttle.js");

    function throttleTime(duration) {
      var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _throttle__WEBPACK_IMPORTED_MODULE_2__["defaultThrottleConfig"];
      return function (source) {
        return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
      };
    }

    var ThrottleTimeOperator = /*#__PURE__*/function () {
      function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        _classCallCheck(this, ThrottleTimeOperator);

        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }

      _createClass(ThrottleTimeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
        }
      }]);

      return ThrottleTimeOperator;
    }();

    var ThrottleTimeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_44) {
      _inherits(ThrottleTimeSubscriber, _Subscriber__WEBPACK_44);

      var _super100 = _createSuper(ThrottleTimeSubscriber);

      function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this185;

        _classCallCheck(this, ThrottleTimeSubscriber);

        _this185 = _super100.call(this, destination);
        _this185.duration = duration;
        _this185.scheduler = scheduler;
        _this185.leading = leading;
        _this185.trailing = trailing;
        _this185._hasTrailingValue = false;
        _this185._trailingValue = null;
        return _this185;
      }

      _createClass(ThrottleTimeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          if (this.throttled) {
            if (this.trailing) {
              this._trailingValue = value;
              this._hasTrailingValue = true;
            }
          } else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
              subscriber: this
            }));

            if (this.leading) {
              this.destination.next(value);
            } else if (this.trailing) {
              this._trailingValue = value;
              this._hasTrailingValue = true;
            }
          }
        }
      }, {
        key: "_complete",
        value: function _complete() {
          if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
          } else {
            this.destination.complete();
          }
        }
      }, {
        key: "clearThrottle",
        value: function clearThrottle() {
          var throttled = this.throttled;

          if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
              this.destination.next(this._trailingValue);
              this._trailingValue = null;
              this._hasTrailingValue = false;
            }

            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
          }
        }
      }]);

      return ThrottleTimeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]);

    function dispatchNext(arg) {
      var subscriber = arg.subscriber;
      subscriber.clearThrottle();
    } //# sourceMappingURL=throttleTime.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js ***!
    \************************************************************************************************************/

  /*! exports provided: throwIfEmpty */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsThrowIfEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function () {
      return throwIfEmpty;
    });
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/EmptyError */
    "../../node_modules/rxjs/_esm2015/internal/util/EmptyError.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function throwIfEmpty() {
      var errorFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultErrorFactory;
      return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
      };
    }

    var ThrowIfEmptyOperator = /*#__PURE__*/function () {
      function ThrowIfEmptyOperator(errorFactory) {
        _classCallCheck(this, ThrowIfEmptyOperator);

        this.errorFactory = errorFactory;
      }

      _createClass(ThrowIfEmptyOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
        }
      }]);

      return ThrowIfEmptyOperator;
    }();

    var ThrowIfEmptySubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_45) {
      _inherits(ThrowIfEmptySubscriber, _Subscriber__WEBPACK_45);

      var _super101 = _createSuper(ThrowIfEmptySubscriber);

      function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this186;

        _classCallCheck(this, ThrowIfEmptySubscriber);

        _this186 = _super101.call(this, destination);
        _this186.errorFactory = errorFactory;
        _this186.hasValue = false;
        return _this186;
      }

      _createClass(ThrowIfEmptySubscriber, [{
        key: "_next",
        value: function _next(value) {
          this.hasValue = true;
          this.destination.next(value);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          if (!this.hasValue) {
            var _err;

            try {
              _err = this.errorFactory();
            } catch (e) {
              _err = e;
            }

            this.destination.error(_err);
          } else {
            return this.destination.complete();
          }
        }
      }]);

      return ThrowIfEmptySubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]);

    function defaultErrorFactory() {
      return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"]();
    } //# sourceMappingURL=throwIfEmpty.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/timeInterval.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/timeInterval.js ***!
    \************************************************************************************************************/

  /*! exports provided: timeInterval, TimeInterval */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimeIntervalJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timeInterval", function () {
      return timeInterval;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeInterval", function () {
      return TimeInterval;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _scan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./scan */
    "../../node_modules/rxjs/_esm2015/internal/operators/scan.js");
    /* harmony import */


    var _observable_defer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/defer */
    "../../node_modules/rxjs/_esm2015/internal/observable/defer.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");

    function timeInterval() {
      var scheduler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
      return function (source) {
        return Object(_observable_defer__WEBPACK_IMPORTED_MODULE_2__["defer"])(function () {
          return source.pipe(Object(_scan__WEBPACK_IMPORTED_MODULE_1__["scan"])(function (_ref6, value) {
            var current = _ref6.current;
            return {
              value: value,
              current: scheduler.now(),
              last: current
            };
          }, {
            current: scheduler.now(),
            value: undefined,
            last: undefined
          }), Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (_ref7) {
            var current = _ref7.current,
                last = _ref7.last,
                value = _ref7.value;
            return new TimeInterval(value, current - last);
          }));
        });
      };
    }

    var TimeInterval = function TimeInterval(value, interval) {
      _classCallCheck(this, TimeInterval);

      this.value = value;
      this.interval = interval;
    }; //# sourceMappingURL=timeInterval.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/timeout.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/timeout.js ***!
    \*******************************************************************************************************/

  /*! exports provided: timeout */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimeoutJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timeout", function () {
      return timeout;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/TimeoutError */
    "../../node_modules/rxjs/_esm2015/internal/util/TimeoutError.js");
    /* harmony import */


    var _timeoutWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./timeoutWith */
    "../../node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js");
    /* harmony import */


    var _observable_throwError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../observable/throwError */
    "../../node_modules/rxjs/_esm2015/internal/observable/throwError.js");

    function timeout(due) {
      var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
      return Object(_timeoutWith__WEBPACK_IMPORTED_MODULE_2__["timeoutWith"])(due, Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_3__["throwError"])(new _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__["TimeoutError"]()), scheduler);
    } //# sourceMappingURL=timeout.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js ***!
    \***********************************************************************************************************/

  /*! exports provided: timeoutWith */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimeoutWithJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timeoutWith", function () {
      return timeoutWith;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isDate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isDate */
    "../../node_modules/rxjs/_esm2015/internal/util/isDate.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function timeoutWith(due, withObservable) {
      var scheduler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
      return function (source) {
        var absoluteTimeout = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_1__["isDate"])(due);
        var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
      };
    }

    var TimeoutWithOperator = /*#__PURE__*/function () {
      function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        _classCallCheck(this, TimeoutWithOperator);

        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }

      _createClass(TimeoutWithOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
        }
      }]);

      return TimeoutWithOperator;
    }();

    var TimeoutWithSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB25) {
      _inherits(TimeoutWithSubscriber, _OuterSubscriber__WEB25);

      var _super102 = _createSuper(TimeoutWithSubscriber);

      function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this187;

        _classCallCheck(this, TimeoutWithSubscriber);

        _this187 = _super102.call(this, destination);
        _this187.absoluteTimeout = absoluteTimeout;
        _this187.waitFor = waitFor;
        _this187.withObservable = withObservable;
        _this187.scheduler = scheduler;
        _this187.action = null;

        _this187.scheduleTimeout();

        return _this187;
      }

      _createClass(TimeoutWithSubscriber, [{
        key: "scheduleTimeout",
        value: function scheduleTimeout() {
          var action = this.action;

          if (action) {
            this.action = action.schedule(this, this.waitFor);
          } else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
          }
        }
      }, {
        key: "_next",
        value: function _next(value) {
          if (!this.absoluteTimeout) {
            this.scheduleTimeout();
          }

          _get(_getPrototypeOf(TimeoutWithSubscriber.prototype), "_next", this).call(this, value);
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.action = null;
          this.scheduler = null;
          this.withObservable = null;
        }
      }], [{
        key: "dispatchTimeout",
        value: function dispatchTimeout(subscriber) {
          var withObservable = subscriber.withObservable;

          subscriber._unsubscribeAndRecycle();

          subscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(subscriber, withObservable));
        }
      }]);

      return TimeoutWithSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]); //# sourceMappingURL=timeoutWith.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/timestamp.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/timestamp.js ***!
    \*********************************************************************************************************/

  /*! exports provided: timestamp, Timestamp */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimestampJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timestamp", function () {
      return timestamp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Timestamp", function () {
      return Timestamp;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");

    function timestamp() {
      var scheduler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
      return Object(_map__WEBPACK_IMPORTED_MODULE_1__["map"])(function (value) {
        return new Timestamp(value, scheduler.now());
      });
    }

    var Timestamp = function Timestamp(value, timestamp) {
      _classCallCheck(this, Timestamp);

      this.value = value;
      this.timestamp = timestamp;
    }; //# sourceMappingURL=timestamp.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/toArray.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/toArray.js ***!
    \*******************************************************************************************************/

  /*! exports provided: toArray */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsToArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "toArray", function () {
      return toArray;
    });
    /* harmony import */


    var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./reduce */
    "../../node_modules/rxjs/_esm2015/internal/operators/reduce.js");

    function toArrayReducer(arr, item, index) {
      if (index === 0) {
        return [item];
      }

      arr.push(item);
      return arr;
    }

    function toArray() {
      return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(toArrayReducer, []);
    } //# sourceMappingURL=toArray.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/window.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/window.js ***!
    \******************************************************************************************************/

  /*! exports provided: window */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "window", function () {
      return window;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function window(windowBoundaries) {
      return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
      };
    }

    var WindowOperator = /*#__PURE__*/function () {
      function WindowOperator(windowBoundaries) {
        _classCallCheck(this, WindowOperator);

        this.windowBoundaries = windowBoundaries;
      }

      _createClass(WindowOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          var windowSubscriber = new WindowSubscriber(subscriber);
          var sourceSubscription = source.subscribe(windowSubscriber);

          if (!sourceSubscription.closed) {
            windowSubscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(windowSubscriber, this.windowBoundaries));
          }

          return sourceSubscription;
        }
      }]);

      return WindowOperator;
    }();

    var WindowSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB26) {
      _inherits(WindowSubscriber, _OuterSubscriber__WEB26);

      var _super103 = _createSuper(WindowSubscriber);

      function WindowSubscriber(destination) {
        var _this188;

        _classCallCheck(this, WindowSubscriber);

        _this188 = _super103.call(this, destination);
        _this188.window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
        destination.next(_this188.window);
        return _this188;
      }

      _createClass(WindowSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.openWindow();
        }
      }, {
        key: "notifyError",
        value: function notifyError(error, innerSub) {
          this._error(error);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          this._complete();
        }
      }, {
        key: "_next",
        value: function _next(value) {
          this.window.next(value);
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.window.error(err);
          this.destination.error(err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.window.complete();
          this.destination.complete();
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.window = null;
        }
      }, {
        key: "openWindow",
        value: function openWindow() {
          var prevWindow = this.window;

          if (prevWindow) {
            prevWindow.complete();
          }

          var destination = this.destination;
          var newWindow = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
          destination.next(newWindow);
        }
      }]);

      return WindowSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=window.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/windowCount.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/windowCount.js ***!
    \***********************************************************************************************************/

  /*! exports provided: windowCount */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowCount", function () {
      return windowCount;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");

    function windowCount(windowSize) {
      var startWindowEvery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
      };
    }

    var WindowCountOperator = /*#__PURE__*/function () {
      function WindowCountOperator(windowSize, startWindowEvery) {
        _classCallCheck(this, WindowCountOperator);

        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }

      _createClass(WindowCountOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
        }
      }]);

      return WindowCountOperator;
    }();

    var WindowCountSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_46) {
      _inherits(WindowCountSubscriber, _Subscriber__WEBPACK_46);

      var _super104 = _createSuper(WindowCountSubscriber);

      function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this189;

        _classCallCheck(this, WindowCountSubscriber);

        _this189 = _super104.call(this, destination);
        _this189.destination = destination;
        _this189.windowSize = windowSize;
        _this189.startWindowEvery = startWindowEvery;
        _this189.windows = [new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]()];
        _this189.count = 0;
        destination.next(_this189.windows[0]);
        return _this189;
      }

      _createClass(WindowCountSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
          var destination = this.destination;
          var windowSize = this.windowSize;
          var windows = this.windows;
          var len = windows.length;

          for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
          }

          var c = this.count - windowSize + 1;

          if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
          }

          if (++this.count % startWindowEvery === 0 && !this.closed) {
            var _window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();

            windows.push(_window);
            destination.next(_window);
          }
        }
      }, {
        key: "_error",
        value: function _error(err) {
          var windows = this.windows;

          if (windows) {
            while (windows.length > 0 && !this.closed) {
              windows.shift().error(err);
            }
          }

          this.destination.error(err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var windows = this.windows;

          if (windows) {
            while (windows.length > 0 && !this.closed) {
              windows.shift().complete();
            }
          }

          this.destination.complete();
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.count = 0;
          this.windows = null;
        }
      }]);

      return WindowCountSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]); //# sourceMappingURL=windowCount.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/windowTime.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/windowTime.js ***!
    \**********************************************************************************************************/

  /*! exports provided: windowTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowTime", function () {
      return windowTime;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/isNumeric */
    "../../node_modules/rxjs/_esm2015/internal/util/isNumeric.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isScheduler */
    "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function windowTime(windowTimeSpan) {
      var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      var windowCreationInterval = null;
      var maxWindowSize = Number.POSITIVE_INFINITY;

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(arguments[3])) {
        scheduler = arguments[3];
      }

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(arguments[2])) {
        scheduler = arguments[2];
      } else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__["isNumeric"])(arguments[2])) {
        maxWindowSize = arguments[2];
      }

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(arguments[1])) {
        scheduler = arguments[1];
      } else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__["isNumeric"])(arguments[1])) {
        windowCreationInterval = arguments[1];
      }

      return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
      };
    }

    var WindowTimeOperator = /*#__PURE__*/function () {
      function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        _classCallCheck(this, WindowTimeOperator);

        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }

      _createClass(WindowTimeOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
        }
      }]);

      return WindowTimeOperator;
    }();

    var CountedSubject = /*#__PURE__*/function (_Subject__WEBPACK_IMP5) {
      _inherits(CountedSubject, _Subject__WEBPACK_IMP5);

      var _super105 = _createSuper(CountedSubject);

      function CountedSubject() {
        var _this190;

        _classCallCheck(this, CountedSubject);

        _this190 = _super105.apply(this, arguments);
        _this190._numberOfNextedValues = 0;
        return _this190;
      }

      _createClass(CountedSubject, [{
        key: "next",
        value: function next(value) {
          this._numberOfNextedValues++;

          _get(_getPrototypeOf(CountedSubject.prototype), "next", this).call(this, value);
        }
      }, {
        key: "numberOfNextedValues",
        get: function get() {
          return this._numberOfNextedValues;
        }
      }]);

      return CountedSubject;
    }(_Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]);

    var WindowTimeSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_47) {
      _inherits(WindowTimeSubscriber, _Subscriber__WEBPACK_47);

      var _super106 = _createSuper(WindowTimeSubscriber);

      function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this191;

        _classCallCheck(this, WindowTimeSubscriber);

        _this191 = _super106.call(this, destination);
        _this191.destination = destination;
        _this191.windowTimeSpan = windowTimeSpan;
        _this191.windowCreationInterval = windowCreationInterval;
        _this191.maxWindowSize = maxWindowSize;
        _this191.scheduler = scheduler;
        _this191.windows = [];

        var window = _this191.openWindow();

        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          var closeState = {
            subscriber: _assertThisInitialized(_this191),
            window: window,
            context: null
          };
          var creationState = {
            windowTimeSpan: windowTimeSpan,
            windowCreationInterval: windowCreationInterval,
            subscriber: _assertThisInitialized(_this191),
            scheduler: scheduler
          };

          _this191.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));

          _this191.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          var timeSpanOnlyState = {
            subscriber: _assertThisInitialized(_this191),
            window: window,
            windowTimeSpan: windowTimeSpan
          };

          _this191.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }

        return _this191;
      }

      _createClass(WindowTimeSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var windows = this.windows;
          var len = windows.length;

          for (var i = 0; i < len; i++) {
            var _window2 = windows[i];

            if (!_window2.closed) {
              _window2.next(value);

              if (_window2.numberOfNextedValues >= this.maxWindowSize) {
                this.closeWindow(_window2);
              }
            }
          }
        }
      }, {
        key: "_error",
        value: function _error(err) {
          var windows = this.windows;

          while (windows.length > 0) {
            windows.shift().error(err);
          }

          this.destination.error(err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var windows = this.windows;

          while (windows.length > 0) {
            var _window3 = windows.shift();

            if (!_window3.closed) {
              _window3.complete();
            }
          }

          this.destination.complete();
        }
      }, {
        key: "openWindow",
        value: function openWindow() {
          var window = new CountedSubject();
          this.windows.push(window);
          var destination = this.destination;
          destination.next(window);
          return window;
        }
      }, {
        key: "closeWindow",
        value: function closeWindow(window) {
          window.complete();
          var windows = this.windows;
          windows.splice(windows.indexOf(window), 1);
        }
      }]);

      return WindowTimeSubscriber;
    }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]);

    function dispatchWindowTimeSpanOnly(state) {
      var subscriber = state.subscriber,
          windowTimeSpan = state.windowTimeSpan,
          window = state.window;

      if (window) {
        subscriber.closeWindow(window);
      }

      state.window = subscriber.openWindow();
      this.schedule(state, windowTimeSpan);
    }

    function dispatchWindowCreation(state) {
      var windowTimeSpan = state.windowTimeSpan,
          subscriber = state.subscriber,
          scheduler = state.scheduler,
          windowCreationInterval = state.windowCreationInterval;
      var window = subscriber.openWindow();
      var action = this;
      var context = {
        action: action,
        subscription: null
      };
      var timeSpanState = {
        subscriber: subscriber,
        window: window,
        context: context
      };
      context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
      action.add(context.subscription);
      action.schedule(state, windowCreationInterval);
    }

    function dispatchWindowClose(state) {
      var subscriber = state.subscriber,
          window = state.window,
          context = state.context;

      if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
      }

      subscriber.closeWindow(window);
    } //# sourceMappingURL=windowTime.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/windowToggle.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/windowToggle.js ***!
    \************************************************************************************************************/

  /*! exports provided: windowToggle */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowToggleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowToggle", function () {
      return windowToggle;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function windowToggle(openings, closingSelector) {
      return function (source) {
        return source.lift(new WindowToggleOperator(openings, closingSelector));
      };
    }

    var WindowToggleOperator = /*#__PURE__*/function () {
      function WindowToggleOperator(openings, closingSelector) {
        _classCallCheck(this, WindowToggleOperator);

        this.openings = openings;
        this.closingSelector = closingSelector;
      }

      _createClass(WindowToggleOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
        }
      }]);

      return WindowToggleOperator;
    }();

    var WindowToggleSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB27) {
      _inherits(WindowToggleSubscriber, _OuterSubscriber__WEB27);

      var _super107 = _createSuper(WindowToggleSubscriber);

      function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this192;

        _classCallCheck(this, WindowToggleSubscriber);

        _this192 = _super107.call(this, destination);
        _this192.openings = openings;
        _this192.closingSelector = closingSelector;
        _this192.contexts = [];

        _this192.add(_this192.openSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(_assertThisInitialized(_this192), openings, openings));

        return _this192;
      }

      _createClass(WindowToggleSubscriber, [{
        key: "_next",
        value: function _next(value) {
          var contexts = this.contexts;

          if (contexts) {
            var len = contexts.length;

            for (var i = 0; i < len; i++) {
              contexts[i].window.next(value);
            }
          }
        }
      }, {
        key: "_error",
        value: function _error(err) {
          var contexts = this.contexts;
          this.contexts = null;

          if (contexts) {
            var len = contexts.length;
            var index = -1;

            while (++index < len) {
              var context = contexts[index];
              context.window.error(err);
              context.subscription.unsubscribe();
            }
          }

          _get(_getPrototypeOf(WindowToggleSubscriber.prototype), "_error", this).call(this, err);
        }
      }, {
        key: "_complete",
        value: function _complete() {
          var contexts = this.contexts;
          this.contexts = null;

          if (contexts) {
            var len = contexts.length;
            var index = -1;

            while (++index < len) {
              var context = contexts[index];
              context.window.complete();
              context.subscription.unsubscribe();
            }
          }

          _get(_getPrototypeOf(WindowToggleSubscriber.prototype), "_complete", this).call(this);
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var contexts = this.contexts;
          this.contexts = null;

          if (contexts) {
            var len = contexts.length;
            var index = -1;

            while (++index < len) {
              var context = contexts[index];
              context.window.unsubscribe();
              context.subscription.unsubscribe();
            }
          }
        }
      }, {
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          if (outerValue === this.openings) {
            var closingNotifier;

            try {
              var closingSelector = this.closingSelector;
              closingNotifier = closingSelector(innerValue);
            } catch (e) {
              return this.error(e);
            }

            var _window4 = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();

            var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            var context = {
              window: _window4,
              subscription: subscription
            };
            this.contexts.push(context);
            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, closingNotifier, context);

            if (innerSubscription.closed) {
              this.closeWindow(this.contexts.length - 1);
            } else {
              innerSubscription.context = context;
              subscription.add(innerSubscription);
            }

            this.destination.next(_window4);
          } else {
            this.closeWindow(this.contexts.indexOf(outerValue));
          }
        }
      }, {
        key: "notifyError",
        value: function notifyError(err) {
          this.error(err);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(inner) {
          if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
          }
        }
      }, {
        key: "closeWindow",
        value: function closeWindow(index) {
          if (index === -1) {
            return;
          }

          var contexts = this.contexts;
          var context = contexts[index];
          var window = context.window,
              subscription = context.subscription;
          contexts.splice(index, 1);
          window.complete();
          subscription.unsubscribe();
        }
      }]);

      return WindowToggleSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]); //# sourceMappingURL=windowToggle.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/windowWhen.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/windowWhen.js ***!
    \**********************************************************************************************************/

  /*! exports provided: windowWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowWhen", function () {
      return windowWhen;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "../../node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function windowWhen(closingSelector) {
      return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
      };
    }

    var WindowOperator = /*#__PURE__*/function () {
      function WindowOperator(closingSelector) {
        _classCallCheck(this, WindowOperator);

        this.closingSelector = closingSelector;
      }

      _createClass(WindowOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
        }
      }]);

      return WindowOperator;
    }();

    var WindowSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB28) {
      _inherits(WindowSubscriber, _OuterSubscriber__WEB28);

      var _super108 = _createSuper(WindowSubscriber);

      function WindowSubscriber(destination, closingSelector) {
        var _this193;

        _classCallCheck(this, WindowSubscriber);

        _this193 = _super108.call(this, destination);
        _this193.destination = destination;
        _this193.closingSelector = closingSelector;

        _this193.openWindow();

        return _this193;
      }

      _createClass(WindowSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.openWindow(innerSub);
        }
      }, {
        key: "notifyError",
        value: function notifyError(error, innerSub) {
          this._error(error);
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete(innerSub) {
          this.openWindow(innerSub);
        }
      }, {
        key: "_next",
        value: function _next(value) {
          this.window.next(value);
        }
      }, {
        key: "_error",
        value: function _error(err) {
          this.window.error(err);
          this.destination.error(err);
          this.unsubscribeClosingNotification();
        }
      }, {
        key: "_complete",
        value: function _complete() {
          this.window.complete();
          this.destination.complete();
          this.unsubscribeClosingNotification();
        }
      }, {
        key: "unsubscribeClosingNotification",
        value: function unsubscribeClosingNotification() {
          if (this.closingNotification) {
            this.closingNotification.unsubscribe();
          }
        }
      }, {
        key: "openWindow",
        value: function openWindow() {
          var innerSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
          }

          var prevWindow = this.window;

          if (prevWindow) {
            prevWindow.complete();
          }

          var window = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
          this.destination.next(window);
          var closingNotifier;

          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
          } catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
          }

          this.add(this.closingNotification = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, closingNotifier));
        }
      }]);

      return WindowSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]); //# sourceMappingURL=windowWhen.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js ***!
    \**************************************************************************************************************/

  /*! exports provided: withLatestFrom */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWithLatestFromJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "withLatestFrom", function () {
      return withLatestFrom;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function withLatestFrom() {
      for (var _len18 = arguments.length, args = new Array(_len18), _key19 = 0; _key19 < _len18; _key19++) {
        args[_key19] = arguments[_key19];
      }

      return function (source) {
        var project;

        if (typeof args[args.length - 1] === 'function') {
          project = args.pop();
        }

        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
      };
    }

    var WithLatestFromOperator = /*#__PURE__*/function () {
      function WithLatestFromOperator(observables, project) {
        _classCallCheck(this, WithLatestFromOperator);

        this.observables = observables;
        this.project = project;
      }

      _createClass(WithLatestFromOperator, [{
        key: "call",
        value: function call(subscriber, source) {
          return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
        }
      }]);

      return WithLatestFromOperator;
    }();

    var WithLatestFromSubscriber = /*#__PURE__*/function (_OuterSubscriber__WEB29) {
      _inherits(WithLatestFromSubscriber, _OuterSubscriber__WEB29);

      var _super109 = _createSuper(WithLatestFromSubscriber);

      function WithLatestFromSubscriber(destination, observables, project) {
        var _this194;

        _classCallCheck(this, WithLatestFromSubscriber);

        _this194 = _super109.call(this, destination);
        _this194.observables = observables;
        _this194.project = project;
        _this194.toRespond = [];
        var len = observables.length;
        _this194.values = new Array(len);

        for (var i = 0; i < len; i++) {
          _this194.toRespond.push(i);
        }

        for (var _i10 = 0; _i10 < len; _i10++) {
          var observable = observables[_i10];

          _this194.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(_assertThisInitialized(_this194), observable, observable, _i10));
        }

        return _this194;
      }

      _createClass(WithLatestFromSubscriber, [{
        key: "notifyNext",
        value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.values[outerIndex] = innerValue;
          var toRespond = this.toRespond;

          if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);

            if (found !== -1) {
              toRespond.splice(found, 1);
            }
          }
        }
      }, {
        key: "notifyComplete",
        value: function notifyComplete() {}
      }, {
        key: "_next",
        value: function _next(value) {
          if (this.toRespond.length === 0) {
            var args = [value].concat(_toConsumableArray(this.values));

            if (this.project) {
              this._tryProject(args);
            } else {
              this.destination.next(args);
            }
          }
        }
      }, {
        key: "_tryProject",
        value: function _tryProject(args) {
          var result;

          try {
            result = this.project.apply(this, args);
          } catch (err) {
            this.destination.error(err);
            return;
          }

          this.destination.next(result);
        }
      }]);

      return WithLatestFromSubscriber;
    }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"]); //# sourceMappingURL=withLatestFrom.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/zip.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/zip.js ***!
    \***************************************************************************************************/

  /*! exports provided: zip */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsZipJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return zip;
    });
    /* harmony import */


    var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/zip */
    "../../node_modules/rxjs/_esm2015/internal/observable/zip.js");

    function zip() {
      for (var _len19 = arguments.length, observables = new Array(_len19), _key20 = 0; _key20 < _len19; _key20++) {
        observables[_key20] = arguments[_key20];
      }

      return function zipOperatorFunction(source) {
        return source.lift.call(Object(_observable_zip__WEBPACK_IMPORTED_MODULE_0__["zip"]).apply(void 0, [source].concat(observables)));
      };
    } //# sourceMappingURL=zip.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/operators/zipAll.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/operators/zipAll.js ***!
    \******************************************************************************************************/

  /*! exports provided: zipAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsZipAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "zipAll", function () {
      return zipAll;
    });
    /* harmony import */


    var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/zip */
    "../../node_modules/rxjs/_esm2015/internal/observable/zip.js");

    function zipAll(project) {
      return function (source) {
        return source.lift(new _observable_zip__WEBPACK_IMPORTED_MODULE_0__["ZipOperator"](project));
      };
    } //# sourceMappingURL=zipAll.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleArray.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduled/scheduleArray.js ***!
    \*************************************************************************************************************/

  /*! exports provided: scheduleArray */

  /***/
  function node_modulesRxjs_esm2015InternalScheduledScheduleArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scheduleArray", function () {
      return scheduleArray;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");

    function scheduleArray(input, scheduler) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        var i = 0;
        sub.add(scheduler.schedule(function () {
          if (i === input.length) {
            subscriber.complete();
            return;
          }

          subscriber.next(input[i++]);

          if (!subscriber.closed) {
            sub.add(this.schedule());
          }
        }));
        return sub;
      });
    } //# sourceMappingURL=scheduleArray.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleIterable.js":
  /*!****************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduled/scheduleIterable.js ***!
    \****************************************************************************************************************/

  /*! exports provided: scheduleIterable */

  /***/
  function node_modulesRxjs_esm2015InternalScheduledScheduleIterableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scheduleIterable", function () {
      return scheduleIterable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../symbol/iterator */
    "../../node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    function scheduleIterable(input, scheduler) {
      if (!input) {
        throw new Error('Iterable cannot be null');
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        var iterator;
        sub.add(function () {
          if (iterator && typeof iterator["return"] === 'function') {
            iterator["return"]();
          }
        });
        sub.add(scheduler.schedule(function () {
          iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__["iterator"]]();
          sub.add(scheduler.schedule(function () {
            if (subscriber.closed) {
              return;
            }

            var value;
            var done;

            try {
              var result = iterator.next();
              value = result.value;
              done = result.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }

            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
              this.schedule();
            }
          }));
        }));
        return sub;
      });
    } //# sourceMappingURL=scheduleIterable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleObservable.js":
  /*!******************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduled/scheduleObservable.js ***!
    \******************************************************************************************************************/

  /*! exports provided: scheduleObservable */

  /***/
  function node_modulesRxjs_esm2015InternalScheduledScheduleObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scheduleObservable", function () {
      return scheduleObservable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../symbol/observable */
    "../../node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    function scheduleObservable(input, scheduler) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        sub.add(scheduler.schedule(function () {
          var observable = input[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"]]();

          sub.add(observable.subscribe({
            next: function next(value) {
              sub.add(scheduler.schedule(function () {
                return subscriber.next(value);
              }));
            },
            error: function error(err) {
              sub.add(scheduler.schedule(function () {
                return subscriber.error(err);
              }));
            },
            complete: function complete() {
              sub.add(scheduler.schedule(function () {
                return subscriber.complete();
              }));
            }
          }));
        }));
        return sub;
      });
    } //# sourceMappingURL=scheduleObservable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduled/schedulePromise.js":
  /*!***************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduled/schedulePromise.js ***!
    \***************************************************************************************************************/

  /*! exports provided: schedulePromise */

  /***/
  function node_modulesRxjs_esm2015InternalScheduledSchedulePromiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "schedulePromise", function () {
      return schedulePromise;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");

    function schedulePromise(input, scheduler) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        sub.add(scheduler.schedule(function () {
          return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
              subscriber.next(value);
              sub.add(scheduler.schedule(function () {
                return subscriber.complete();
              }));
            }));
          }, function (err) {
            sub.add(scheduler.schedule(function () {
              return subscriber.error(err);
            }));
          });
        }));
        return sub;
      });
    } //# sourceMappingURL=schedulePromise.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduled.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduled/scheduled.js ***!
    \*********************************************************************************************************/

  /*! exports provided: scheduled */

  /***/
  function node_modulesRxjs_esm2015InternalScheduledScheduledJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scheduled", function () {
      return scheduled;
    });
    /* harmony import */


    var _scheduleObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./scheduleObservable */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleObservable.js");
    /* harmony import */


    var _schedulePromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./schedulePromise */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/schedulePromise.js");
    /* harmony import */


    var _scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./scheduleArray */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleArray.js");
    /* harmony import */


    var _scheduleIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./scheduleIterable */
    "../../node_modules/rxjs/_esm2015/internal/scheduled/scheduleIterable.js");
    /* harmony import */


    var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isInteropObservable */
    "../../node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js");
    /* harmony import */


    var _util_isPromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/isPromise */
    "../../node_modules/rxjs/_esm2015/internal/util/isPromise.js");
    /* harmony import */


    var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ../util/isArrayLike */
    "../../node_modules/rxjs/_esm2015/internal/util/isArrayLike.js");
    /* harmony import */


    var _util_isIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ../util/isIterable */
    "../../node_modules/rxjs/_esm2015/internal/util/isIterable.js");

    function scheduled(input, scheduler) {
      if (input != null) {
        if (Object(_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_4__["isInteropObservable"])(input)) {
          return Object(_scheduleObservable__WEBPACK_IMPORTED_MODULE_0__["scheduleObservable"])(input, scheduler);
        } else if (Object(_util_isPromise__WEBPACK_IMPORTED_MODULE_5__["isPromise"])(input)) {
          return Object(_schedulePromise__WEBPACK_IMPORTED_MODULE_1__["schedulePromise"])(input, scheduler);
        } else if (Object(_util_isArrayLike__WEBPACK_IMPORTED_MODULE_6__["isArrayLike"])(input)) {
          return Object(_scheduleArray__WEBPACK_IMPORTED_MODULE_2__["scheduleArray"])(input, scheduler);
        } else if (Object(_util_isIterable__WEBPACK_IMPORTED_MODULE_7__["isIterable"])(input) || typeof input === 'string') {
          return Object(_scheduleIterable__WEBPACK_IMPORTED_MODULE_3__["scheduleIterable"])(input, scheduler);
        }
      }

      throw new TypeError((input !== null && typeof input || input) + ' is not observable');
    } //# sourceMappingURL=scheduled.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/Action.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/Action.js ***!
    \******************************************************************************************************/

  /*! exports provided: Action */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Action", function () {
      return Action;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscription */
    "../../node_modules/rxjs/_esm2015/internal/Subscription.js");

    var Action = /*#__PURE__*/function (_Subscription__WEBPAC4) {
      _inherits(Action, _Subscription__WEBPAC4);

      var _super110 = _createSuper(Action);

      function Action(scheduler, work) {
        _classCallCheck(this, Action);

        return _super110.call(this);
      }

      _createClass(Action, [{
        key: "schedule",
        value: function schedule(state) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return this;
        }
      }]);

      return Action;
    }(_Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"]); //# sourceMappingURL=Action.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js ***!
    \**********************************************************************************************************/

  /*! exports provided: AsapAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsapActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsapAction", function () {
      return AsapAction;
    });
    /* harmony import */


    var _util_Immediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/Immediate */
    "../../node_modules/rxjs/_esm2015/internal/util/Immediate.js");
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsyncAction */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");

    var AsapAction = /*#__PURE__*/function (_AsyncAction__WEBPACK) {
      _inherits(AsapAction, _AsyncAction__WEBPACK);

      var _super111 = _createSuper(AsapAction);

      function AsapAction(scheduler, work) {
        var _this195;

        _classCallCheck(this, AsapAction);

        _this195 = _super111.call(this, scheduler, work);
        _this195.scheduler = scheduler;
        _this195.work = work;
        return _this195;
      }

      _createClass(AsapAction, [{
        key: "requestAsyncId",
        value: function requestAsyncId(scheduler, id) {
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          if (delay !== null && delay > 0) {
            return _get(_getPrototypeOf(AsapAction.prototype), "requestAsyncId", this).call(this, scheduler, id, delay);
          }

          scheduler.actions.push(this);
          return scheduler.scheduled || (scheduler.scheduled = _util_Immediate__WEBPACK_IMPORTED_MODULE_0__["Immediate"].setImmediate(scheduler.flush.bind(scheduler, null)));
        }
      }, {
        key: "recycleAsyncId",
        value: function recycleAsyncId(scheduler, id) {
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _get(_getPrototypeOf(AsapAction.prototype), "recycleAsyncId", this).call(this, scheduler, id, delay);
          }

          if (scheduler.actions.length === 0) {
            _util_Immediate__WEBPACK_IMPORTED_MODULE_0__["Immediate"].clearImmediate(id);

            scheduler.scheduled = undefined;
          }

          return undefined;
        }
      }]);

      return AsapAction;
    }(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]); //# sourceMappingURL=AsapAction.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js ***!
    \*************************************************************************************************************/

  /*! exports provided: AsapScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsapSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsapScheduler", function () {
      return AsapScheduler;
    });
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    var AsapScheduler = /*#__PURE__*/function (_AsyncScheduler__WEBP) {
      _inherits(AsapScheduler, _AsyncScheduler__WEBP);

      var _super112 = _createSuper(AsapScheduler);

      function AsapScheduler() {
        _classCallCheck(this, AsapScheduler);

        return _super112.apply(this, arguments);
      }

      _createClass(AsapScheduler, [{
        key: "flush",
        value: function flush(action) {
          this.active = true;
          this.scheduled = undefined;
          var actions = this.actions;
          var error;
          var index = -1;
          var count = actions.length;
          action = action || actions.shift();

          do {
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          } while (++index < count && (action = actions.shift()));

          this.active = false;

          if (error) {
            while (++index < count && (action = actions.shift())) {
              action.unsubscribe();
            }

            throw error;
          }
        }
      }]);

      return AsapScheduler;
    }(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__["AsyncScheduler"]); //# sourceMappingURL=AsapScheduler.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js ***!
    \***********************************************************************************************************/

  /*! exports provided: AsyncAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsyncActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsyncAction", function () {
      return AsyncAction;
    });
    /* harmony import */


    var _Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Action */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/Action.js");

    var AsyncAction = /*#__PURE__*/function (_Action__WEBPACK_IMPO) {
      _inherits(AsyncAction, _Action__WEBPACK_IMPO);

      var _super113 = _createSuper(AsyncAction);

      function AsyncAction(scheduler, work) {
        var _this196;

        _classCallCheck(this, AsyncAction);

        _this196 = _super113.call(this, scheduler, work);
        _this196.scheduler = scheduler;
        _this196.work = work;
        _this196.pending = false;
        return _this196;
      }

      _createClass(AsyncAction, [{
        key: "schedule",
        value: function schedule(state) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          if (this.closed) {
            return this;
          }

          this.state = state;
          var id = this.id;
          var scheduler = this.scheduler;

          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
          }

          this.pending = true;
          this.delay = delay;
          this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
          return this;
        }
      }, {
        key: "requestAsyncId",
        value: function requestAsyncId(scheduler, id) {
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          return setInterval(scheduler.flush.bind(scheduler, this), delay);
        }
      }, {
        key: "recycleAsyncId",
        value: function recycleAsyncId(scheduler, id) {
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
          }

          clearInterval(id);
          return undefined;
        }
      }, {
        key: "execute",
        value: function execute(state, delay) {
          if (this.closed) {
            return new Error('executing a cancelled action');
          }

          this.pending = false;

          var error = this._execute(state, delay);

          if (error) {
            return error;
          } else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
        }
      }, {
        key: "_execute",
        value: function _execute(state, delay) {
          var errored = false;
          var errorValue = undefined;

          try {
            this.work(state);
          } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
          }

          if (errored) {
            this.unsubscribe();
            return errorValue;
          }
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          var id = this.id;
          var scheduler = this.scheduler;
          var actions = scheduler.actions;
          var index = actions.indexOf(this);
          this.work = null;
          this.state = null;
          this.pending = false;
          this.scheduler = null;

          if (index !== -1) {
            actions.splice(index, 1);
          }

          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }

          this.delay = null;
        }
      }]);

      return AsyncAction;
    }(_Action__WEBPACK_IMPORTED_MODULE_0__["Action"]); //# sourceMappingURL=AsyncAction.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js ***!
    \**************************************************************************************************************/

  /*! exports provided: AsyncScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsyncSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsyncScheduler", function () {
      return AsyncScheduler;
    });
    /* harmony import */


    var _Scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Scheduler */
    "../../node_modules/rxjs/_esm2015/internal/Scheduler.js");

    var AsyncScheduler = /*#__PURE__*/function (_Scheduler__WEBPACK_I) {
      _inherits(AsyncScheduler, _Scheduler__WEBPACK_I);

      var _super114 = _createSuper(AsyncScheduler);

      function AsyncScheduler(SchedulerAction) {
        var _this197;

        var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Scheduler__WEBPACK_IMPORTED_MODULE_0__["Scheduler"].now;

        _classCallCheck(this, AsyncScheduler);

        _this197 = _super114.call(this, SchedulerAction, function () {
          if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _assertThisInitialized(_this197)) {
            return AsyncScheduler.delegate.now();
          } else {
            return now();
          }
        });
        _this197.actions = [];
        _this197.active = false;
        _this197.scheduled = undefined;
        return _this197;
      }

      _createClass(AsyncScheduler, [{
        key: "schedule",
        value: function schedule(work) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var state = arguments.length > 2 ? arguments[2] : undefined;

          if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
          } else {
            return _get(_getPrototypeOf(AsyncScheduler.prototype), "schedule", this).call(this, work, delay, state);
          }
        }
      }, {
        key: "flush",
        value: function flush(action) {
          var actions = this.actions;

          if (this.active) {
            actions.push(action);
            return;
          }

          var error;
          this.active = true;

          do {
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          } while (action = actions.shift());

          this.active = false;

          if (error) {
            while (action = actions.shift()) {
              action.unsubscribe();
            }

            throw error;
          }
        }
      }]);

      return AsyncScheduler;
    }(_Scheduler__WEBPACK_IMPORTED_MODULE_0__["Scheduler"]); //# sourceMappingURL=AsyncScheduler.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js ***!
    \***********************************************************************************************************/

  /*! exports provided: QueueAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerQueueActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "QueueAction", function () {
      return QueueAction;
    });
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncAction */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");

    var QueueAction = /*#__PURE__*/function (_AsyncAction__WEBPACK2) {
      _inherits(QueueAction, _AsyncAction__WEBPACK2);

      var _super115 = _createSuper(QueueAction);

      function QueueAction(scheduler, work) {
        var _this198;

        _classCallCheck(this, QueueAction);

        _this198 = _super115.call(this, scheduler, work);
        _this198.scheduler = scheduler;
        _this198.work = work;
        return _this198;
      }

      _createClass(QueueAction, [{
        key: "schedule",
        value: function schedule(state) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          if (delay > 0) {
            return _get(_getPrototypeOf(QueueAction.prototype), "schedule", this).call(this, state, delay);
          }

          this.delay = delay;
          this.state = state;
          this.scheduler.flush(this);
          return this;
        }
      }, {
        key: "execute",
        value: function execute(state, delay) {
          return delay > 0 || this.closed ? _get(_getPrototypeOf(QueueAction.prototype), "execute", this).call(this, state, delay) : this._execute(state, delay);
        }
      }, {
        key: "requestAsyncId",
        value: function requestAsyncId(scheduler, id) {
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _get(_getPrototypeOf(QueueAction.prototype), "requestAsyncId", this).call(this, scheduler, id, delay);
          }

          return scheduler.flush(this);
        }
      }]);

      return QueueAction;
    }(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"]); //# sourceMappingURL=QueueAction.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js ***!
    \**************************************************************************************************************/

  /*! exports provided: QueueScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerQueueSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "QueueScheduler", function () {
      return QueueScheduler;
    });
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    var QueueScheduler = /*#__PURE__*/function (_AsyncScheduler__WEBP2) {
      _inherits(QueueScheduler, _AsyncScheduler__WEBP2);

      var _super116 = _createSuper(QueueScheduler);

      function QueueScheduler() {
        _classCallCheck(this, QueueScheduler);

        return _super116.apply(this, arguments);
      }

      return QueueScheduler;
    }(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__["AsyncScheduler"]); //# sourceMappingURL=QueueScheduler.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/asap.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/asap.js ***!
    \****************************************************************************************************/

  /*! exports provided: asap */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "asap", function () {
      return asap;
    });
    /* harmony import */


    var _AsapAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsapAction */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js");
    /* harmony import */


    var _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsapScheduler */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js");

    var asap = new _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__["AsapScheduler"](_AsapAction__WEBPACK_IMPORTED_MODULE_0__["AsapAction"]); //# sourceMappingURL=asap.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/async.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/async.js ***!
    \*****************************************************************************************************/

  /*! exports provided: async */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsyncJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "async", function () {
      return async;
    });
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncAction */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    var async = new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"](_AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"]); //# sourceMappingURL=async.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/scheduler/queue.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/scheduler/queue.js ***!
    \*****************************************************************************************************/

  /*! exports provided: queue */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerQueueJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "queue", function () {
      return queue;
    });
    /* harmony import */


    var _QueueAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./QueueAction */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js");
    /* harmony import */


    var _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./QueueScheduler */
    "../../node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js");

    var queue = new _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__["QueueScheduler"](_QueueAction__WEBPACK_IMPORTED_MODULE_0__["QueueAction"]); //# sourceMappingURL=queue.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/symbol/iterator.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/symbol/iterator.js ***!
    \*****************************************************************************************************/

  /*! exports provided: getSymbolIterator, iterator, $$iterator */

  /***/
  function node_modulesRxjs_esm2015InternalSymbolIteratorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getSymbolIterator", function () {
      return getSymbolIterator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "iterator", function () {
      return iterator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "$$iterator", function () {
      return $$iterator;
    });

    function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
      }

      return Symbol.iterator;
    }

    var iterator = getSymbolIterator();
    var $$iterator = iterator; //# sourceMappingURL=iterator.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/symbol/observable.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/symbol/observable.js ***!
    \*******************************************************************************************************/

  /*! exports provided: observable */

  /***/
  function node_modulesRxjs_esm2015InternalSymbolObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "observable", function () {
      return observable;
    });

    var observable = function () {
      return typeof Symbol === 'function' && Symbol.observable || '@@observable';
    }(); //# sourceMappingURL=observable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js ***!
    \*********************************************************************************************************/

  /*! exports provided: rxSubscriber, $$rxSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalSymbolRxSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rxSubscriber", function () {
      return rxSubscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "$$rxSubscriber", function () {
      return $$rxSubscriber;
    });

    var rxSubscriber = function () {
      return typeof Symbol === 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random();
    }();

    var $$rxSubscriber = rxSubscriber; //# sourceMappingURL=rxSubscriber.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js":
  /*!******************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js ***!
    \******************************************************************************************************************/

  /*! exports provided: ArgumentOutOfRangeError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilArgumentOutOfRangeErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function () {
      return ArgumentOutOfRangeError;
    });

    var ArgumentOutOfRangeErrorImpl = function () {
      function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
      }

      ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl;
    }();

    var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl; //# sourceMappingURL=ArgumentOutOfRangeError.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/EmptyError.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/EmptyError.js ***!
    \*****************************************************************************************************/

  /*! exports provided: EmptyError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilEmptyErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmptyError", function () {
      return EmptyError;
    });

    var EmptyErrorImpl = function () {
      function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
      }

      EmptyErrorImpl.prototype = Object.create(Error.prototype);
      return EmptyErrorImpl;
    }();

    var EmptyError = EmptyErrorImpl; //# sourceMappingURL=EmptyError.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/Immediate.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/Immediate.js ***!
    \****************************************************************************************************/

  /*! exports provided: Immediate, TestTools */

  /***/
  function node_modulesRxjs_esm2015InternalUtilImmediateJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Immediate", function () {
      return Immediate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TestTools", function () {
      return TestTools;
    });

    var nextHandle = 1;

    var RESOLVED = function () {
      return Promise.resolve();
    }();

    var activeHandles = {};

    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }

      return false;
    }

    var Immediate = {
      setImmediate: function setImmediate(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function clearImmediate(handle) {
        findAndClearHandle(handle);
      }
    };
    var TestTools = {
      pending: function pending() {
        return Object.keys(activeHandles).length;
      }
    }; //# sourceMappingURL=Immediate.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js":
  /*!******************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js ***!
    \******************************************************************************************************************/

  /*! exports provided: ObjectUnsubscribedError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilObjectUnsubscribedErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function () {
      return ObjectUnsubscribedError;
    });

    var ObjectUnsubscribedErrorImpl = function () {
      function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
      }

      ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl;
    }();

    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl; //# sourceMappingURL=ObjectUnsubscribedError.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/TimeoutError.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/TimeoutError.js ***!
    \*******************************************************************************************************/

  /*! exports provided: TimeoutError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilTimeoutErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeoutError", function () {
      return TimeoutError;
    });

    var TimeoutErrorImpl = function () {
      function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
      }

      TimeoutErrorImpl.prototype = Object.create(Error.prototype);
      return TimeoutErrorImpl;
    }();

    var TimeoutError = TimeoutErrorImpl; //# sourceMappingURL=TimeoutError.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js ***!
    \**************************************************************************************************************/

  /*! exports provided: UnsubscriptionError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilUnsubscriptionErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function () {
      return UnsubscriptionError;
    });

    var UnsubscriptionErrorImpl = function () {
      function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ? "".concat(errors.length, " errors occurred during unsubscription:\n").concat(errors.map(function (err, i) {
          return "".concat(i + 1, ") ").concat(err.toString());
        }).join('\n  ')) : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
      }

      UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl;
    }();

    var UnsubscriptionError = UnsubscriptionErrorImpl; //# sourceMappingURL=UnsubscriptionError.js.map

    /***/
  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/canReportError.js":
  /*!*********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/canReportError.js ***!
    \*********************************************************************************************************/

  /*! exports provided: canReportError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilCanReportErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "canReportError", function () {
      return canReportError;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function canReportError(observer) {
      while (observer) {
        var _observer = observer,
            closed = _observer.closed,
            destination = _observer.destination,
            isStopped = _observer.isStopped;

        if (closed || isStopped) {
          return false;
        } else if (destination && destination instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
          observer = destination;
        } else {
          observer = null;
        }
      }

      return true;
    } //# sourceMappingURL=canReportError.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/hostReportError.js":
  /*!**********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/hostReportError.js ***!
    \**********************************************************************************************************/

  /*! exports provided: hostReportError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilHostReportErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "hostReportError", function () {
      return hostReportError;
    });

    function hostReportError(err) {
      setTimeout(function () {
        throw err;
      }, 0);
    } //# sourceMappingURL=hostReportError.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/identity.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/identity.js ***!
    \***************************************************************************************************/

  /*! exports provided: identity */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIdentityJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "identity", function () {
      return identity;
    });

    function identity(x) {
      return x;
    } //# sourceMappingURL=identity.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isArray.js":
  /*!**************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isArray.js ***!
    \**************************************************************************************************/

  /*! exports provided: isArray */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isArray", function () {
      return isArray;
    });

    var isArray = function () {
      return Array.isArray || function (x) {
        return x && typeof x.length === 'number';
      };
    }(); //# sourceMappingURL=isArray.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isArrayLike.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isArrayLike.js ***!
    \******************************************************************************************************/

  /*! exports provided: isArrayLike */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsArrayLikeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isArrayLike", function () {
      return isArrayLike;
    });

    var isArrayLike = function isArrayLike(x) {
      return x && typeof x.length === 'number' && typeof x !== 'function';
    }; //# sourceMappingURL=isArrayLike.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isDate.js":
  /*!*************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isDate.js ***!
    \*************************************************************************************************/

  /*! exports provided: isDate */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsDateJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isDate", function () {
      return isDate;
    });

    function isDate(value) {
      return value instanceof Date && !isNaN(+value);
    } //# sourceMappingURL=isDate.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isFunction.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isFunction.js ***!
    \*****************************************************************************************************/

  /*! exports provided: isFunction */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsFunctionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isFunction", function () {
      return isFunction;
    });

    function isFunction(x) {
      return typeof x === 'function';
    } //# sourceMappingURL=isFunction.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js ***!
    \**************************************************************************************************************/

  /*! exports provided: isInteropObservable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsInteropObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isInteropObservable", function () {
      return isInteropObservable;
    });
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/observable */
    "../../node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    function isInteropObservable(input) {
      return input && typeof input[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]] === 'function';
    } //# sourceMappingURL=isInteropObservable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isIterable.js":
  /*!*****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isIterable.js ***!
    \*****************************************************************************************************/

  /*! exports provided: isIterable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsIterableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isIterable", function () {
      return isIterable;
    });
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/iterator */
    "../../node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    function isIterable(input) {
      return input && typeof input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]] === 'function';
    } //# sourceMappingURL=isIterable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isNumeric.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isNumeric.js ***!
    \****************************************************************************************************/

  /*! exports provided: isNumeric */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsNumericJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isNumeric", function () {
      return isNumeric;
    });
    /* harmony import */


    var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./isArray */
    "../../node_modules/rxjs/_esm2015/internal/util/isArray.js");

    function isNumeric(val) {
      return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(val) && val - parseFloat(val) + 1 >= 0;
    } //# sourceMappingURL=isNumeric.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isObject.js":
  /*!***************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isObject.js ***!
    \***************************************************************************************************/

  /*! exports provided: isObject */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsObjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isObject", function () {
      return isObject;
    });

    function isObject(x) {
      return x !== null && typeof x === 'object';
    } //# sourceMappingURL=isObject.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isPromise.js":
  /*!****************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isPromise.js ***!
    \****************************************************************************************************/

  /*! exports provided: isPromise */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsPromiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isPromise", function () {
      return isPromise;
    });

    function isPromise(value) {
      return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    } //# sourceMappingURL=isPromise.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/isScheduler.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/isScheduler.js ***!
    \******************************************************************************************************/

  /*! exports provided: isScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isScheduler", function () {
      return isScheduler;
    });

    function isScheduler(value) {
      return value && typeof value.schedule === 'function';
    } //# sourceMappingURL=isScheduler.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/noop.js":
  /*!***********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/noop.js ***!
    \***********************************************************************************************/

  /*! exports provided: noop */

  /***/
  function node_modulesRxjs_esm2015InternalUtilNoopJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "noop", function () {
      return noop;
    });

    function noop() {} //# sourceMappingURL=noop.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/not.js":
  /*!**********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/not.js ***!
    \**********************************************************************************************/

  /*! exports provided: not */

  /***/
  function node_modulesRxjs_esm2015InternalUtilNotJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "not", function () {
      return not;
    });

    function not(pred, thisArg) {
      function notPred() {
        return !notPred.pred.apply(notPred.thisArg, arguments);
      }

      notPred.pred = pred;
      notPred.thisArg = thisArg;
      return notPred;
    } //# sourceMappingURL=not.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/pipe.js":
  /*!***********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/pipe.js ***!
    \***********************************************************************************************/

  /*! exports provided: pipe, pipeFromArray */

  /***/
  function node_modulesRxjs_esm2015InternalUtilPipeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pipe", function () {
      return pipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pipeFromArray", function () {
      return pipeFromArray;
    });
    /* harmony import */


    var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./noop */
    "../../node_modules/rxjs/_esm2015/internal/util/noop.js");

    function pipe() {
      for (var _len20 = arguments.length, fns = new Array(_len20), _key21 = 0; _key21 < _len20; _key21++) {
        fns[_key21] = arguments[_key21];
      }

      return pipeFromArray(fns);
    }

    function pipeFromArray(fns) {
      if (!fns) {
        return _noop__WEBPACK_IMPORTED_MODULE_0__["noop"];
      }

      if (fns.length === 1) {
        return fns[0];
      }

      return function piped(input) {
        return fns.reduce(function (prev, fn) {
          return fn(prev);
        }, input);
      };
    } //# sourceMappingURL=pipe.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/subscribeTo.js":
  /*!******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/subscribeTo.js ***!
    \******************************************************************************************************/

  /*! exports provided: subscribeTo */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeTo", function () {
      return subscribeTo;
    });
    /* harmony import */


    var _subscribeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./subscribeToArray */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js");
    /* harmony import */


    var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./subscribeToPromise */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js");
    /* harmony import */


    var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./subscribeToIterable */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js");
    /* harmony import */


    var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./subscribeToObservable */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js");
    /* harmony import */


    var _isArrayLike__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./isArrayLike */
    "../../node_modules/rxjs/_esm2015/internal/util/isArrayLike.js");
    /* harmony import */


    var _isPromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./isPromise */
    "../../node_modules/rxjs/_esm2015/internal/util/isPromise.js");
    /* harmony import */


    var _isObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./isObject */
    "../../node_modules/rxjs/_esm2015/internal/util/isObject.js");
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ../symbol/iterator */
    "../../node_modules/rxjs/_esm2015/internal/symbol/iterator.js");
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ../symbol/observable */
    "../../node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    var subscribeTo = function subscribeTo(result) {
      if (!!result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_8__["observable"]] === 'function') {
        return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__["subscribeToObservable"])(result);
      } else if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_4__["isArrayLike"])(result)) {
        return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_0__["subscribeToArray"])(result);
      } else if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_5__["isPromise"])(result)) {
        return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_1__["subscribeToPromise"])(result);
      } else if (!!result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_7__["iterator"]] === 'function') {
        return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_2__["subscribeToIterable"])(result);
      } else {
        var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_6__["isObject"])(result) ? 'an invalid object' : "'".concat(result, "'");
        var msg = "You provided ".concat(value, " where a stream was expected.") + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
      }
    }; //# sourceMappingURL=subscribeTo.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js":
  /*!***********************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js ***!
    \***********************************************************************************************************/

  /*! exports provided: subscribeToArray */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToArray", function () {
      return subscribeToArray;
    });

    var subscribeToArray = function subscribeToArray(array) {
      return function (subscriber) {
        for (var i = 0, _len21 = array.length; i < _len21 && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }

        subscriber.complete();
      };
    }; //# sourceMappingURL=subscribeToArray.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js":
  /*!**************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js ***!
    \**************************************************************************************************************/

  /*! exports provided: subscribeToIterable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToIterableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToIterable", function () {
      return subscribeToIterable;
    });
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/iterator */
    "../../node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    var subscribeToIterable = function subscribeToIterable(iterable) {
      return function (subscriber) {
        var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]]();

        do {
          var item = iterator.next();

          if (item.done) {
            subscriber.complete();
            break;
          }

          subscriber.next(item.value);

          if (subscriber.closed) {
            break;
          }
        } while (true);

        if (typeof iterator["return"] === 'function') {
          subscriber.add(function () {
            if (iterator["return"]) {
              iterator["return"]();
            }
          });
        }

        return subscriber;
      };
    }; //# sourceMappingURL=subscribeToIterable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js":
  /*!****************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js ***!
    \****************************************************************************************************************/

  /*! exports provided: subscribeToObservable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToObservable", function () {
      return subscribeToObservable;
    });
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/observable */
    "../../node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    var subscribeToObservable = function subscribeToObservable(obj) {
      return function (subscriber) {
        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]]();

        if (typeof obs.subscribe !== 'function') {
          throw new TypeError('Provided object does not correctly implement Symbol.observable');
        } else {
          return obs.subscribe(subscriber);
        }
      };
    }; //# sourceMappingURL=subscribeToObservable.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js":
  /*!*************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js ***!
    \*************************************************************************************************************/

  /*! exports provided: subscribeToPromise */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToPromiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToPromise", function () {
      return subscribeToPromise;
    });
    /* harmony import */


    var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./hostReportError */
    "../../node_modules/rxjs/_esm2015/internal/util/hostReportError.js");

    var subscribeToPromise = function subscribeToPromise(promise) {
      return function (subscriber) {
        promise.then(function (value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function (err) {
          return subscriber.error(err);
        }).then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__["hostReportError"]);
        return subscriber;
      };
    }; //# sourceMappingURL=subscribeToPromise.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js":
  /*!************************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js ***!
    \************************************************************************************************************/

  /*! exports provided: subscribeToResult */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToResultJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToResult", function () {
      return subscribeToResult;
    });
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./subscribeTo */
    "../../node_modules/rxjs/_esm2015/internal/util/subscribeTo.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Observable */
    "../../node_modules/rxjs/_esm2015/internal/Observable.js");

    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
      var innerSubscriber = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__["InnerSubscriber"](outerSubscriber, outerValue, outerIndex);

      if (innerSubscriber.closed) {
        return undefined;
      }

      if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]) {
        return result.subscribe(innerSubscriber);
      }

      return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(result)(innerSubscriber);
    } //# sourceMappingURL=subscribeToResult.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/internal/util/toSubscriber.js":
  /*!*******************************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/internal/util/toSubscriber.js ***!
    \*******************************************************************************************************/

  /*! exports provided: toSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalUtilToSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "toSubscriber", function () {
      return toSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "../../node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../symbol/rxSubscriber */
    "../../node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js");
    /* harmony import */


    var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Observer */
    "../../node_modules/rxjs/_esm2015/internal/Observer.js");

    function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
        if (nextOrObserver instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
          return nextOrObserver;
        }

        if (nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]) {
          return nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]();
        }
      }

      if (!nextOrObserver && !error && !complete) {
        return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](_Observer__WEBPACK_IMPORTED_MODULE_2__["empty"]);
      }

      return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](nextOrObserver, error, complete);
    } //# sourceMappingURL=toSubscriber.js.map

    /***/

  },

  /***/
  "../../node_modules/rxjs/_esm2015/operators/index.js":
  /*!********************************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/rxjs/_esm2015/operators/index.js ***!
    \********************************************************************************************/

  /*! exports provided: audit, auditTime, buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, catchError, combineAll, combineLatest, concat, concatAll, concatMap, concatMapTo, count, debounce, debounceTime, defaultIfEmpty, delay, delayWhen, dematerialize, distinct, distinctUntilChanged, distinctUntilKeyChanged, elementAt, endWith, every, exhaust, exhaustMap, expand, filter, finalize, find, findIndex, first, groupBy, ignoreElements, isEmpty, last, map, mapTo, materialize, max, merge, mergeAll, mergeMap, flatMap, mergeMapTo, mergeScan, min, multicast, observeOn, onErrorResumeNext, pairwise, partition, pluck, publish, publishBehavior, publishLast, publishReplay, race, reduce, repeat, repeatWhen, retry, retryWhen, refCount, sample, sampleTime, scan, sequenceEqual, share, shareReplay, single, skip, skipLast, skipUntil, skipWhile, startWith, subscribeOn, switchAll, switchMap, switchMapTo, take, takeLast, takeUntil, takeWhile, tap, throttle, throttleTime, throwIfEmpty, timeInterval, timeout, timeoutWith, timestamp, toArray, window, windowCount, windowTime, windowToggle, windowWhen, withLatestFrom, zip, zipAll */

  /***/
  function node_modulesRxjs_esm2015OperatorsIndexJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../internal/operators/audit */
    "../../node_modules/rxjs/_esm2015/internal/operators/audit.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "audit", function () {
      return _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__["audit"];
    });
    /* harmony import */


    var _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../internal/operators/auditTime */
    "../../node_modules/rxjs/_esm2015/internal/operators/auditTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "auditTime", function () {
      return _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__["auditTime"];
    });
    /* harmony import */


    var _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../internal/operators/buffer */
    "../../node_modules/rxjs/_esm2015/internal/operators/buffer.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "buffer", function () {
      return _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__["buffer"];
    });
    /* harmony import */


    var _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../internal/operators/bufferCount */
    "../../node_modules/rxjs/_esm2015/internal/operators/bufferCount.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferCount", function () {
      return _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__["bufferCount"];
    });
    /* harmony import */


    var _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../internal/operators/bufferTime */
    "../../node_modules/rxjs/_esm2015/internal/operators/bufferTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferTime", function () {
      return _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__["bufferTime"];
    });
    /* harmony import */


    var _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../internal/operators/bufferToggle */
    "../../node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferToggle", function () {
      return _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__["bufferToggle"];
    });
    /* harmony import */


    var _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ../internal/operators/bufferWhen */
    "../../node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferWhen", function () {
      return _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__["bufferWhen"];
    });
    /* harmony import */


    var _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ../internal/operators/catchError */
    "../../node_modules/rxjs/_esm2015/internal/operators/catchError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "catchError", function () {
      return _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__["catchError"];
    });
    /* harmony import */


    var _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ../internal/operators/combineAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/combineAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "combineAll", function () {
      return _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__["combineAll"];
    });
    /* harmony import */


    var _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ../internal/operators/combineLatest */
    "../../node_modules/rxjs/_esm2015/internal/operators/combineLatest.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__["combineLatest"];
    });
    /* harmony import */


    var _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! ../internal/operators/concat */
    "../../node_modules/rxjs/_esm2015/internal/operators/concat.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__["concat"];
    });
    /* harmony import */


    var _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! ../internal/operators/concatAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/concatAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concatAll", function () {
      return _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__["concatAll"];
    });
    /* harmony import */


    var _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! ../internal/operators/concatMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/concatMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concatMap", function () {
      return _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__["concatMap"];
    });
    /* harmony import */


    var _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! ../internal/operators/concatMapTo */
    "../../node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concatMapTo", function () {
      return _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__["concatMapTo"];
    });
    /* harmony import */


    var _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! ../internal/operators/count */
    "../../node_modules/rxjs/_esm2015/internal/operators/count.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "count", function () {
      return _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__["count"];
    });
    /* harmony import */


    var _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! ../internal/operators/debounce */
    "../../node_modules/rxjs/_esm2015/internal/operators/debounce.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "debounce", function () {
      return _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__["debounce"];
    });
    /* harmony import */


    var _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! ../internal/operators/debounceTime */
    "../../node_modules/rxjs/_esm2015/internal/operators/debounceTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "debounceTime", function () {
      return _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__["debounceTime"];
    });
    /* harmony import */


    var _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! ../internal/operators/defaultIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function () {
      return _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__["defaultIfEmpty"];
    });
    /* harmony import */


    var _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! ../internal/operators/delay */
    "../../node_modules/rxjs/_esm2015/internal/operators/delay.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "delay", function () {
      return _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__["delay"];
    });
    /* harmony import */


    var _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! ../internal/operators/delayWhen */
    "../../node_modules/rxjs/_esm2015/internal/operators/delayWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "delayWhen", function () {
      return _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__["delayWhen"];
    });
    /* harmony import */


    var _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! ../internal/operators/dematerialize */
    "../../node_modules/rxjs/_esm2015/internal/operators/dematerialize.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "dematerialize", function () {
      return _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__["dematerialize"];
    });
    /* harmony import */


    var _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! ../internal/operators/distinct */
    "../../node_modules/rxjs/_esm2015/internal/operators/distinct.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "distinct", function () {
      return _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__["distinct"];
    });
    /* harmony import */


    var _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! ../internal/operators/distinctUntilChanged */
    "../../node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function () {
      return _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"];
    });
    /* harmony import */


    var _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! ../internal/operators/distinctUntilKeyChanged */
    "../../node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function () {
      return _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__["distinctUntilKeyChanged"];
    });
    /* harmony import */


    var _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! ../internal/operators/elementAt */
    "../../node_modules/rxjs/_esm2015/internal/operators/elementAt.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "elementAt", function () {
      return _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__["elementAt"];
    });
    /* harmony import */


    var _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! ../internal/operators/endWith */
    "../../node_modules/rxjs/_esm2015/internal/operators/endWith.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "endWith", function () {
      return _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__["endWith"];
    });
    /* harmony import */


    var _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! ../internal/operators/every */
    "../../node_modules/rxjs/_esm2015/internal/operators/every.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "every", function () {
      return _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__["every"];
    });
    /* harmony import */


    var _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! ../internal/operators/exhaust */
    "../../node_modules/rxjs/_esm2015/internal/operators/exhaust.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "exhaust", function () {
      return _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__["exhaust"];
    });
    /* harmony import */


    var _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! ../internal/operators/exhaustMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "exhaustMap", function () {
      return _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__["exhaustMap"];
    });
    /* harmony import */


    var _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! ../internal/operators/expand */
    "../../node_modules/rxjs/_esm2015/internal/operators/expand.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "expand", function () {
      return _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__["expand"];
    });
    /* harmony import */


    var _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! ../internal/operators/filter */
    "../../node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "filter", function () {
      return _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__["filter"];
    });
    /* harmony import */


    var _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! ../internal/operators/finalize */
    "../../node_modules/rxjs/_esm2015/internal/operators/finalize.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "finalize", function () {
      return _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__["finalize"];
    });
    /* harmony import */


    var _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! ../internal/operators/find */
    "../../node_modules/rxjs/_esm2015/internal/operators/find.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "find", function () {
      return _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__["find"];
    });
    /* harmony import */


    var _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
    /*! ../internal/operators/findIndex */
    "../../node_modules/rxjs/_esm2015/internal/operators/findIndex.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "findIndex", function () {
      return _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__["findIndex"];
    });
    /* harmony import */


    var _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
    /*! ../internal/operators/first */
    "../../node_modules/rxjs/_esm2015/internal/operators/first.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "first", function () {
      return _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__["first"];
    });
    /* harmony import */


    var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
    /*! ../internal/operators/groupBy */
    "../../node_modules/rxjs/_esm2015/internal/operators/groupBy.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "groupBy", function () {
      return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__["groupBy"];
    });
    /* harmony import */


    var _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
    /*! ../internal/operators/ignoreElements */
    "../../node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ignoreElements", function () {
      return _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__["ignoreElements"];
    });
    /* harmony import */


    var _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(
    /*! ../internal/operators/isEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/isEmpty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "isEmpty", function () {
      return _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__["isEmpty"];
    });
    /* harmony import */


    var _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(
    /*! ../internal/operators/last */
    "../../node_modules/rxjs/_esm2015/internal/operators/last.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "last", function () {
      return _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__["last"];
    });
    /* harmony import */


    var _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(
    /*! ../internal/operators/map */
    "../../node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "map", function () {
      return _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__["map"];
    });
    /* harmony import */


    var _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(
    /*! ../internal/operators/mapTo */
    "../../node_modules/rxjs/_esm2015/internal/operators/mapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mapTo", function () {
      return _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__["mapTo"];
    });
    /* harmony import */


    var _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(
    /*! ../internal/operators/materialize */
    "../../node_modules/rxjs/_esm2015/internal/operators/materialize.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "materialize", function () {
      return _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__["materialize"];
    });
    /* harmony import */


    var _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(
    /*! ../internal/operators/max */
    "../../node_modules/rxjs/_esm2015/internal/operators/max.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "max", function () {
      return _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__["max"];
    });
    /* harmony import */


    var _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(
    /*! ../internal/operators/merge */
    "../../node_modules/rxjs/_esm2015/internal/operators/merge.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__["merge"];
    });
    /* harmony import */


    var _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(
    /*! ../internal/operators/mergeAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeAll", function () {
      return _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__["mergeAll"];
    });
    /* harmony import */


    var _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(
    /*! ../internal/operators/mergeMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeMap", function () {
      return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "flatMap", function () {
      return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"];
    });
    /* harmony import */


    var _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(
    /*! ../internal/operators/mergeMapTo */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeMapTo", function () {
      return _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__["mergeMapTo"];
    });
    /* harmony import */


    var _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(
    /*! ../internal/operators/mergeScan */
    "../../node_modules/rxjs/_esm2015/internal/operators/mergeScan.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeScan", function () {
      return _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__["mergeScan"];
    });
    /* harmony import */


    var _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(
    /*! ../internal/operators/min */
    "../../node_modules/rxjs/_esm2015/internal/operators/min.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "min", function () {
      return _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__["min"];
    });
    /* harmony import */


    var _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(
    /*! ../internal/operators/multicast */
    "../../node_modules/rxjs/_esm2015/internal/operators/multicast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "multicast", function () {
      return _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__["multicast"];
    });
    /* harmony import */


    var _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(
    /*! ../internal/operators/observeOn */
    "../../node_modules/rxjs/_esm2015/internal/operators/observeOn.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "observeOn", function () {
      return _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__["observeOn"];
    });
    /* harmony import */


    var _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(
    /*! ../internal/operators/onErrorResumeNext */
    "../../node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function () {
      return _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__["onErrorResumeNext"];
    });
    /* harmony import */


    var _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(
    /*! ../internal/operators/pairwise */
    "../../node_modules/rxjs/_esm2015/internal/operators/pairwise.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "pairwise", function () {
      return _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__["pairwise"];
    });
    /* harmony import */


    var _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(
    /*! ../internal/operators/partition */
    "../../node_modules/rxjs/_esm2015/internal/operators/partition.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "partition", function () {
      return _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__["partition"];
    });
    /* harmony import */


    var _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(
    /*! ../internal/operators/pluck */
    "../../node_modules/rxjs/_esm2015/internal/operators/pluck.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "pluck", function () {
      return _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__["pluck"];
    });
    /* harmony import */


    var _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(
    /*! ../internal/operators/publish */
    "../../node_modules/rxjs/_esm2015/internal/operators/publish.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publish", function () {
      return _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__["publish"];
    });
    /* harmony import */


    var _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(
    /*! ../internal/operators/publishBehavior */
    "../../node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publishBehavior", function () {
      return _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__["publishBehavior"];
    });
    /* harmony import */


    var _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(
    /*! ../internal/operators/publishLast */
    "../../node_modules/rxjs/_esm2015/internal/operators/publishLast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publishLast", function () {
      return _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__["publishLast"];
    });
    /* harmony import */


    var _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(
    /*! ../internal/operators/publishReplay */
    "../../node_modules/rxjs/_esm2015/internal/operators/publishReplay.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publishReplay", function () {
      return _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__["publishReplay"];
    });
    /* harmony import */


    var _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(
    /*! ../internal/operators/race */
    "../../node_modules/rxjs/_esm2015/internal/operators/race.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__["race"];
    });
    /* harmony import */


    var _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(
    /*! ../internal/operators/reduce */
    "../../node_modules/rxjs/_esm2015/internal/operators/reduce.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "reduce", function () {
      return _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__["reduce"];
    });
    /* harmony import */


    var _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(
    /*! ../internal/operators/repeat */
    "../../node_modules/rxjs/_esm2015/internal/operators/repeat.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "repeat", function () {
      return _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__["repeat"];
    });
    /* harmony import */


    var _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(
    /*! ../internal/operators/repeatWhen */
    "../../node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "repeatWhen", function () {
      return _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__["repeatWhen"];
    });
    /* harmony import */


    var _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(
    /*! ../internal/operators/retry */
    "../../node_modules/rxjs/_esm2015/internal/operators/retry.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "retry", function () {
      return _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__["retry"];
    });
    /* harmony import */


    var _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(
    /*! ../internal/operators/retryWhen */
    "../../node_modules/rxjs/_esm2015/internal/operators/retryWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "retryWhen", function () {
      return _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__["retryWhen"];
    });
    /* harmony import */


    var _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(
    /*! ../internal/operators/refCount */
    "../../node_modules/rxjs/_esm2015/internal/operators/refCount.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "refCount", function () {
      return _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__["refCount"];
    });
    /* harmony import */


    var _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(
    /*! ../internal/operators/sample */
    "../../node_modules/rxjs/_esm2015/internal/operators/sample.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "sample", function () {
      return _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__["sample"];
    });
    /* harmony import */


    var _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(
    /*! ../internal/operators/sampleTime */
    "../../node_modules/rxjs/_esm2015/internal/operators/sampleTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "sampleTime", function () {
      return _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__["sampleTime"];
    });
    /* harmony import */


    var _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(
    /*! ../internal/operators/scan */
    "../../node_modules/rxjs/_esm2015/internal/operators/scan.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "scan", function () {
      return _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__["scan"];
    });
    /* harmony import */


    var _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(
    /*! ../internal/operators/sequenceEqual */
    "../../node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "sequenceEqual", function () {
      return _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__["sequenceEqual"];
    });
    /* harmony import */


    var _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(
    /*! ../internal/operators/share */
    "../../node_modules/rxjs/_esm2015/internal/operators/share.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "share", function () {
      return _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__["share"];
    });
    /* harmony import */


    var _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(
    /*! ../internal/operators/shareReplay */
    "../../node_modules/rxjs/_esm2015/internal/operators/shareReplay.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "shareReplay", function () {
      return _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__["shareReplay"];
    });
    /* harmony import */


    var _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(
    /*! ../internal/operators/single */
    "../../node_modules/rxjs/_esm2015/internal/operators/single.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "single", function () {
      return _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__["single"];
    });
    /* harmony import */


    var _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(
    /*! ../internal/operators/skip */
    "../../node_modules/rxjs/_esm2015/internal/operators/skip.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skip", function () {
      return _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__["skip"];
    });
    /* harmony import */


    var _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(
    /*! ../internal/operators/skipLast */
    "../../node_modules/rxjs/_esm2015/internal/operators/skipLast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skipLast", function () {
      return _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__["skipLast"];
    });
    /* harmony import */


    var _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(
    /*! ../internal/operators/skipUntil */
    "../../node_modules/rxjs/_esm2015/internal/operators/skipUntil.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skipUntil", function () {
      return _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__["skipUntil"];
    });
    /* harmony import */


    var _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(
    /*! ../internal/operators/skipWhile */
    "../../node_modules/rxjs/_esm2015/internal/operators/skipWhile.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skipWhile", function () {
      return _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__["skipWhile"];
    });
    /* harmony import */


    var _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(
    /*! ../internal/operators/startWith */
    "../../node_modules/rxjs/_esm2015/internal/operators/startWith.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "startWith", function () {
      return _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__["startWith"];
    });
    /* harmony import */


    var _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(
    /*! ../internal/operators/subscribeOn */
    "../../node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "subscribeOn", function () {
      return _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__["subscribeOn"];
    });
    /* harmony import */


    var _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(
    /*! ../internal/operators/switchAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/switchAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "switchAll", function () {
      return _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__["switchAll"];
    });
    /* harmony import */


    var _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(
    /*! ../internal/operators/switchMap */
    "../../node_modules/rxjs/_esm2015/internal/operators/switchMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "switchMap", function () {
      return _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__["switchMap"];
    });
    /* harmony import */


    var _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(
    /*! ../internal/operators/switchMapTo */
    "../../node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "switchMapTo", function () {
      return _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__["switchMapTo"];
    });
    /* harmony import */


    var _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(
    /*! ../internal/operators/take */
    "../../node_modules/rxjs/_esm2015/internal/operators/take.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "take", function () {
      return _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__["take"];
    });
    /* harmony import */


    var _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(
    /*! ../internal/operators/takeLast */
    "../../node_modules/rxjs/_esm2015/internal/operators/takeLast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "takeLast", function () {
      return _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__["takeLast"];
    });
    /* harmony import */


    var _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(
    /*! ../internal/operators/takeUntil */
    "../../node_modules/rxjs/_esm2015/internal/operators/takeUntil.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "takeUntil", function () {
      return _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__["takeUntil"];
    });
    /* harmony import */


    var _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(
    /*! ../internal/operators/takeWhile */
    "../../node_modules/rxjs/_esm2015/internal/operators/takeWhile.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "takeWhile", function () {
      return _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__["takeWhile"];
    });
    /* harmony import */


    var _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(
    /*! ../internal/operators/tap */
    "../../node_modules/rxjs/_esm2015/internal/operators/tap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "tap", function () {
      return _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__["tap"];
    });
    /* harmony import */


    var _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(
    /*! ../internal/operators/throttle */
    "../../node_modules/rxjs/_esm2015/internal/operators/throttle.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throttle", function () {
      return _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__["throttle"];
    });
    /* harmony import */


    var _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(
    /*! ../internal/operators/throttleTime */
    "../../node_modules/rxjs/_esm2015/internal/operators/throttleTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throttleTime", function () {
      return _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__["throttleTime"];
    });
    /* harmony import */


    var _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(
    /*! ../internal/operators/throwIfEmpty */
    "../../node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function () {
      return _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__["throwIfEmpty"];
    });
    /* harmony import */


    var _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(
    /*! ../internal/operators/timeInterval */
    "../../node_modules/rxjs/_esm2015/internal/operators/timeInterval.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timeInterval", function () {
      return _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__["timeInterval"];
    });
    /* harmony import */


    var _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(
    /*! ../internal/operators/timeout */
    "../../node_modules/rxjs/_esm2015/internal/operators/timeout.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timeout", function () {
      return _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__["timeout"];
    });
    /* harmony import */


    var _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(
    /*! ../internal/operators/timeoutWith */
    "../../node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timeoutWith", function () {
      return _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__["timeoutWith"];
    });
    /* harmony import */


    var _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(
    /*! ../internal/operators/timestamp */
    "../../node_modules/rxjs/_esm2015/internal/operators/timestamp.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timestamp", function () {
      return _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__["timestamp"];
    });
    /* harmony import */


    var _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(
    /*! ../internal/operators/toArray */
    "../../node_modules/rxjs/_esm2015/internal/operators/toArray.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "toArray", function () {
      return _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__["toArray"];
    });
    /* harmony import */


    var _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(
    /*! ../internal/operators/window */
    "../../node_modules/rxjs/_esm2015/internal/operators/window.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "window", function () {
      return _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__["window"];
    });
    /* harmony import */


    var _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(
    /*! ../internal/operators/windowCount */
    "../../node_modules/rxjs/_esm2015/internal/operators/windowCount.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowCount", function () {
      return _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__["windowCount"];
    });
    /* harmony import */


    var _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(
    /*! ../internal/operators/windowTime */
    "../../node_modules/rxjs/_esm2015/internal/operators/windowTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowTime", function () {
      return _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__["windowTime"];
    });
    /* harmony import */


    var _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(
    /*! ../internal/operators/windowToggle */
    "../../node_modules/rxjs/_esm2015/internal/operators/windowToggle.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowToggle", function () {
      return _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__["windowToggle"];
    });
    /* harmony import */


    var _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(
    /*! ../internal/operators/windowWhen */
    "../../node_modules/rxjs/_esm2015/internal/operators/windowWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowWhen", function () {
      return _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__["windowWhen"];
    });
    /* harmony import */


    var _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(
    /*! ../internal/operators/withLatestFrom */
    "../../node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "withLatestFrom", function () {
      return _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__["withLatestFrom"];
    });
    /* harmony import */


    var _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(
    /*! ../internal/operators/zip */
    "../../node_modules/rxjs/_esm2015/internal/operators/zip.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__["zip"];
    });
    /* harmony import */


    var _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(
    /*! ../internal/operators/zipAll */
    "../../node_modules/rxjs/_esm2015/internal/operators/zipAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "zipAll", function () {
      return _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__["zipAll"];
    }); //# sourceMappingURL=index.js.map

    /***/

  },

  /***/
  "../../node_modules/tslib/tslib.es6.js":
  /*!******************************************************************************!*\
    !*** /Users/mamadou/Desktop/PL/platon-front/node_modules/tslib/tslib.es6.js ***!
    \******************************************************************************/

  /*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */

  /***/
  function node_modulesTslibTslibEs6Js(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__extends", function () {
      return __extends;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__assign", function () {
      return _assign;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__rest", function () {
      return __rest;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__decorate", function () {
      return __decorate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__param", function () {
      return __param;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__metadata", function () {
      return __metadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__awaiter", function () {
      return __awaiter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__generator", function () {
      return __generator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__createBinding", function () {
      return __createBinding;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__exportStar", function () {
      return __exportStar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__values", function () {
      return __values;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__read", function () {
      return __read;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__spread", function () {
      return __spread;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__spreadArrays", function () {
      return __spreadArrays;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__await", function () {
      return __await;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function () {
      return __asyncGenerator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function () {
      return __asyncDelegator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncValues", function () {
      return __asyncValues;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function () {
      return __makeTemplateObject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__importStar", function () {
      return __importStar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__importDefault", function () {
      return __importDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function () {
      return __classPrivateFieldGet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function () {
      return __classPrivateFieldSet;
    });
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */


    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    function __rest(s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }

    function __decorate(decorators, target, key, desc) {
      var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    }

    function __metadata(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    function __createBinding(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    }

    function __exportStar(m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
    }

    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function next() {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
          r,
          ar = [],
          e;

      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
          ar.push(r.value);
        }
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }

      return ar;
    }

    function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
      }

      return ar;
    }

    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
      }

      for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
          r[k] = a[j];
        }
      }

      return r;
    }

    ;

    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i;

      function verb(n) {
        if (g[n]) i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }

      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }

      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }

      function fulfill(value) {
        resume("next", value);
      }

      function reject(value) {
        resume("throw", value);
      }

      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }

    function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function () {
        return this;
      }, i;

      function verb(n, f) {
        i[n] = o[n] ? function (v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: n === "return"
          } : f ? f(v) : v;
        } : f;
      }
    }

    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator],
          i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i);

      function verb(n) {
        i[n] = o[n] && function (v) {
          return new Promise(function (resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }

      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
          resolve({
            value: v,
            done: d
          });
        }, reject);
      }
    }

    function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
          value: raw
        });
      } else {
        cooked.raw = raw;
      }

      return cooked;
    }

    ;

    function __importStar(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    }

    function __importDefault(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      privateMap.set(receiver, value);
      return value;
    }
    /***/

  },

  /***/
  "./src/app/app-routing.module.ts":
  /*!***************************************!*\
    !*** ./src/app/app-routing.module.ts ***!
    \***************************************/

  /*! exports provided: AppRoutingModule */

  /***/
  function srcAppAppRoutingModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AppRoutingModule", function () {
      return AppRoutingModule;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/router */
    "../../node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common */
    "@angular/common");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_2__);

    var routes = [];

    var AppRoutingModule = function AppRoutingModule() {
      _classCallCheck(this, AppRoutingModule);
    };

    AppRoutingModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: AppRoutingModule
    });
    AppRoutingModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function AppRoutingModule_Factory(t) {
        return new (t || AppRoutingModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"].forRoot(routes, {
        enableTracing: false,
        initialNavigation: 'enabled',
        preloadingStrategy: _angular_router__WEBPACK_IMPORTED_MODULE_1__["PreloadAllModules"]
      })], _angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](AppRoutingModule, {
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]],
        exports: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AppRoutingModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"].forRoot(routes, {
            enableTracing: false,
            initialNavigation: 'enabled',
            preloadingStrategy: _angular_router__WEBPACK_IMPORTED_MODULE_1__["PreloadAllModules"]
          })],
          exports: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]]
        }]
      }], null, null);
    })();
    /***/

  },

  /***/
  "./src/app/app.component.ts":
  /*!**********************************!*\
    !*** ./src/app/app.component.ts ***!
    \**********************************/

  /*! exports provided: AppComponent */

  /***/
  function srcAppAppComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AppComponent", function () {
      return AppComponent;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/router */
    "../../node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js");

    var AppComponent = function AppComponent() {
      _classCallCheck(this, AppComponent);

      this.title = 'ghpage';
    };

    AppComponent.ɵfac = function AppComponent_Factory(t) {
      return new (t || AppComponent)();
    };

    AppComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: AppComponent,
      selectors: [["app-root"]],
      decls: 56,
      vars: 1,
      consts: [[1, "flex"], ["alt", "Nx logo", "width", "75", "src", "https://nx.dev/assets/images/nx-logo-white.svg"], [1, "flex", "github-star-container"], ["href", "https://github.com/nrwl/nx", "target", "_blank", "rel", "noopener noreferrer"], [1, "github-star-badge"], ["xmlns", "http://www.w3.org/2000/svg", "width", "24", "height", "24", "viewBox", "0 0 24 24", 1, "material-icons"], ["d", "M0 0h24v24H0z", "fill", "none"], ["d", "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"], [1, "resources"], [1, "col-span-2"], ["href", "https://connect.nrwl.io/app/courses/nx-workspaces/intro", 1, "resource", "flex"], ["href", "https://nx.dev/angular/getting-started/what-is-nx", 1, "resource", "flex"], ["href", "https://nx.dev/angular/tutorial/01-create-application", 1, "resource", "flex"], ["href", "https://nx.app/", 1, "resource", "flex"], ["width", "36", "height", "36", "viewBox", "0 0 120 120", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["d", "M120 15V30C103.44 30 90 43.44 90 60C90 76.56 76.56 90 60 90C43.44 90 30 103.44 30 120H15C6.72 120 0 113.28 0 105V15C0 6.72 6.72 0 15 0H105C113.28 0 120 6.72 120 15Z", "fill", "#0E2039"], ["d", "M120 30V105C120 113.28 113.28 120 105 120H30C30 103.44 43.44 90 60 90C76.56 90 90 76.56 90 60C90 43.44 103.44 30 120 30Z", "fill", "white"], [1, "gutter-left"], ["open", ""]],
      template: function AppComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "header", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "img", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "h1");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "main");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "h2");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](6, "Resources & Tools");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](7, "p");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](8, " Thank you for using and showing some \u2665 for Nx. ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](9, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](10, "a", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](11, " If you like Nx, please give it a star: ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](12, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceSVG"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](13, "svg", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](14, "path", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](15, "path", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](16, " Star ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceHTML"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](17, "p");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](18, " Here are some links to help you get started. ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](19, "ul", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](20, "li", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](21, "a", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](22, " Nx video course ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](23, "li", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](24, "a", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](25, " Nx video tutorial ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](26, "li", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](27, "a", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](28, " Interactive tutorial ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](29, "li", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](30, "a", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceSVG"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](31, "svg", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](32, "path", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](33, "path", 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceHTML"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](34, "span", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](35, "Nx Cloud");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](36, "h2");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](37, "Next Steps");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](38, "p");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](39, "Here are some things you can do with Nx.");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](40, "details", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](41, "summary");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](42, "Add UI library");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](43, "pre");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](44, "# Generate UI lib\nng g @nrwl/angular:lib ui\n\n# Add a component\nng g @nrwl/angular:component xyz --project ui");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](45, "details");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](46, "summary");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](47, "View dependency graph");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](48, "pre");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](49, "nx dep-graph");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](50, "details");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](51, "summary");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](52, "Run affected commands");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](53, "pre");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](54, "# see what's been affected by changes\nng affected:dep-graph\n\n# run tests for current changes\nng affected:test\n\n# run e2e tests for current changes\nng affected:e2e\n");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](55, "router-outlet");
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("Welcome to ", ctx.title, "!");
        }
      },
      directives: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterOutlet"]],
      styles: ["[_nghost-%COMP%] {\n  display: block;\n  font-family: sans-serif;\n  min-width: 300px;\n  max-width: 600px;\n  margin: 50px auto;\n}\n.gutter-left[_ngcontent-%COMP%] {\n  margin-left: 9px;\n}\n.col-span-2[_ngcontent-%COMP%] {\n  grid-column: span 2;\n}\n.flex[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\nheader[_ngcontent-%COMP%] {\n  background-color: #143055;\n  color: white;\n  padding: 5px;\n  border-radius: 3px;\n}\nmain[_ngcontent-%COMP%] {\n  padding: 0 36px;\n}\np[_ngcontent-%COMP%] {\n  text-align: center;\n}\nh1[_ngcontent-%COMP%] {\n  text-align: center;\n  margin-left: 18px;\n  font-size: 24px;\n}\nh2[_ngcontent-%COMP%] {\n  text-align: center;\n  font-size: 20px;\n  margin: 40px 0 10px 0;\n}\n.resources[_ngcontent-%COMP%] {\n  text-align: center;\n  list-style: none;\n  padding: 0;\n  display: grid;\n  grid-gap: 9px;\n  grid-template-columns: 1fr 1fr;\n}\n.resource[_ngcontent-%COMP%] {\n  color: #0094ba;\n  height: 36px;\n  background-color: rgba(0, 0, 0, 0);\n  border: 1px solid rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  padding: 3px 9px;\n  text-decoration: none;\n}\n.resource[_ngcontent-%COMP%]:hover {\n  background-color: rgba(68, 138, 255, 0.04);\n}\npre[_ngcontent-%COMP%] {\n  padding: 9px;\n  border-radius: 4px;\n  background-color: black;\n  color: #eee;\n}\ndetails[_ngcontent-%COMP%] {\n  border-radius: 4px;\n  color: #333;\n  background-color: rgba(0, 0, 0, 0);\n  border: 1px solid rgba(0, 0, 0, 0.12);\n  padding: 3px 9px;\n  margin-bottom: 9px;\n}\nsummary[_ngcontent-%COMP%] {\n  cursor: pointer;\n  outline: none;\n  height: 36px;\n  line-height: 36px;\n}\n.github-star-container[_ngcontent-%COMP%] {\n  margin-top: 12px;\n  line-height: 20px;\n}\n.github-star-container[_ngcontent-%COMP%]   a[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  text-decoration: none;\n  color: #333;\n}\n.github-star-badge[_ngcontent-%COMP%] {\n  color: #24292e;\n  display: flex;\n  align-items: center;\n  font-size: 12px;\n  padding: 3px 10px;\n  border: 1px solid rgba(27, 31, 35, 0.2);\n  border-radius: 3px;\n  background-image: linear-gradient(-180deg, #fafbfc, #eff3f6 90%);\n  margin-left: 4px;\n  font-weight: 600;\n}\n.github-star-badge[_ngcontent-%COMP%]:hover {\n  background-image: linear-gradient(-180deg, #f0f3f6, #e6ebf1 90%);\n  border-color: rgba(27, 31, 35, 0.35);\n  background-position: -0.5em;\n}\n.github-star-badge[_ngcontent-%COMP%]   .material-icons[_ngcontent-%COMP%] {\n  height: 16px;\n  width: 16px;\n  margin-right: 4px;\n}"]
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AppComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'app-root',
          templateUrl: './app.component.html',
          styleUrls: ['./app.component.scss']
        }]
      }], null, null);
    })();
    /***/

  },

  /***/
  "./src/app/app.module.ts":
  /*!*******************************!*\
    !*** ./src/app/app.module.ts ***!
    \*******************************/

  /*! exports provided: AppModule */

  /***/
  function srcAppAppModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AppModule", function () {
      return AppModule;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/platform-browser */
    "@angular/platform-browser");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/platform-browser/animations */
    "../../node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js");
    /* harmony import */


    var _juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @juristr/ngx-lazy-el */
    "../../node_modules/@juristr/ngx-lazy-el/__ivy_ngcc__/fesm2015/juristr-ngx-lazy-el.js");
    /* harmony import */


    var _platon_webcomponents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @platon/webcomponents */
    "../../libs/webcomponents/src/index.ts");
    /* harmony import */


    var _platon_shared_vendors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @platon/shared/vendors */
    "../../libs/shared/vendors/src/index.ts");
    /* harmony import */


    var _app_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./app.component */
    "./src/app/app.component.ts");
    /* harmony import */


    var _app_routing_module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./app-routing.module */
    "./src/app/app-routing.module.ts"); // ANGULAR
    // LIBS
    // MODULE


    var AppModule = function AppModule() {
      _classCallCheck(this, AppModule);
    };

    AppModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: AppModule,
      bootstrap: [_app_component__WEBPACK_IMPORTED_MODULE_6__["AppComponent"]]
    });
    AppModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function AppModule_Factory(t) {
        return new (t || AppModule)();
      },
      providers: [],
      imports: [[_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"], _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__["BrowserAnimationsModule"], _app_routing_module__WEBPACK_IMPORTED_MODULE_7__["AppRoutingModule"], _platon_shared_vendors__WEBPACK_IMPORTED_MODULE_5__["SharedVendorsModule"], _platon_webcomponents__WEBPACK_IMPORTED_MODULE_4__["WebComponentsModule"], _juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_3__["NgxLazyElModule"].forRoot(_platon_webcomponents__WEBPACK_IMPORTED_MODULE_4__["WEB_COMPONENTS_REGISTRY"])]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](AppModule, {
        declarations: [_app_component__WEBPACK_IMPORTED_MODULE_6__["AppComponent"]],
        imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"], _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__["BrowserAnimationsModule"], _app_routing_module__WEBPACK_IMPORTED_MODULE_7__["AppRoutingModule"], _platon_shared_vendors__WEBPACK_IMPORTED_MODULE_5__["SharedVendorsModule"], _platon_webcomponents__WEBPACK_IMPORTED_MODULE_4__["WebComponentsModule"], _juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_3__["NgxLazyElModule"]]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AppModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          declarations: [_app_component__WEBPACK_IMPORTED_MODULE_6__["AppComponent"]],
          imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"], _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__["BrowserAnimationsModule"], _app_routing_module__WEBPACK_IMPORTED_MODULE_7__["AppRoutingModule"], _platon_shared_vendors__WEBPACK_IMPORTED_MODULE_5__["SharedVendorsModule"], _platon_webcomponents__WEBPACK_IMPORTED_MODULE_4__["WebComponentsModule"], _juristr_ngx_lazy_el__WEBPACK_IMPORTED_MODULE_3__["NgxLazyElModule"].forRoot(_platon_webcomponents__WEBPACK_IMPORTED_MODULE_4__["WEB_COMPONENTS_REGISTRY"])],
          providers: [],
          schemas: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["CUSTOM_ELEMENTS_SCHEMA"]],
          bootstrap: [_app_component__WEBPACK_IMPORTED_MODULE_6__["AppComponent"]]
        }]
      }], null, null);
    })();
    /***/

  },

  /***/
  "./src/environments/environment.ts":
  /*!*****************************************!*\
    !*** ./src/environments/environment.ts ***!
    \*****************************************/

  /*! exports provided: environment */

  /***/
  function srcEnvironmentsEnvironmentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "environment", function () {
      return environment;
    });

    var environment = {
      production: true
    };
    /***/
  },

  /***/
  "./src/main.ts":
  /*!*********************!*\
    !*** ./src/main.ts ***!
    \*********************/

  /*! no exports provided */

  /***/
  function srcMainTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "@angular/core");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var _environments_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./environments/environment */
    "./src/environments/environment.ts");
    /* harmony import */


    var _app_app_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./app/app.module */
    "./src/app/app.module.ts");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/platform-browser */
    "@angular/platform-browser");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__);

    if (_environments_environment__WEBPACK_IMPORTED_MODULE_1__["environment"].production) {
      Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["enableProdMode"])();
    }

    _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__["platformBrowser"]().bootstrapModule(_app_app_module__WEBPACK_IMPORTED_MODULE_2__["AppModule"])["catch"](function (err) {
      return console.error(err);
    });
    /***/

  },

  /***/
  0:
  /*!***************************!*\
    !*** multi ./src/main.ts ***!
    \***************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! /Users/mamadou/Desktop/PL/platon-front/apps/ghpage/src/main.ts */
    "./src/main.ts");
    /***/
  },

  /***/
  "@angular/common":
  /*!****************************!*\
    !*** external "ng.common" ***!
    \****************************/

  /*! no static exports found */

  /***/
  function angularCommon(module, exports) {
    module.exports = ng.common;
    /***/
  },

  /***/
  "@angular/core":
  /*!**************************!*\
    !*** external "ng.core" ***!
    \**************************/

  /*! no static exports found */

  /***/
  function angularCore(module, exports) {
    module.exports = ng.core;
    /***/
  },

  /***/
  "@angular/elements":
  /*!******************************!*\
    !*** external "ng.elements" ***!
    \******************************/

  /*! no static exports found */

  /***/
  function angularElements(module, exports) {
    module.exports = ng.elements;
    /***/
  },

  /***/
  "@angular/platform-browser":
  /*!*************************************!*\
    !*** external "ng.platformBrowser" ***!
    \*************************************/

  /*! no static exports found */

  /***/
  function angularPlatformBrowser(module, exports) {
    module.exports = ng.platformBrowser;
    /***/
  },

  /***/
  "rxjs":
  /*!***********************!*\
    !*** external "rxjs" ***!
    \***********************/

  /*! no static exports found */

  /***/
  function (_rxjs) {
    function rxjs(_x, _x2) {
      return _rxjs.apply(this, arguments);
    }

    rxjs.toString = function () {
      return _rxjs.toString();
    };

    return rxjs;
  }(function (module, exports) {
    module.exports = rxjs;
    /***/
  })
  /******/

});